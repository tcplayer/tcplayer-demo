/**
 * @license
 * Video.js 4.6.0 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.TCPlayer = factory());
}(this, (function () {

var version = "4.6.0";

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

var window_1 = win;

var empty = {};


var empty$1 = (Object.freeze || Object)({
	'default': empty
});

var minDoc = ( empty$1 && empty ) || empty$1;

var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};


var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

var document_1 = doccy;

/**
 * @file browser.js
 * @module browser
 */
var USER_AGENT = window_1.navigator && window_1.navigator.userAgent || '';
var VENDOR = window_1.navigator && window_1.navigator.vendor || '';
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);

  if (match && match[1]) {
    return match[1];
  }
  return null;
}();
var IOS_VERSION_ARRAY = function () {
  var match = USER_AGENT.match(/OS (\d+)_(\d+)_?(\d+)?/i);
  return match && [parseInt(match[1], 10), parseInt(match[2], 10), parseInt(match[3] || '0', 10)] || [];
}();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

  if (!match) {
    return null;
  }

  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();

var IS_TBS = /TBS\/\d+/i.test(USER_AGENT); // 仅X5内核，QQ浏览器默认x5内核，但是agent没有TBS
var TBS_VERSION = function () {
  var match = USER_AGENT.match(/TBS\/(\d+)/i);
  if (match && match[1]) {
    return match[1];
  }
}(); // X5内核版本

var IS_MQQB = !IS_TBS && /MQQBrowser\/\d+/i.test(USER_AGENT); // 移动端QQ浏览器 android QQ也为true
var IS_QQB = !IS_TBS && / QQBrowser\/\d+/i.test(USER_AGENT); // pc端QQ浏览器
var IS_PC_WECHAT = /windowswechat/i.test(USER_AGENT); // 3.3 版本之后的 pc 微信客户端浏览器
var IS_WECHAT = /(micromessenger|webbrowser)/i.test(USER_AGENT); // 微信浏览器
// export const IS_MQQ = !IS_TBS &&(/(QBWebViewType)/i).test(USER_AGENT); // 手机QQ内置浏览器 不是很可靠 需要搭配 IS_IOS 来用
var IS_MQQ = / QQ\/\d+/i.test(USER_AGENT); // 手机QQ内置浏览器

// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edge/i.test(USER_AGENT);
var IS_EDG = /Edg/i.test(USER_AGENT); // edge new agent flag
var EDG_VERSION = IS_EDG && function () {
  var match = USER_AGENT.match(/Edg\/(\d+)/);
  if (match && match[1]) {
    return parseFloat(match[1]);
  }
  return null;
}();
// export const IS_CHROME = !IS_EDGE && (/Chrome/i).test(USER_AGENT);
var IS_CHROME = function () {
  if (!IS_EDGE && /Chrome/i.test(USER_AGENT)) {
    return true;
  } else if (/Safari/i.test(USER_AGENT) && /CriOS/i.test(USER_AGENT)) {
    // ios chrome
    return true;
  }
  return false;
}() && !IS_WECHAT && !IS_MQQB && !IS_QQB;
var CHROME_VERSION = function () {
  var match = USER_AGENT.match(/Chrome\/(\d+)/);
  var matchIOS = USER_AGENT.match(/CriOS\/(\d+)/);
  if (match && match[1]) {
    return parseFloat(match[1]);
  } else if (matchIOS && matchIOS[1]) {
    return parseFloat(matchIOS[1]);
  }
  return null;
}();

var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
var IE_VERSION = function () {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version = result && parseFloat(result[1]);

  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    // IE 11 has a different user agent string than other IE versions
    version = 11.0;
  }

  return version;
}();

var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE && !IS_MQQB && !IS_QQB && !IS_PC_WECHAT;
var IS_ANY_SAFARI = IS_SAFARI || IS_IOS;
var IS_SAFARI_NOT_SIMULATOR = IS_SAFARI && VENDOR !== 'Google Inc.'; // 部分浏览器下vendor值有可能为空，只拎出chrome来就可以，此优化主要针对开发者
var IS_UC = /UCBrowser\/(\d+)\./i.test(USER_AGENT); // UC浏览器

var TOUCH_ENABLED = isReal() && ('ontouchstart' in window_1 || window_1.DocumentTouch && window_1.document instanceof window_1.DocumentTouch);

var BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window_1.document.createElement('video').style;

var IS_WIN = /Windows/i.test(USER_AGENT); // window系统
var IS_MAC = /MAC OS X/i.test(USER_AGENT); // MAC系统，先检查IOS

var WIN_VER = function () {
  // window版本
  /Windows NT ([.\w]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var MAC_VER = function () {
  // mac版本(暂时忽略iMac)
  /Mac OS X (\w+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var QQ_VER = function () {
  // qq浏览器版本
  /QQBrowser\/([.\d]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var EDGE_VER = function () {
  // Edge版本
  /Edge\/([.\d]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var SAFARI_VER = function () {
  // Edge版本
  /Version\/([.\d]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var FIREFOX_VER = function () {
  // firefox版本
  /Firefox\/([.\d]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var CHROME_VER = function () {
  /Chrome\/([.\d]+)/.test(USER_AGENT);
  return RegExp.$1;
}();

var IS_HUAWEI = /HUAWEI|honor|HMA/i.test(USER_AGENT); // 华为
var IS_XIAOMI = /HM|RedMi|Mi/i.test(USER_AGENT) && !IS_HUAWEI; // 小米
var IS_OPPO = /OPPO/i.test(USER_AGENT); // oppo
var IS_VIVO = /VIVO/i.test(USER_AGENT); // vivo
var IS_SX = /GT-|SM-|SCH-/i.test(USER_AGENT); // 三星
var IS_ONE = /ONE/i.test(USER_AGENT); // 一加
var IS_CP = /Coolpad/i.test(USER_AGENT); // 酷派
var IS_ZX = /ZTE/i.test(USER_AGENT); // 中兴


var isWebRTCAPISupported = function isWebRTCAPISupported() {
  var apiList = ['RTCPeerConnection', 'webkitRTCPeerConnection', 'RTCIceGatherer'];
  return apiList.filter(function (api) {
    return api in window_1;
  }).length > 0;
};

// 支持chrome浏览器，safari浏览器，firefox浏览器（M56+）, edge浏览器（M80+）
var isWebRTCSupported = function isWebRTCSupported() {
  var MIN_FIREFOX_VERSION = 56;
  var MIN_EDG_VERSION = 80;
  if (IS_UC || IS_EDGE) {
    return false;
  }
  if (IS_EDG && EDG_VERSION < MIN_EDG_VERSION) {
    return false;
  }
  if (IS_FIREFOX && FIREFOX_VER < MIN_FIREFOX_VERSION) {
    return false;
  }

  if (!IS_TBS && IS_SAFARI && IS_IOS) {
    // iOS 11.1.2 以下版本不支持
    if (IOS_VERSION_ARRAY.length === 0 || IOS_VERSION_ARRAY[0] < 11 || IOS_VERSION_ARRAY[0] === 11 && IOS_VERSION_ARRAY[1] < 1 || IOS_VERSION_ARRAY[0] === 11 && IOS_VERSION_ARRAY[1] === 1 && IOS_VERSION_ARRAY[2] < 2) {
      return false;
    }
  }
  return isWebRTCAPISupported();
};

var IS_ENABLED_MSE = function () {
  var mediaSource = window_1.MediaSource = window_1.MediaSource || window_1.WebKitMediaSource;
  var sourceBuffer = window_1.SourceBuffer = window_1.SourceBuffer || window_1.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  // ios13 部分开放了MSE 但支持不完整，hlsjs flvjs播放仍有问题
  if (IS_IOS) {
    return undefined;
  }
  return isTypeSupported && sourceBufferValidAPI;
}();

var browser = (Object.freeze || Object)({
	USER_AGENT: USER_AGENT,
	IS_IPAD: IS_IPAD,
	IS_IPHONE: IS_IPHONE,
	IS_IPOD: IS_IPOD,
	IS_IOS: IS_IOS,
	IOS_VERSION: IOS_VERSION,
	IOS_VERSION_ARRAY: IOS_VERSION_ARRAY,
	IS_ANDROID: IS_ANDROID,
	ANDROID_VERSION: ANDROID_VERSION,
	IS_TBS: IS_TBS,
	TBS_VERSION: TBS_VERSION,
	IS_MQQB: IS_MQQB,
	IS_QQB: IS_QQB,
	IS_PC_WECHAT: IS_PC_WECHAT,
	IS_WECHAT: IS_WECHAT,
	IS_MQQ: IS_MQQ,
	IS_OLD_ANDROID: IS_OLD_ANDROID,
	IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
	IS_FIREFOX: IS_FIREFOX,
	IS_EDGE: IS_EDGE,
	IS_EDG: IS_EDG,
	EDG_VERSION: EDG_VERSION,
	IS_CHROME: IS_CHROME,
	CHROME_VERSION: CHROME_VERSION,
	IS_IE8: IS_IE8,
	IE_VERSION: IE_VERSION,
	IS_SAFARI: IS_SAFARI,
	IS_ANY_SAFARI: IS_ANY_SAFARI,
	IS_SAFARI_NOT_SIMULATOR: IS_SAFARI_NOT_SIMULATOR,
	IS_UC: IS_UC,
	TOUCH_ENABLED: TOUCH_ENABLED,
	BACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED,
	IS_WIN: IS_WIN,
	IS_MAC: IS_MAC,
	WIN_VER: WIN_VER,
	MAC_VER: MAC_VER,
	QQ_VER: QQ_VER,
	EDGE_VER: EDGE_VER,
	SAFARI_VER: SAFARI_VER,
	FIREFOX_VER: FIREFOX_VER,
	CHROME_VER: CHROME_VER,
	IS_HUAWEI: IS_HUAWEI,
	IS_XIAOMI: IS_XIAOMI,
	IS_OPPO: IS_OPPO,
	IS_VIVO: IS_VIVO,
	IS_SX: IS_SX,
	IS_ONE: IS_ONE,
	IS_CP: IS_CP,
	IS_ZX: IS_ZX,
	isWebRTCAPISupported: isWebRTCAPISupported,
	isWebRTCSupported: isWebRTCSupported,
	IS_ENABLED_MSE: IS_ENABLED_MSE
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};











var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

/**
 * @file obj.js
 * @module obj
 */

/**
 * @callback obj:EachCallback
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 */

/**
 * @callback obj:ReduceCallback
 *
 * @param {Mixed} accum
 *        The value that is accumulating over the reduce loop.
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 *
 * @return {Mixed}
 *         The new accumulated value.
 */
var toString = Object.prototype.toString;

/**
 * Get the keys of an Object
 *
 * @param {Object}
 *        The Object to get the keys from
 *
 * @return {string[]}
 *         An array of the keys from the object. Returns an empty array if the
 *         object passed in was invalid or had no keys.
 *
 * @private
 */
var keys = function keys(object) {
  return isObject$1(object) ? Object.keys(object) : [];
};

/**
 * Array-like iteration for objects.
 *
 * @param {Object} object
 *        The object to iterate over
 *
 * @param {obj:EachCallback} fn
 *        The callback function which is called for each key in the object.
 */
function each(object, fn) {
  keys(object).forEach(function (key) {
    return fn(object[key], key);
  });
}

/**
 * Array-like reduce for objects.
 *
 * @param {Object} object
 *        The Object that you want to reduce.
 *
 * @param {Function} fn
 *         A callback function which is called for each key in the object. It
 *         receives the accumulated value and the per-iteration value and key
 *         as arguments.
 *
 * @param {Mixed} [initial = 0]
 *        Starting value
 *
 * @return {Mixed}
 *         The final accumulated value.
 */
function reduce(object, fn) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return keys(object).reduce(function (accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}

/**
 * Object.assign-style object shallow merge/extend.
 *
 * @param  {Object} target
 * @param  {Object} ...sources
 * @return {Object}
 */
function assign(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (Object.assign) {
    return Object.assign.apply(Object, [target].concat(sources));
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      target[key] = value;
    });
  });

  return target;
}

/**
 * Returns whether a value is an object of any kind - including DOM nodes,
 * arrays, regular expressions, etc. Not functions, though.
 *
 * This avoids the gotcha where using `typeof` on a `null` value
 * results in `'object'`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isObject$1(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

/**
 * Returns whether an object appears to be a "plain" object - that is, a
 * direct instance of `Object`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isPlain(value) {
  return isObject$1(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
}

/**
 * Returns whether an object typeof is function
 * @param obj
 * @returns {boolean}
 */
function isFunction(obj) {
  // Support: Chrome <=57, Firefox <=52
  // In some browsers, typeof returns "function" for HTML <object> elements
  // (i.e., `typeof document.createElement( "object" ) === "function"`).
  // We don't want to classify *any* DOM node as a function.
  return typeof obj === "function" && typeof obj.nodeType !== "number";
}

/**
 * @file log.js
 * @module log
 */
var log$1 = void 0;

// This is the private tracking variable for logging level.
var level = 'info';

// This is the private tracking variable for the logging history.
var history = [];

/**
 * Log messages to the console and history based on the type of message
 *
 * @private
 * @param  {string} type
 *         The name of the console method to use.
 *
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 *
 * @param  {boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;

  var lvl = log$1.levels[level];
  var lvlRegExp = new RegExp('^(' + lvl + ')$');

  if (type !== 'log') {

    // Add the type to the front of the message when it's not "log".
    args.unshift(type.toUpperCase() + ':');
  }

  // Add a clone of the args at this point to history.
  if (history) {
    history.push([].concat(args));
  }

  if (!log$1.enableLog && type == 'log') {
    return;
  }

  // Add console prefix after adding to history.
  args.unshift('TCPlayer:');

  // If there's no console then don't try to output messages, but they will
  // still be stored in history.
  if (!window_1.console) {
    return;
  }

  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = window_1.console[type];

  if (!fn && type === 'debug') {
    // Certain browsers don't have support for console.debug. For those, we
    // should default to the closest comparable log.
    fn = window_1.console.info || window_1.console.log;
  }

  // Bail out if there's no console or if this type is not allowed by the
  // current logging level.
  if (!fn || !lvl || !lvlRegExp.test(type)) {
    return;
  }

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (isObject$1(a) || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {
          return String(a);
        }
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](window_1.console, args);
  }
};

/**
 * Logs plain debug messages. Similar to `console.log`.
 *
 * @class
 * @param    {Mixed[]} args
 *           One or more messages or objects that should be logged.
 */
log$1 = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
};

/**
 * Enumeration of available logging levels, where the keys are the level names
 * and the values are `|`-separated strings containing logging methods allowed
 * in that logging level. These strings are used to create a regular expression
 * matching the function name being called.
 *
 * Levels provided by video.js are:
 *
 * - `off`: Matches no calls. Any value that can be cast to `false` will have
 *   this effect. The most restrictive.
 * - `all`: Matches only Video.js-provided functions (`debug`, `log`,
 *   `log.warn`, and `log.error`).
 * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.
 * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.
 * - `warn`: Matches `log.warn` and `log.error` calls.
 * - `error`: Matches only `log.error` calls.
 *
 * @type {Object}
 */
log$1.levels = {
  all: 'debug|log|warn|error',
  off: '',
  debug: 'debug|log|warn|error',
  info: 'log|warn|error',
  warn: 'warn|error',
  error: 'error',
  DEFAULT: level
};

/**
 * Get or set the current logging level. If a string matching a key from
 * {@link log.levels} is provided, acts as a setter. Regardless of argument,
 * returns the current logging level.
 *
 * @param  {string} [lvl]
 *         Pass to set a new logging level.
 *
 * @return {string}
 *         The current logging level.
 */
log$1.level = function (lvl) {
  if (typeof lvl === 'string') {
    if (!log$1.levels.hasOwnProperty(lvl)) {
      throw new Error('"' + lvl + '" in not a valid log level');
    }
    level = lvl;
  }
  return level;
};

/**
 * Returns an array containing everything that has been logged to the history.
 *
 * This array is a shallow clone of the internal history record. However, its
 * contents are _not_ cloned; so, mutating objects inside this array will
 * mutate them in history.
 *
 * @return {Array}
 */
log$1.history = function () {
  return history ? [].concat(history) : [];
};

/**
 * Clears the internal history tracking, but does not prevent further history
 * tracking.
 */
log$1.history.clear = function () {
  if (history) {
    history.length = 0;
  }
};

/**
 * Disable history tracking if it is currently enabled.
 */
log$1.history.disable = function () {
  if (history !== null) {
    history.length = 0;
    history = null;
  }
};

/**
 * Enable history tracking if it is currently disabled.
 */
log$1.history.enable = function () {
  if (history === null) {
    history = [];
  }
};

log$1.enableLog = false;
/**
 * Logs error messages. Similar to `console.error`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as an error
 */
log$1.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Logs warning messages. Similar to `console.warn`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as a warning.
 */
log$1.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

/**
 * Logs debug messages. Similar to `console.debug`, but may also act as a comparable
 * log if `console.debug` is not available
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as debug.
 */
log$1.debug = function () {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return logByType('debug', args);
};

var log$2 = log$1;

function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


var tsml = function tsml (sa) {
  var s = ''
    , i = 0;

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '');

  return s
};

/**
 * @file computed-style.js
 * @module computed-style
 */
function computedStyle(el, prop) {
  if (!el || !prop) {
    return '';
  }

  if (typeof window_1.getComputedStyle === 'function') {
    var cs = window_1.getComputedStyle(el);

    return cs ? cs[prop] : '';
  }

  return el.currentStyle[prop] || '';
}

var _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

/**
 * @file dom.js
 * @module dom
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param {string} str
 *         The string to check for whitespace.
 *
 * @throws {Error}
 *         Throws an error if there is whitespace in the string.
 *
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a className within an elements className.
 *
 * @param {string} className
 *         The className to generate the RegExp for.
 *
 * @return {RegExp}
 *         The RegExp that will check for a specific `className` in an elements
 *         className.
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Whether the current DOM interface appears to be real.
 *
 * @return {Boolean}
 */
function isReal() {
  return (

    // Both document and window will never be undefined thanks to `global`.
    document_1 === window_1.document &&

    // In IE < 9, DOM methods return "object" as their type, so all we can
    // confidently check is that it exists.
    typeof document_1.createElement !== 'undefined'
  );
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @param {Mixed} value
 *        The thing to check
 *
 * @return {boolean}
 *         - True if it is a DOM element
 *         - False otherwise
 */
function isEl(value) {
  return isObject$1(value) && value.nodeType === 1;
}

/**
 * Determines if the current DOM is embedded in an iframe.
 *
 * @return {boolean}
 *
 */
function isInFrame() {

  // We need a try/catch here because Safari will throw errors when attempting
  // to get either `parent` or `self`
  try {
    return window_1.parent !== window_1.self;
  } catch (x) {
    return true;
  }
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @param {string} method
 *         The method to create the query with.
 *
 * @return {Function}
 *         The query method
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return document_1[method](null);
    }
    if (isNonBlankString(context)) {
      context = document_1.querySelector(context);
    }

    var ctx = isEl(context) ? context : document_1;

    return ctx[method] && ctx[method](selector);
  };
}

/**
 * Creates an element and applies properties.
 *
 * @param {string} [tagName='div']
 *         Name of tag to be created.
 *
 * @param {Object} [properties={}]
 *         Element properties to be applied.
 *
 * @param {Object} [attributes={}]
 *         Element attributes to be applied.
 *
 * @param {String|Element|TextNode|Array|Function} [content]
 *         Contents for the element (see: {@link dom:normalizeContent})
 *
 * @return {Element}
 *         The element that was created.
 */
function createEl() {
  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = arguments[3];

  var el = document_1.createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      log$2.warn(tsml(_templateObject, propName, val));
      el.setAttribute(propName, val);

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
    } else if (propName === 'textContent') {
      textContent(el, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });

  if (content) {
    appendContent(el, content);
  }

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param {Element} el
 *        The element to add text content into
 *
 * @param {string} text
 *        The text content to add.
 *
 * @return {Element}
 *         The element with added text content.
 */
function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}

/**
 * Insert an element as the first child node of another
 *
 * @param {Element} child
 *        Element to insert
 *
 * @param {Element} parent
 *        Element to insert child into
 */
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Check if an element has a CSS class
 *
 * @param {Element} element
 *        Element to check
 *
 * @param {string} classToCheck
 *        Class name to check for
 *
 * @return {boolean}
 *         - True if the element had the class
 *         - False otherwise.
 *
 * @throws {Error}
 *         Throws an error if `classToCheck` has white space.
 */
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}

/**
 * Add a CSS class name to an element
 *
 * @param {Element} element
 *        Element to add class name to.
 *
 * @param {string} classToAdd
 *        Class name to add.
 *
 * @return {Element}
 *         The dom element with the added class name.
 */
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + ' ' + classToAdd).trim();
  }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @param {Element} element
 *        Element to remove a class name from.
 *
 * @param {string} classToRemove
 *        Class name to remove
 *
 * @return {Element}
 *         The dom element with class name removed.
 */
function removeClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * The callback definition for toggleElClass.
 *
 * @callback Dom~PredicateCallback
 * @param {Element} element
 *        The DOM element of the Component.
 *
 * @param {string} classToToggle
 *        The `className` that wants to be toggled
 *
 * @return {boolean|undefined}
 *         - If true the `classToToggle` will get added to `element`.
 *         - If false the `classToToggle` will get removed from `element`.
 *         - If undefined this callback will be ignored
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @param {Element} element
 *        The element to toggle a class name on.
 *
 * @param {string} classToToggle
 *        The class that should be toggled
 *
 * @param {boolean|PredicateCallback} [predicate]
 *        See the return value for {@link Dom~PredicateCallback}
 *
 * @return {Element}
 *         The element with a class that has been toggled.
 */
function toggleClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param {Element} el
 *        Element to add attributes to.
 *
 * @param {Object} [attributes]
 *        Attributes to be applied.
 */
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param {Element} tag
 *        Element from which to get tag attributes.
 *
 * @return {Object}
 *         All attributes of the element.
 */
function getAttributes(tag) {
  var obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Get the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to get the value of
 *
 * @return {string}
 *         value of the attribute
 */
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}

/**
 * Set the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to set
 *
 * @param {string} value
 *        Value to set the attribute to
 */
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}

/**
 * Remove an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to remove
 */
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}

/**
 * Attempt to block the ability to select text while dragging controls
 */
function blockTextSelection() {
  document_1.body.focus();
  document_1.onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 */
function unblockTextSelection() {
  document_1.onselectstart = function () {
    return true;
  };
}

/**
 * Identical to the native `getBoundingClientRect` function, but ensures that
 * the method is supported at all (it is in all browsers we claim to support)
 * and that the element is in the DOM before continuing.
 *
 * This wrapper function also shims properties which are not provided by some
 * older browsers (namely, IE8).
 *
 * Additionally, some browsers do not support adding properties to a
 * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
 * properties (except `x` and `y` which are not widely supported). This helps
 * avoid implementations where keys are non-enumerable.
 *
 * @param  {Element} el
 *         Element whose `ClientRect` we want to calculate.
 *
 * @return {Object|undefined}
 *         Always returns a plain
 */
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};

    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
      if (rect[k] !== undefined) {
        result[k] = rect[k];
      }
    });

    if (!result.height) {
      result.height = parseFloat(computedStyle(el, 'height'));
    }

    if (!result.width) {
      result.width = parseFloat(computedStyle(el, 'width'));
    }

    return result;
  }
}

/**
 * The postion of a DOM element on the page.
 *
 * @typedef {Object} module:dom~Position
 *
 * @property {number} left
 *           Pixels to the left
 *
 * @property {number} top
 *           Pixels on top
 */

/**
 * Offset Left.
 * getBoundingClientRect technique from
 * John Resig
 *
 * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @param {Element} el
 *        Element from which to get offset
 *
 * @return {module:dom~Position}
 *         The position of the element that was passed in.
 */
function findPosition(el) {
  var box = void 0;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = document_1.documentElement;
  var body = document_1.body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = window_1.pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = window_1.pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * x and y coordinates for a dom element or mouse pointer
 *
 * @typedef {Object} Dom~Coordinates
 *
 * @property {number} x
 *           x coordinate in pixels
 *
 * @property {number} y
 *           y coordinate in pixels
 */

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @param {Element} el
 *        Element on which to get the pointer position on
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {Dom~Coordinates}
 *         A Coordinates object corresponding to the mouse position.
 *
 */
function getPointerPosition(el, event) {
  var position = {};
  var box = findPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param {Mixed} value
 *        Check if this value is a text node.
 *
 * @return {boolean}
 *         - True if it is a text node
 *         - False otherwise
 */
function isTextNode(value) {
  return isObject$1(value) && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @param {Element} el
 *        The element to empty children from
 *
 * @return {Element}
 *         The element with no children
 */
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        - String: Normalized into a text node.
 *        - Element/TextNode: Passed through.
 *        - Array: A one-dimensional array of strings, elements, nodes, or functions
 *          (which return single strings, elements, or nodes).
 *        - Function: If the sole argument, is expected to produce a string, element,
 *          node, or array as defined above.
 *
 * @return {Array}
 *         All of the content that was passed in normalized.
 */
function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return document_1.createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @param {Element} el
 *        Element to append normalized content to.
 *
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with appended normalized content.
 */
function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @param {Element} el
 *        Element to insert normalized content into.
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with inserted normalized content.
 *
 */
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Check if event was a single left click
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {boolean}
 *         - True if a left click
 *         - False if not a left click
 */
function isSingleLeftClick(event) {
  // Note: if you create something draggable, be sure to
  // call it on both `mousedown` and `mousemove` event,
  // otherwise `mousedown` should be enough for a button

  if (event.button === undefined && event.buttons === undefined) {
    // Why do we need `butttons` ?
    // Because, middle mouse sometimes have this:
    // e.button === 0 and e.buttons === 4
    // Furthermore, we want to prevent combination click, something like
    // HOLD middlemouse then left click, that would be
    // e.button === 0, e.buttons === 5
    // just `button` is not gonna work

    // Alright, then what this block does ?
    // this is for chrome `simulate mobile devices`
    // I want to support this as well

    return true;
  }

  if (event.button === 0 && event.buttons === undefined) {
    // Touch screen, sometimes on some specific device, `buttons`
    // doesn't have anything (safari on ios, blackberry...)

    return true;
  }

  if (IE_VERSION === 9) {
    // Ignore IE9

    return true;
  }

  if (event.button !== 0 || event.buttons !== 1) {
    // This is the reason we have those if else block above
    // if any special case we can catch and let it slide
    // we do it above, when get to here, this definitely
    // is-not-left-click

    return false;
  }

  return true;
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *        A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param {Element|String} [context=document]
 *        A DOM element within which to query. Can also be a selector
 *        string in which case the first matching element will be used
 *        as context. If missing (or no element matches selector), falls
 *        back to `document`.
 *
 * @return {Element|null}
 *         The element that was found or null.
 */
var $ = createQuerier('querySelector');

/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return {NodeList}
 *         A element list of elements that were found. Will be empty if none were found.
 *
 */
var $$ = createQuerier('querySelectorAll');



var Dom = (Object.freeze || Object)({
	isReal: isReal,
	isEl: isEl,
	isInFrame: isInFrame,
	createEl: createEl,
	textContent: textContent,
	prependTo: prependTo,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	toggleClass: toggleClass,
	setAttributes: setAttributes,
	getAttributes: getAttributes,
	getAttribute: getAttribute,
	setAttribute: setAttribute,
	removeAttribute: removeAttribute,
	blockTextSelection: blockTextSelection,
	unblockTextSelection: unblockTextSelection,
	getBoundingClientRect: getBoundingClientRect,
	findPosition: findPosition,
	getPointerPosition: getPointerPosition,
	isTextNode: isTextNode,
	emptyEl: emptyEl,
	normalizeContent: normalizeContent,
	appendContent: appendContent,
	insertContent: insertContent,
	isSingleLeftClick: isSingleLeftClick,
	$: $,
	$$: $$
});

/**
 * @file guid.js
 * @module guid
 */

/**
 * Unique ID for an element or function
 * @type {Number}
 */
var _guid = 1;

/**
 * Get a unique auto-incrementing ID by number that has not been returned before.
 *
 * @return {number}
 *         A new unique ID.
 */
function newGUID() {
  return _guid++;
}

/**
 * @file dom-data.js
 * @module dom-data
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param {Element} el
 *        Element to store data for.
 *
 * @return {Object}
 *         The cache object for that el that was passed in.
 */
function getData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param {Element} el
 *        Check if this element has cached data.
 *
 * @return {boolean}
 *         - True if the DOM element has cached data.
 *         - False otherwise.
 */
function hasData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param {Element} el
 *        Remove cached data for this element.
 */
function removeData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 *
 * @module events
 */

function _cleanUpEvents(elem, type) {
  var data = getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param {Function} fn
 *        The event method we want to use.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} callback
 *        Event listener.
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    // Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

/**
 * Fix a native event to have standard property values
 *
 * @param {Object} event
 *        Event object to fix.
 *
 * @return {Object}
 *         Fixed event object.
 */
function fixEvent(event) {

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window_1.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document_1;
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      // if (event.cancelable && !event.defaultPrevented && old.preventDefault) {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX !== null && event.clientX !== undefined) {
      var doc = document_1.documentElement;
      var body = document_1.body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button !== null && event.button !== undefined) {

      // The following is disabled because it does not pass videojs-standard
      // and... yikes.
      /* eslint-disable */
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      /* eslint-enable */
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Whether passive event listeners are supported
 */
var _supportsPassive = false;

(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        _supportsPassive = true;
      }
    });

    window_1.addEventListener('test', null, opts);
    window_1.removeEventListener('test', null, opts);
  } catch (e) {
    // disregard
  }
})();

/**
 * Touch events Chrome expects to be passive
 */
var passiveEvents = ['touchstart', 'touchmove'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string|string[]} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} fn
 *        Event listener.
 */
function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) {
    data.handlers = {};
  }

  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }

  if (!fn.guid) {
    fn.guid = newGUID();
  }

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) {
        return;
      }

      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              log$2.error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      var options = false;

      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
        options = { passive: true };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param {Element|Object} elem
 *        Object to remove listeners from.
 *
 * @param {string|string[]} [type]
 *        Type of listener to remove. Don't include to remove all events from element.
 *
 * @param {EventTarget~EventListener} [fn]
 *        Specific listener to remove. Don't include to remove listeners for an event
 *        type.
 */
function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!hasData(elem)) {
    return;
  }

  var data = getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(el, t) {
    data.handlers[t] = [];
    _cleanUpEvents(el, t);
  };

  // Are we removing all bound events?
  if (type === undefined) {
    for (var t in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
        removeType(elem, t);
      }
    }
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  }

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(elem, type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param {Element|Object} elem
 *        Element to trigger an event on
 *
 * @param {EventTarget~Event|string} event
 *        A string (the type) or an event object with a type attribute
 *
 * @param {Object} [hash]
 *        data hash to pass along with the event
 *
 * @return {boolean|undefined}
 *         - Returns the opposite of `defaultPrevented` if default was prevented
 *         - Otherwise returns undefined
 */
function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = hasData(elem) ? getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param {Element|Object} elem
 *        Element or object to bind to.
 *
 * @param {string|string[]} type
 *        Name/type of event
 *
 * @param {Event~EventListener} fn
 *        Event Listener function
 */
function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };

  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type, func);
}

var Events = (Object.freeze || Object)({
	fixEvent: fixEvent,
	on: on,
	off: off,
	trigger: trigger,
	one: one
});

/**
 * @file setup.js - Functions for setting up a player without
 * user interaction based on the data-setup `attribute` of the video tag.
 *
 * @module setup
 */
var _windowLoaded = false;
var videojs$2 = void 0;

/**
 * Set up any tags that have a data-setup `attribute` when the player is started.
 */
var autoSetup = function autoSetup() {

  // Protect against breakage in non-browser environments.
  if (!isReal()) {
    return;
  }

  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop
  // through each list of elements to build up a new, combined list of elements.
  var vids = document_1.getElementsByTagName('video');
  var audios = document_1.getElementsByTagName('audio');
  var divs = document_1.getElementsByTagName('video-js');
  var mediaEls = [];

  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }

  if (audios && audios.length > 0) {
    for (var _i = 0, _e = audios.length; _i < _e; _i++) {
      mediaEls.push(audios[_i]);
    }
  }

  if (divs && divs.length > 0) {
    for (var _i2 = 0, _e2 = divs.length; _i2 < _e2; _i2++) {
      mediaEls.push(divs[_i2]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var _i3 = 0, _e3 = mediaEls.length; _i3 < _e3; _i3++) {
      var mediaEl = mediaEls[_i3];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of
      // 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            videojs$2(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

/**
 * Wait until the page is loaded before running autoSetup. This will be called in
 * autoSetup if `hasLoaded` returns false.
 *
 * @param {number} wait
 *        How long to wait in ms
 *
 * @param {module:videojs} [vjs]
 *        The videojs library function
 */
function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs$2 = vjs;
  }

  window_1.setTimeout(autoSetup, wait);
}

if (isReal() && document_1.readyState === 'complete') {
  _windowLoaded = true;
} else {
  /**
   * Listen for the load event on window, and set _windowLoaded to true.
   *
   * @listens load
   */
  one(window_1, 'load', function () {
    _windowLoaded = true;
  });
}

/**
 * check if the document has been loaded
 */

/**
 * @file stylesheet.js
 * @module stylesheet
 */
var createStyleElement = function createStyleElement(className) {
  var style = document_1.createElement('style');

  style.className = className;

  return style;
};

/**
 * Add text to a DOM element.
 *
 * @param {Element} el
 *        The Element to add text content to.
 *
 * @param {string} content
 *        The text to add to the element.
 */
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};

/**
 * @file fn.js
 * @module fn
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = newGUID();
  }

  // Create the new function that changes the context
  var bound = function bound() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return bound;
};

/**
 * Wraps the given function, `fn`, with a new function that only invokes `fn`
 * at most once per every `wait` milliseconds.
 *
 * @param  {Function} fn
 *         The function to be throttled.
 *
 * @param  {Number}   wait
 *         The number of milliseconds by which to throttle.
 *
 * @return {Function}
 */
var throttle = function throttle(fn, wait) {
  var last = Date.now();

  var throttled = function throttled() {
    var now = Date.now();

    if (now - last >= wait) {
      fn.apply(undefined, arguments);
      last = now;
    }
  };

  return throttled;
};

/**
 * @file src/js/event-target.js
 */
var EventTarget = function EventTarget() {};

/**
 * A Custom DOM event.
 *
 * @typedef {Object} EventTarget~Event
 * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
 */

/**
 * All event listeners should follow the following format.
 *
 * @callback EventTarget~EventListener
 * @this {EventTarget}
 *
 * @param {EventTarget~Event} event
 *        the event that triggered this function
 *
 * @param {Object} [hash]
 *        hash of data sent during the event
 */

/**
 * An object containing event names as keys and booleans as values.
 *
 * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
 *         will have extra functionality. See that function for more information.
 *
 * @property EventTarget.prototype.allowedEvents_
 * @private
 */
EventTarget.prototype.allowedEvents_ = {};

/**
 * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
 * function that will get called when an event with a certain name gets triggered.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to call with `EventTarget`s
 */
EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  on(this, type, fn);
  this.addEventListener = ael;
};

/**
 * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#on}
 */
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

/**
 * Removes an `event listener` for a specific event from an instance of `EventTarget`.
 * This makes it so that the `event listener` will no longer get called when the
 * named event happens.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to remove.
 */
EventTarget.prototype.off = function (type, fn) {
  off(this, type, fn);
};

/**
 * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#off}
 */
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

/**
 * This function will add an `event listener` that gets triggered only once. After the
 * first trigger it will get removed. This is like adding an `event listener`
 * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to be called once for each event name.
 */
EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alialing Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  one(this, type, fn);
  this.addEventListener = ael;
};

/**
 * This function causes an event to happen. This will then cause any `event listeners`
 * that are waiting for that event, to get called. If there are no `event listeners`
 * for an event then nothing will happen.
 *
 * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
 * Trigger will also call the `on` + `uppercaseEventName` function.
 *
 * Example:
 * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
 * `onClick` if it exists.
 *
 * @param {string|EventTarget~Event|Object} event
 *        The name of the event, an `Event`, or an object with a key of type set to
 *        an event name.
 */
EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = { type: type };
  }
  event = fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  trigger(this, event);
};

/**
 * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#trigger}
 */
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

/**
 * @file mixins/evented.js
 * @module evented
 */
var isEvented = function isEvented(object) {
  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
    return typeof object[k] === 'function';
  });
};

/**
 * Whether a value is a valid event type - non-empty string or array.
 *
 * @private
 * @param  {string|Array} type
 *         The type value to test.
 *
 * @return {boolean}
 *         Whether or not the type is a valid event type.
 */
var isValidEventType = function isValidEventType(type) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the target does not appear to be a valid event target.
 *
 * @param  {Object} target
 *         The object to test.
 */
var validateTarget = function validateTarget(target) {
  if (!target.nodeName && !isEvented(target)) {
    throw new Error('Invalid target; must be a DOM node or evented object.');
  }
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the type does not appear to be a valid event type.
 *
 * @param  {string|Array} type
 *         The type to test.
 */
var validateEventType = function validateEventType(type) {
  if (!isValidEventType(type)) {
    throw new Error('Invalid event type; must be a non-empty string or array.');
  }
};

/**
 * Validates a value to determine if it is a valid listener. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the listener is not a function.
 *
 * @param  {Function} listener
 *         The listener to test.
 */
var validateListener = function validateListener(listener) {
  if (typeof listener !== 'function') {
    throw new Error('Invalid listener; must be a function.');
  }
};

/**
 * Takes an array of arguments given to `on()` or `one()`, validates them, and
 * normalizes them into an object.
 *
 * @private
 * @param  {Object} self
 *         The evented object on which `on()` or `one()` was called. This
 *         object will be bound as the `this` value for the listener.
 *
 * @param  {Array} args
 *         An array of arguments passed to `on()` or `one()`.
 *
 * @return {Object}
 *         An object containing useful values for `on()` or `one()` calls.
 */
var normalizeListenArgs = function normalizeListenArgs(self, args) {

  // If the number of arguments is less than 3, the target is always the
  // evented object itself.
  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
  var target = void 0;
  var type = void 0;
  var listener = void 0;

  if (isTargetingSelf) {
    target = self.eventBusEl_;

    // Deal with cases where we got 3 arguments, but we are still listening to
    // the evented object itself.
    if (args.length >= 3) {
      args.shift();
    }

    type = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }

  validateTarget(target);
  validateEventType(type);
  validateListener(listener);

  listener = bind(self, listener);

  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };
};

/**
 * Adds the listener to the event type(s) on the target, normalizing for
 * the type of target.
 *
 * @private
 * @param  {Element|Object} target
 *         A DOM node or evented object.
 *
 * @param  {string} method
 *         The event binding method to use ("on" or "one").
 *
 * @param  {string|Array} type
 *         One or more event type(s).
 *
 * @param  {Function} listener
 *         A listener function.
 */
var listen = function listen(target, method, type, listener) {
  validateTarget(target);

  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};

/**
 * Contains methods that provide event capabilites to an object which is passed
 * to {@link module:evented|evented}.
 *
 * @mixin EventedMixin
 */
var EventedMixin = {

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on$$1() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _normalizeListenArgs = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
        target = _normalizeListenArgs.target,
        type = _normalizeListenArgs.type,
        listener = _normalizeListenArgs.listener;

    listen(target, 'on', type, listener);

    // If this object is listening to another evented object.
    if (!isTargetingSelf) {

      // If this object is disposed, remove the listener.
      var removeListenerOnDispose = function removeListenerOnDispose() {
        return _this.off(target, type, listener);
      };

      // Use the same function ID as the listener so we can remove it later it
      // using the ID of the original listener.
      removeListenerOnDispose.guid = listener.guid;

      // Add a listener to the target's dispose event as well. This ensures
      // that if the target is disposed BEFORE this object, we remove the
      // removal listener that was just added. Otherwise, we create a memory leak.
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
        return _this.off('dispose', removeListenerOnDispose);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      removeRemoverOnTargetDispose.guid = listener.guid;

      listen(this, 'on', 'dispose', removeListenerOnDispose);
      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
    }
  },


  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one$$1() {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _normalizeListenArgs2 = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
        target = _normalizeListenArgs2.target,
        type = _normalizeListenArgs2.type,
        listener = _normalizeListenArgs2.listener;

    // Targeting this evented object.


    if (isTargetingSelf) {
      listen(target, 'one', type, listener);

      // Targeting another evented object.
    } else {
      var wrapper = function wrapper() {
        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }

        _this2.off(target, type, wrapper);
        listener.apply(null, largs);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      wrapper.guid = listener.guid;
      listen(target, 'one', type, wrapper);
    }
  },


  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$$1(targetOrType, typeOrListener, listener) {

    // Targeting this evented object.
    if (!targetOrType || isValidEventType(targetOrType)) {
      if (isValidEventType(typeOrListener)) {
        off(this.eventBusEl_, typeOrListener, listener);
      } else {
        off(this.eventBusEl_, targetOrType, typeOrListener);
      }
      // Targeting another evented object.
    } else {
      var target = targetOrType;
      var type = typeOrListener;

      // Fail fast and in a meaningful way!
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);

      // Ensure there's at least a guid, even if the function hasn't been used
      listener = bind(this, listener);

      // Remove the dispose listener on this evented object, which was given
      // the same guid as the event listener in on().
      this.off('dispose', listener);

      if (target.nodeName) {
        off(target, type, listener);
        off(target, 'dispose', listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off('dispose', listener);
      }
    }
  },


  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @returns {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$$1(event, hash) {
    return trigger(this.eventBusEl_, event, hash);
  }
};

/**
 * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
 *
 * @param  {Object} target
 *         The object to which to add event methods.
 *
 * @param  {Object} [options={}]
 *         Options for customizing the mixin behavior.
 *
 * @param  {String} [options.eventBusKey]
 *         By default, adds a `eventBusEl_` DOM element to the target object,
 *         which is used as an event bus. If the target object already has a
 *         DOM element that should be used, pass its key here.
 *
 * @return {Object}
 *         The target object.
 */
function evented(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventBusKey = options.eventBusKey;

  // Set or create the eventBusEl_.

  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });
  }

  assign(target, EventedMixin);

  // When any evented object is disposed, it removes all its listeners.
  target.on('dispose', function () {
    target.off();
    window_1.setTimeout(function () {
      target.eventBusEl_ = null;
    }, 0);
  });

  return target;
}

/**
 * @file mixins/stateful.js
 * @module stateful
 */
var StatefulMixin = {

  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},

  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @returns {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;

    // Support providing the `stateUpdates` state as a function.
    if (typeof stateUpdates === 'function') {
      stateUpdates = stateUpdates();
    }

    var changes = void 0;

    each(stateUpdates, function (value, key) {

      // Record the change if the value is different from what's in the
      // current state.
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }

      _this.state[key] = value;
    });

    // Only trigger "statechange" if there were changes AND we have a trigger
    // function. This allows us to not require that the target object be an
    // evented object.
    if (changes && isEvented(this)) {

      /**
       * An event triggered on an object that is both
       * {@link module:stateful|stateful} and {@link module:evented|evented}
       * indicating that its state has changed.
       *
       * @event    module:stateful~StatefulMixin#statechanged
       * @type     {Object}
       * @property {Object} changes
       *           A hash containing the properties that were changed and
       *           the values they were changed `from` and `to`.
       */
      this.trigger({
        changes: changes,
        type: 'statechanged'
      });
    }

    return changes;
  }
};

/**
 * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
 * object.
 *
 * If the target object is {@link module:evented|evented} and has a
 * `handleStateChanged` method, that method will be automatically bound to the
 * `statechanged` event on itself.
 *
 * @param   {Object} target
 *          The object to be made stateful.
 *
 * @param   {Object} [defaultState]
 *          A default set of properties to populate the newly-stateful object's
 *          `state` property.
 *
 * @returns {Object}
 *          Returns the `target`.
 */
function stateful(target, defaultState) {
  assign(target, StatefulMixin);

  // This happens after the mixing-in because we need to replace the `state`
  // added in that step.
  target.state = assign({}, target.state, defaultState);

  // Auto-bind the `handleStateChanged` method of the target object if it exists.
  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
    target.on('statechanged', target.handleStateChanged);
  }

  return target;
}

/**
 * @file to-title-case.js
 * @module to-title-case
 */

/**
 * Uppercase the first letter of a string.
 *
 * @param {string} string
 *        String to be uppercased
 *
 * @return {string}
 *         The string with an uppercased first letter
 */
function toTitleCase(string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

function titleCaseEquals(str1, str2) {
  return toTitleCase(str1) === toTitleCase(str2);
}

/**
 * @file merge-options.js
 * @module merge-options
 */
function mergeOptions() {
  var result = {};

  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }

      if (!isPlain(result[key])) {
        result[key] = {};
      }

      result[key] = mergeOptions(result[key], value);
    });
  });

  return result;
}

/**
 * @file extend.js
 * @module extend
 */
function extend() {
  var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;

    // Skip the boolean and the target
    target = arguments[i] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !isFunction(target)) {
    target = {};
  }

  // Extend jQuery itself if only one argument is passed
  if (i === length) {
    target = this;
    i--;
  }

  for (; i < length; i++) {

    // Only deal with non-null/undefined values
    if ((options = arguments[i]) != null) {

      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];

        // Prevent never-ending loop
        if (target === copy) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if (deep && copy && (isPlain(copy) || (copyIsArray = Array.isArray(copy)))) {

          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];
          } else {
            clone = src && isPlain(src) ? src : {};
          }

          // Never move original objects, clone them
          target[name] = extend(deep, clone, copy);

          // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
}

/**
 * Player Component - Base class for all UI objects
 *
 * @file component.js
 */
var Component = function () {

  /**
   * A callback that is called when a component is ready. Does not have any
   * paramters and any callback value will be ignored.
   *
   * @callback Component~ReadyCallback
   * @this Component
   */

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to intialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  function Component(player, options, ready) {
    classCallCheck(this, Component);


    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding defaults
    // this.options_ = mergeOptions({}, this.options_);
    this.options_ = extend(true, {}, this.options_);

    // Updated options with supplied options
    options = this.options_ = mergeOptions(this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    // if evented is anything except false, we want to mixin in evented
    if (options.evented !== false) {
      // Make this an evented object and use `el_`, if available, as its event bus
      evented(this, { eventBusKey: this.el_ ? 'el_' : null });
    }
    stateful(this, this.constructor.defaultState);

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   */


  Component.prototype.dispose = function dispose() {

    /**
     * Triggered when a `Component` is disposed.
     *
     * @event Component#dispose
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up
     */
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    if (this.el_) {
      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      removeData(this.el_);
      this.el_ = null;
    }

    // remove reference to the player after disposing of the element
    this.player_ = null;
  };

  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */


  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:mergeOptions}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   *
   * @deprecated since version 5
   */


  Component.prototype.options = function options(obj) {
    log$2.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = mergeOptions(this.options_, obj);
    return this.options_;
  };

  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */


  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };

  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */


  Component.prototype.localize = function localize(string, tokens) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;

    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split('-')[0];
    var primaryLang = languages && languages[primaryCode];

    var localizedString = defaultValue;

    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }

    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
        var value = tokens[index - 1];
        var ret = value;

        if (typeof value === 'undefined') {
          ret = match;
        }

        return ret;
      });
    }

    return localizedString;
  };

  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */


  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */


  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */


  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */


  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */


  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */


  Component.prototype.getChild = function getChild(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    return this.childNameIndex_[name];
  };

  /**
   * Add a child `Component` inside the current `Component`.
   *
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */


  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;

    var component = void 0;
    var componentName = void 0;

    // If child is a string, create component with options
    if (typeof child === 'string') {
      componentName = toTitleCase(child);

      var componentClassName = options.componentClass || componentName;

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
      component = child;
    }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && toTitleCase(component.name());

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;

      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */


  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child `Component`s based upon options.
   */


  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      // `this` is `parent`
      var parentOptions = this.options_;

      var handleAdd = function handleAdd(child) {
        var name = child.name;
        var opts = child.opts;

        // Allow options for children to be set at the parent options
        // e.g. videojs(id, { controlBar: false });
        // instead of videojs(id, { children: { controlBar: false });
        if (parentOptions[name] !== undefined) {
          opts = parentOptions[name];
        }

        // Allow for disabling default components
        // e.g. options['children']['posterImage'] = false
        if (opts === false) {
          return;
        }

        // Allow options to be passed as a simple boolean if no configuration
        // is necessary.
        if (opts === true) {
          opts = {};
        }

        // We also want to pass the original player options
        // to each component as well so they don't need to
        // reach back into the player for options later.
        opts.playerOptions = _this.options_.playerOptions;

        // Create and add the child component.
        // Add a direct reference to the child by name on the parent instance.
        // If two of the same component are used, different names should be supplied
        // for each
        var newChild = _this.addChild(name, opts);

        if (newChild) {
          _this[name] = newChild;
        }
      };

      // Allow for an array of children details to passed in the options
      var workingChildren = void 0;
      var Tech = Component.getComponent('Tech');

      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }

      workingChildren
      // children that are in this.options_ but also in workingChildren  would
      // give us extra children we do not want. So, we want to filter them out.
      .concat(Object.keys(this.options_).filter(function (child) {
        return !workingChildren.some(function (wchild) {
          if (typeof wchild === 'string') {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function (child) {
        var name = void 0;
        var opts = void 0;

        if (typeof child === 'string') {
          name = child;
          opts = children[name] || _this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }

        return { name: name, opts: opts };
      }).filter(function (child) {
        // we have to make sure that child.name isn't in the techOrder since
        // techs are registerd as Components but can't aren't compatible
        // See https://github.com/videojs/video.js/issues/2772
        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));

        return c && !Tech.isTech(c);
      }).forEach(handleAdd);
    }
  };

  /**
   * Builds the default DOM class name. Should be overriden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */


  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @return {Component}
   *         Returns itself; method can be chained.
   */


  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!fn) {
      return;
    }

    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn);
      return;
    }

    if (sync) {
      fn.call(this);
    } else {
      // Call the function asynchronously by default for consistency
      this.setTimeout(fn, 1);
    }
  };

  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */


  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggerd asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      /**
       * Triggered when a `Component` is ready.
       *
       * @event Component#ready
       * @type {EventTarget~Event}
       */
      this.trigger('ready');
    }, 1);
  };

  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$ = function $$$1(selector, context) {
    return $(selector, context || this.contentEl());
  };

  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$$ = function $$$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */


  Component.prototype.hasClass = function hasClass$$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {string} classToAdd
   *        CSS class name to add
   */


  Component.prototype.addClass = function addClass$$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };

  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {string} classToRemove
   *        CSS class name to remove
   */


  Component.prototype.removeClass = function removeClass$$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };

  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */


  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };

  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */


  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
  };

  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */


  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
  };

  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
  };

  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
  };

  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attibute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */


  Component.prototype.getAttribute = function getAttribute$$1(attribute) {
    return getAttribute(this.el_, attribute);
  };

  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */


  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };

  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */


  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {
    removeAttribute(this.el_, attribute);
  };

  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *           postpixed with '%' or 'px'.
   */


  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *         postpixed with '%' or 'px'.
   */


  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */


  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip componentresize listeners on width for optimization
    this.width(width, true);
    this.height(height);
  };

  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number}
   *         The dimension when getting or 0 if unset
   */


  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        /**
         * Triggered when a component is resized.
         *
         * @event Component#componentresize
         * @type {EventTarget~Event}
         */
        this.trigger('componentresize');
      }

      return;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
  };

  /**
   * Get the width or the height of the `Component` elements computed style. Uses
   * `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */


  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof window_1.getComputedStyle === 'function') {
      var computedStyle = window_1.getComputedStyle(this.el_);

      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);

    // if the computed value is still 0, it's possible that the browser is lying
    // and we want to check the offset values.
    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.
    if (computedWidthOrHeight === 0) {
      var rule = 'offset' + toTitleCase(widthOrHeight);

      computedWidthOrHeight = this.el_[rule];
    }

    return computedWidthOrHeight;
  };

  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */

  /**
   * Get an object that contains width and height values of the `Component`s
   * computed style.
   *
   * @return {Component~DimensionObject}
   *         The dimensions of the components element
   */


  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} width
   *           The width of the `Component`s computed style.
   */


  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} height
   *           The height of the `Component`s computed style.
   */


  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Set the focus to this component
   */


  Component.prototype.focus = function focus() {
    this.el_.focus();
  };

  /**
   * Remove the focus from this component
   */


  Component.prototype.blur = function blur() {
    this.el_.blur();
  };

  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @private
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */


  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15,
    // so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = void 0;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          /**
           * Triggered when a `Component` is tapped.
           *
           * @event Component#tap
           * @type {EventTarget~Event}
           */
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */


  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = bind(this.player(), this.player().reportUserActivity);

    var touchHolding = void 0;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */

  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose}.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */


  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    var _this2 = this;

    fn = bind(this, fn);

    var timeoutId = window_1.setTimeout(fn, timeout);
    var disposeFn = function disposeFn() {
      return _this2.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */


  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    window_1.clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */


  Component.prototype.setInterval = function setInterval(fn, interval) {
    var _this3 = this;

    fn = bind(this, fn);

    var intervalId = window_1.setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      return _this3.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */


  Component.prototype.clearInterval = function clearInterval(intervalId) {
    window_1.clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */


  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this4 = this;

    if (this.supportsRaf_) {
      fn = bind(this, fn);

      var id = window_1.requestAnimationFrame(fn);
      var disposeFn = function disposeFn() {
        return _this4.cancelAnimationFrame(id);
      };

      disposeFn.guid = 'vjs-raf-' + id;
      this.on('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.setTimeout(fn, 1000 / 60);
  };

  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */


  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (this.supportsRaf_) {
      window_1.cancelAnimationFrame(id);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-raf-' + id;

      this.off('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.clearTimeout(id);
  };

  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */


  Component.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== 'string' || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }

    var Tech = Component.getComponent('Tech');

    // We need to make sure this check is only done if Tech has been registered.
    var isTech = Tech && Tech.isTech(ComponentToRegister);
    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);

    if (isTech || !isComp) {
      var reason = void 0;

      if (isTech) {
        reason = 'techs must be registered using Tech.registerTech()';
      } else {
        reason = 'must be a Component subclass';
      }

      throw new Error('Illegal component, "' + name + '"; ' + reason + '.');
    }

    name = toTitleCase(name);

    if (!Component.components_) {
      Component.components_ = {};
    }

    var Player = Component.getComponent('Player');

    if (name === 'Player' && Player && Player.players) {
      var players = Player.players;
      var playerNames = Object.keys(players);

      // If we have players that were disposed, then their name will still be
      // in Players.players. So, we must loop through and verify that the value
      // for each item is not null. This allows registration of the Player component
      // after all players have been disposed or before any were created.
      if (players && playerNames.length > 0 && playerNames.map(function (pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error('Can not register Player component after player has been created.');
      }
    }

    Component.components_[name] = ComponentToRegister;

    return ComponentToRegister;
  };

  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {Component}
   *         The `Component` that got registered under the given name.
   *
   * @deprecated In `videojs` 6 this will not return `Component`s that were not
   *             registered using {@link Component.registerComponent}. Currently we
   *             check the global `videojs` object for a `Component` name and
   *             return that if it exists.
   */


  Component.getComponent = function getComponent(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }
  };

  return Component;
}();

/**
 * Whether or not this component supports `requestAnimationFrame`.
 *
 * This is exposed primarily for testing purposes.
 *
 * @private
 * @type {Boolean}
 */


Component.prototype.supportsRaf_ = typeof window_1.requestAnimationFrame === 'function' && typeof window_1.cancelAnimationFrame === 'function';

Component.registerComponent('Component', Component);

var EXT_MIME = {
  'm3u8': 'application/x-mpegURL',
  'flv': 'video/flv',
  'mp4': 'video/mp4',
  'webm': 'video/webm',
  'rtmp': 'rtmp/flv',
  'mpd': 'application/dash+xml',
  'mp3': 'audio/mpeg'
};







var SERVER_PATH = '//playvideo.qcloud.com';
var SERVER_PATH_V3 = '//playvideo.qcloud.com';
var SERVER_PATH_V4 = '//playvideo.qcloud.com';
// export const SERVER_PATH_V4 = '//adapter.vod.myqcloud.com'; // 测试域名
var SERVER_PATH_BACKUP = '//bkplayvideo.qcloud.com';
var LICENSE_PATH = 'https://drm.vod2.myqcloud.com/getlicense/v1';
var HLS_PATH = 'https://web.sdk.qcloud.com/player/tcplayer/release/v4.6.0/libs/hls.min.1.1.5.js';
var FLV_PATH = 'https://web.sdk.qcloud.com/player/tcplayer/release/v4.6.0/libs/flv.min.1.6.3.js';
var WEBRTC_PATH = 'https://web.sdk.qcloud.com/player/tcplayer/release/v4.6.0/libs/TXLivePlayer-1.2.3.min.js';
var DASH_PATH = 'https://web.sdk.qcloud.com/player/tcplayer/release/v4.6.0/libs/dash.all.min.4.4.1.js';

/**
 * @file url.js
 * @module url
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = document_1.createElement('a');

  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = void 0;

  if (addToBody) {
    div = document_1.createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document_1.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};

  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }

  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (!details.protocol) {
    details.protocol = window_1.location.protocol;
  }

  if (addToBody) {
    document_1.body.removeChild(div);
  }

  return details;
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 *
 *
 * @param  {string} url
 *         URL to make absolute
 *
 * @return {string}
 *         Absolute URL
 *
 * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = document_1.createElement('div');

    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

/**
 * Returns the extension of the passed file name. It will return an empty string
 * if passed an invalid path.
 *
 * @param {string} path
 *        The fileName path like '/path/to/file.mp4'
 *
 * @returns {string}
 *          The extension in lower case or an empty string if no
 *          extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {string} url
 *        The url to check.
 *
 * @return {boolean}
 *         Whether it is a cross domain request or not.
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = window_1.location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};

var Url = (Object.freeze || Object)({
	parseUrl: parseUrl,
	getAbsoluteURL: getAbsoluteURL,
	getFileExtension: getFileExtension,
	isCrossOrigin: isCrossOrigin
});

function getParams(name, url) {
  var search = url.split('?')[1]; // || window.location.search.substr(1);
  if (!search) return;
  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  var r = search.match(reg);
  if (r != null) {
    return decodeURIComponent(r[2]);
  }
  return null;
}

function guid() {
  function S4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  }
  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
}



/**
 * 与页面统一 url protocol，如果非http、https协议则使用 http
 * @param url
 */
function unifyProtocol(url) {
  url = url.replace(/^(http|https):/, '');
  var protocol = window.location.protocol;
  if (protocol != 'http:' && protocol != 'https:') {
    protocol = 'https:';
  }
  url = protocol + url;
  return url;
}

function replaceHost(url, host) {
  var reg = /^http(s)?:\/\/(.*?)\//,
      match = url.match(reg);
  return url.replace(match[2], host);
}

function getViewportSize() {
  var doc = document;
  var docE = doc.documentElement;
  var body = doc.body;
  return {
    'width': docE && docE.clientWidth || body && body.offsetWidth || window.innerWidth || 0,
    'height': docE && docE.clientHeight || body && body.offsetHeight || window.innerHeight || 0
  };
}

function getTimeStamp() {
  return new Date().getTime();
}

function getTimeStampBySecond() {
  return Date.parse(new Date()) / 1000;
}

/**
* 动态加载css脚本
* @param {string} id 节点id
* @param {string} cssText css样式
*/


function loadScript(src, callback, attrs) {
  var remove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var tag = document.createElement("script");

  tag.onload = tag.onreadystatechange = function () {
    if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
      if (typeof callback == "function") {
        callback();
      }
      tag.onload = tag.onreadystatechange = null;

      if (tag.parentNode && !remove) {
        tag.parentNode.removeChild(tag);
      }
    }
  };
  if (attrs) {
    for (var k in attrs) {
      if (!attrs.hasOwnProperty(k)) continue;
      var attr = attrs[k];
      if (attr === null) tag.removeAttribute(attr);else tag.setAttribute(k, attr);
    }
  }
  tag.src = src;
  document.getElementsByTagName("head")[0].appendChild(tag);
}

/**
 * 序列化参数
 * @param args
 */
function serializeParams(args) {
  var s = [];
  var add = function add(k, v) {
    v = typeof v === 'function' ? v() : v;
    v = v === null ? '' : v === undefined ? '' : v;
    s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);
  };
  var buildParams = function buildParams(prefix, obj) {
    var i = void 0,
        len = void 0,
        key = void 0;

    if (prefix) {
      if (Array.isArray(obj)) {
        for (i = 0, len = obj.length; i < len; i++) {
          buildParams(prefix + '[' + (_typeof(obj[i]) === 'object' && obj[i] ? i : '') + ']', obj[i]);
        }
      } else if (String(obj) === '[object Object]') {
        for (key in obj) {
          buildParams(prefix + '[' + key + ']', obj[key]);
        }
      } else {
        add(prefix, obj);
      }
    } else if (Array.isArray(obj)) {
      for (i = 0, len = obj.length; i < len; i++) {
        add(obj[i].name, obj[i].value);
      }
    } else {
      for (key in obj) {
        buildParams(key, obj[key]);
      }
    }
    return s;
  };

  return buildParams('', args).join('&');
}

/**
 * 编码html
 * @param str
 * @returns {string}
 */
function encodeHTML(unsafe_str) {
  if (!unsafe_str.length) {
    return "";
  }
  return String(unsafe_str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\'/g, '&#39;').replace(/\//g, '&#x2F;');
}

/**
 * 在调用player.src 之前，对sources进行检查，为 sources 加上 MIME type 声明
 * 
 * @example
 * // input:
 * sources: [{
 *    src: 'https://5664.liveplay.myqcloud.com/live/5664_harchar1.m3u8?txSecret=f22a813b284137ed10d3259a7b5c224b&txTime=6403f7bb'
 *  }]
 * // or
 * sources: {
 *  src: 'https://5664.liveplay.myqcloud.com/live/5664_harchar1.m3u8?txSecret=f22a813b284137ed10d3259a7b5c224b&txTime=6403f7bb'
 * }
 * // output:
 * sources: [{
 *    src: 'https://5664.liveplay.myqcloud.com/live/5664_harchar1.m3u8?txSecret=f22a813b284137ed10d3259a7b5c224b&txTime=6403f7bb',
 *    type: 'application/x-mpegURL'
 *  }]
 * // or
 * sources: {
 *  src: 'https://5664.liveplay.myqcloud.com/live/5664_harchar1.m3u8?txSecret=f22a813b284137ed10d3259a7b5c224b&txTime=6403f7bb',
 *  type: 'application/x-mpegURL'
 * }
 * 
 */


/**
   * 根据url的文件扩展名，获取对应的mime type
   * @param url
   * @returns {string}
   */


/**
   * 判断当前url是否是 webrtc 地址
   * @param url
   * @returns {boolean}
   */
function isWebrtcUrl(url) {
  return (/webrtc:\/\//.test(url) || /\.sdp/.test(url)
  );
}

/**
 * @file time-ranges.js
 * @module time-ranges
 */

/**
 * Returns the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @function time-ranges:indexFunction
 *
 * @param {number} [index=0]
 *        The range number to return the time for.
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 * @depricated index must be set to a value, in the future this will throw an error.
 */

/**
 * An object that contains ranges of time for various reasons.
 *
 * @typedef {Object} TimeRange
 *
 * @property {number} length
 *           The number of time ranges represented by this Object
 *
 * @property {time-ranges:indexFunction} start
 *           Returns the time offset at which a specified time range begins.
 *
 * @property {time-ranges:indexFunction} end
 *           Returns the time offset at which a specified time range begins.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
 */

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {number} index
 *        The index to check
 *
 * @param {number} maxIndex
 *        The maximum possible index
 *
 * @throws {Error} if the timeRanges provided are over the maxIndex
 */
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== 'number' || index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');
  }
}

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {string} valueIndex
 *        The proprety that should be used to get the time. should be 'start' or 'end'
 *
 * @param {Array} ranges
 *        An array of time ranges
 *
 * @param {Array} [rangeIndex=0]
 *        The index to start the search at
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 *
 * @depricated rangeIndex must be set to a value, in the future this will throw an error.
 * @throws {Error} if rangeIndex is more than the length of ranges
 */
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

/**
 * Create a time range object givent ranges of time.
 *
 * @param {Array} [ranges]
 *        An array of time ranges.
 */
function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

/**
 * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.
 *
 * @param {number|Array} start
 *        The start of a single range or an array of ranges
 *
 * @param {number} end
 *        The end of a single range.
 *
 * @private
 */
function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

/**
 * @file buffer.js
 * @module buffer
 */
function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0;
  var start = void 0;
  var end = void 0;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

/**
 * @file fullscreen-api.js
 * @module fullscreen-api
 * @private
 */
var FullscreenApi = {};

// browser API methods
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = void 0;
var prefixedAPI = false;

// determine the supported set of functions
for (var i$2 = 0; i$2 < apiMap.length; i$2++) {
  // check for exitFullscreen function
  if (apiMap[i$2][1] in document_1) {
    browserApi = apiMap[i$2];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }

  prefixedAPI = browserApi[0] === specApi[0];
}

/**
 * @file media-error.js
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (isObject$1(value)) {

    // We assign the `code` property manually because native `MediaError` objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    assign(this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/**
 * The error code that refers two one of the defined `MediaError` types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message that to show with the error. Message is not part of the HTML5
 * video spec but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins to allow even more detail about
 * the error. For example a plugin might provide a specific HTTP status code and an
 * error message for that code. Then when the plugin gets that error this class will
 * know how to display an error message for it. This allows a custom message to show
 * up on the `Player` error overlay.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

/**
 * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
 * specification listed under {@link MediaError} for more information.
 *
 * @enum {array}
 * @readonly
 * @property {string} 0 - MEDIA_ERR_CUSTOM
 * @property {string} 1 - MEDIA_ERR_CUSTOM
 * @property {string} 2 - MEDIA_ERR_ABORTED
 * @property {string} 3 - MEDIA_ERR_NETWORK
 * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
 * @property {string} 5 - MEDIA_ERR_ENCRYPTED
 */
MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

/**
 * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
 *
 * @type {Array}
 * @constant
 */
MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

// jsdocs for instance/static members added above
// instance methods use `#` and static methods use `.`
/**
 * W3C error code for any custom error.
 *
 * @member MediaError#MEDIA_ERR_CUSTOM
 * @constant {number}
 * @default 0
 */
/**
 * W3C error code for any custom error.
 *
 * @member MediaError.MEDIA_ERR_CUSTOM
 * @constant {number}
 * @default 0
 */

/**
 * W3C error code for media error aborted.
 *
 * @member MediaError#MEDIA_ERR_ABORTED
 * @constant {number}
 * @default 1
 */
/**
 * W3C error code for media error aborted.
 *
 * @member MediaError.MEDIA_ERR_ABORTED
 * @constant {number}
 * @default 1
 */

/**
 * W3C error code for any network error.
 *
 * @member MediaError#MEDIA_ERR_NETWORK
 * @constant {number}
 * @default 2
 */
/**
 * W3C error code for any network error.
 *
 * @member MediaError.MEDIA_ERR_NETWORK
 * @constant {number}
 * @default 2
 */

/**
 * W3C error code for any decoding error.
 *
 * @member MediaError#MEDIA_ERR_DECODE
 * @constant {number}
 * @default 3
 */
/**
 * W3C error code for any decoding error.
 *
 * @member MediaError.MEDIA_ERR_DECODE
 * @constant {number}
 * @default 3
 */

/**
 * W3C error code for any time that a source is not supported.
 *
 * @member MediaError#MEDIA_ERR_SRC_NOT_SUPPORTED
 * @constant {number}
 * @default 4
 */
/**
 * W3C error code for any time that a source is not supported.
 *
 * @member MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
 * @constant {number}
 * @default 4
 */

/**
 * W3C error code for any time that a source is encrypted.
 *
 * @member MediaError#MEDIA_ERR_ENCRYPTED
 * @constant {number}
 * @default 5
 */
/**
 * W3C error code for any time that a source is encrypted.
 *
 * @member MediaError.MEDIA_ERR_ENCRYPTED
 * @constant {number}
 * @default 5
 */

var tuple = SafeParseTuple;

function SafeParseTuple(obj, reviver) {
    var json;
    var error = null;

    try {
        json = JSON.parse(obj, reviver);
    } catch (err) {
        error = err;
    }

    return [error, json]
}

/**
 * Returns whether an object is `Promise`-like (i.e. has a `then` method).
 *
 * @param  {Object}  value
 *         An object that may or may not be `Promise`-like.
 *
 * @return {Boolean}
 *         Whether or not the object is `Promise`-like.
 */
function isPromise(value) {
  return value !== undefined && typeof value.then === 'function';
}

/**
 * Silence a Promise-like object.
 *
 * This is useful for avoiding non-harmful, but potentially confusing "uncaught
 * play promise" rejection error messages.
 *
 * @param  {Object} value
 *         An object that may or may not be `Promise`-like.
 */
function silencePromise(value) {
  if (isPromise(value)) {
    value.then(null, function (e) {});
  }
}

/**
 * @file text-track-list-converter.js Utilities for capturing text track state and
 * re-creating tracks based on a capture.
 *
 * @module text-track-list-converter
 */

/**
 * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
 * represents the {@link TextTrack}'s state.
 *
 * @param {TextTrack} track
 *        The text track to query.
 *
 * @return {Object}
 *         A serializable javascript representation of the TextTrack.
 * @private
 */
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {

    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
 * state of all {@link TextTrack}s currently configured. The return array is compatible with
 * {@link text-track-list-converter:jsonToTextTracks}.
 *
 * @param {Tech} tech
 *        The tech object to query
 *
 * @return {Array}
 *         A serializable javascript representation of the {@link Tech}s
 *         {@link TextTrackList}.
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);

    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
 * object {@link TextTrack} representations.
 *
 * @param {Array} json
 *        An array of `TextTrack` representation objects, like those that would be
 *        produced by `textTracksToJson`.
 *
 * @param {Tech} tech
 *        The `Tech` to create the `TextTrack`s on.
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;

    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

var textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };

/**
 * @file modal-dialog.js
 */
var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 */

var ModalDialog = function (_Component) {
  inherits(ModalDialog, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Mixed} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  function ModalDialog(player, options) {
    classCallCheck(this, ModalDialog);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;

    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    _this.contentEl_ = createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    _this.descEl_ = createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-control-text',
      id: _this.el().getAttribute('aria-describedby')
    });

    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }

  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  ModalDialog.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      'role': 'dialog'
    });
  };

  ModalDialog.prototype.dispose = function dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles `keydown` events on the document, looking for ESC, which closes
   * the modal.
   *
   * @param {EventTarget~Event} e
   *        The keypress that triggered this event.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */


  ModalDialog.prototype.label = function label() {
    return this.localize(this.options_.label || 'Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */


  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */


  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {EventTarget~Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
      }

      // Hide controls and note if they were enabled.
      this.hadControls_ = player.controls();
      player.controls(false);

      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {EventTarget~Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
  };

  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */


  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */


  ModalDialog.prototype.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();

    /**
      * Fired just before a `ModalDialog` is closed.
      *
      * @event ModalDialog#beforemodalclose
      * @type {EventTarget~Event}
      */
    this.trigger('beforemodalclose');
    this.opened_ = false;

    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }

    if (this.closeable()) {
      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
    }

    if (this.hadControls_) {
      player.controls(true);
    }

    this.hide();
    this.el().setAttribute('aria-hidden', 'true');

    /**
      * Fired just after a `ModalDialog` is closed.
      *
      * @event ModalDialog#modalclose
      * @type {EventTarget~Event}
      */
    this.trigger('modalclose');
    this.conditionalBlur_();

    if (this.options_.temporary) {
      this.dispose();
    }
  };

  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */


  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;

        this.contentEl_ = this.el_;
        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && close) {
        this.off(close, 'close', this.close);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */


  ModalDialog.prototype.fill = function fill() {
    this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {Mixed} [content]
   *        The same rules apply to this as apply to the `content` option.
   */


  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    /**
     * Fired just before a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#beforemodalfill
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    /**
     * Fired just after a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#modalfill
     * @type {EventTarget~Event}
     */
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    // make sure that the close button is last in the dialog DOM
    var closeButton = this.getChild('closeButton');

    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };

  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */


  ModalDialog.prototype.empty = function empty() {
    /**
     * Fired just before a `ModalDialog` is emptied.
     *
     * @event ModalDialog#beforemodalempty
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalempty');
    emptyEl(this.contentEl());

    /**
     * Fired just after a `ModalDialog` is emptied.
     *
     * @event ModalDialog#modalempty
     * @type {EventTarget~Event}
     */
    this.trigger('modalempty');
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   *         The current content of the modal dialog
   */


  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */


  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document_1.activeElement;
    var playerEl = this.player_.el_;

    this.previouslyActiveEl_ = null;

    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;

      this.focus();

      this.on(document_1, 'keydown', this.handleKeyDown);
    }
  };

  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */


  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }

    this.off(document_1, 'keydown', this.handleKeyDown);
  };

  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {
    // exit early if it isn't a tab key
    if (event.which !== 9) {
      return;
    }

    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(':focus');
    var focusIndex = void 0;

    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }

    if (document_1.activeElement === this.el_) {
      focusIndex = 0;
    }

    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };

  /**
   * get all focusable elements
   *
   * @private
   */


  ModalDialog.prototype.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll('*');

    return Array.prototype.filter.call(allChildren, function (child) {
      return (child instanceof window_1.HTMLAnchorElement || child instanceof window_1.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window_1.HTMLInputElement || child instanceof window_1.HTMLSelectElement || child instanceof window_1.HTMLTextAreaElement || child instanceof window_1.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window_1.HTMLIFrameElement || child instanceof window_1.HTMLObjectElement || child instanceof window_1.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
    });
  };

  return ModalDialog;
}(Component);

/**
 * Default options for `ModalDialog` default options.
 *
 * @type {Object}
 * @private
 */


ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};

Component.registerComponent('ModalDialog', ModalDialog);

/**
 * @file track-list.js
 */
var TrackList = function (_EventTarget) {
  inherits(TrackList, _EventTarget);

  /**
   * Create an instance of this class
   *
   * @param {Track[]} tracks
   *        A list of tracks to initialize the list with.
   *
   * @param {Object} [list]
   *        The child object with inheritance done manually for ie8.
   *
   * @abstract
   */
  function TrackList() {
    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ret;

    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TrackList);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    if (!list) {
      list = _this; // eslint-disable-line
      if (IS_IE8) {
        list = document_1.createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];

    /**
     * @memberof TrackList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack(tracks[i]);
    }

    // must return the object, as for ie8 it will not be this
    // but a reference to a document object
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TrackList.prototype.addTrack = function addTrack(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      /**
       * Triggered when a track is added to a track list.
       *
       * @event TrackList#addtrack
       * @type {EventTarget~Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */


  TrackList.prototype.removeTrack = function removeTrack(rtrack) {
    var track = void 0;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    /**
     * Triggered when a track is removed from track list.
     *
     * @event TrackList#removetrack
     * @type {EventTarget~Event}
     * @property {Track} track
     *           A reference to track that was removed.
     */
    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */


  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
}(EventTarget);

/**
 * Triggered when a different track is selected/enabled.
 *
 * @event TrackList#change
 * @type {EventTarget~Event}
 */

/**
 * Events that can be called with on + eventName. See {@link EventHandler}.
 *
 * @property {Object} TrackList#allowedEvents_
 * @private
 */


TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var event$1 in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + event$1] = null;
}

/**
 * @file audio-track-list.js
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};

/**
 * The current list of {@link AudioTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
 * @extends TrackList
 */

var AudioTrackList = function (_TrackList) {
  inherits(AudioTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  function AudioTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, AudioTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in AudioTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = AudioTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  AudioTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens AudioTrack#enabledchange
     * @fires TrackList#change
     */
    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return AudioTrackList;
}(TrackList);

/**
 * @file video-track-list.js
 */
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another video track is enabled, disable it
    list[i].selected = false;
  }
};

/**
 * The current list of {@link VideoTrack} for a video.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
 * @extends TrackList
 */

var VideoTrackList = function (_TrackList) {
  inherits(VideoTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  function VideoTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, VideoTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in VideoTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = VideoTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    /**
     * @member {number} VideoTrackList#selectedIndex
     *         The current index of the selected {@link VideoTrack`}.
     */
    Object.defineProperty(list, 'selectedIndex', {
      get: function get$$1() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set$$1() {}
    });

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  VideoTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.selected) {
      disableOthers$1(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens VideoTrack#selectedchange
     * @fires TrackList#change
     */
    track.addEventListener('selectedchange', function () {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return VideoTrackList;
}(TrackList);

/**
 * @file text-track-list.js
 */
var TextTrackList = function (_TrackList) {
  inherits(TextTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {TextTrack[]} [tracks=[]]
   *        A list of `TextTrack` to instantiate the list with.
   */
  function TextTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, TextTrackList);

    var list = void 0;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in TextTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = TextTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TextTrackList.prototype.addTrack = function addTrack(track) {
    // fixed safari hls empty sub item
    if (track.mode === 'disabled' && !track.label) {
      return false;
    }
    _TrackList.prototype.addTrack.call(this, track);

    /**
     * @listens TextTrack#modechange
     * @fires TrackList#change
     */
    track.addEventListener('modechange', bind(this, function () {
      this.trigger('change');
    }));

    var nonLanguageTextTrackKind = ['metadata', 'chapters'];

    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener('modechange', bind(this, function () {
        this.trigger('selectedlanguagechange');
      }));
    }
  };

  return TextTrackList;
}(TrackList);

/**
 * @file html-track-element-list.js
 */

var HtmlTrackElementList = function () {

  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  function HtmlTrackElementList() {
    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, HtmlTrackElementList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    /**
     * @memberof HtmlTrackElementList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, length = trackElements.length; i < length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.trackElements_[index];
        }
      });
    }

    // Do not add duplicate elements
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };

  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */


  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = void 0;

    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
}();

/**
 * @file text-track-cue-list.js
 */
var TextTrackCueList = function () {

  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */


  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get$$1() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */


  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
}();

/**
 * @file track-kinds.js
 */

/**
 * All possible `VideoTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 * @typedef VideoTrack~Kind
 * @enum
 */
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * All possible `AudioTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 * @typedef AudioTrack~Kind
 * @enum
 */
var AudioTrackKind = {
  'alternative': 'alternative',
  'descriptions': 'descriptions',
  'main': 'main',
  'main-desc': 'main-desc',
  'translation': 'translation',
  'commentary': 'commentary'
};

/**
 * All possible `TextTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
 * @typedef TextTrack~Kind
 * @enum
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * All possible `TextTrackMode`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 * @typedef TextTrack~Mode
 * @enum
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/**
 * @file track.js
 */
var Track = function (_EventTarget) {
  inherits(Track, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  function Track() {
    var _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Track);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var track = _this; // eslint-disable-line

    if (IS_IE8) {
      track = document_1.createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || (options.id === 0 ? 0 : 'vjs_track_' + newGUID()),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    /**
     * @memberof Track
     * @member {string} id
     *         The id of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} kind
     *         The kind of track that this is. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} label
     *         The label of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} language
     *         The two letter language code for this track. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */

    var _loop = function _loop(key) {
      Object.defineProperty(track, key, {
        get: function get$$1() {
          return trackProps[key];
        },
        set: function set$$1() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return Track;
}(EventTarget);

var isFunction_1 = isFunction$1;

var toString$1 = Object.prototype.toString;

function isFunction$1 (fn) {
  if (!fn) {
    return false
  }
  var string = toString$1.call(fn);
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
}

var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
};
var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };

var parseHeaders = function (headers) {
  if (!headers)
    return {}

  var result = {};

  var headersArr = trim(headers).split('\n');

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i];
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1));

    if (typeof(result[key]) === 'undefined') {
      result[key] = value;
    } else if (isArray(result[key])) {
      result[key].push(value);
    } else {
      result[key] = [ result[key], value ];
    }
  }

  return result
};

var immutable = extend$1;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend$1() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var xhr = createXHR;
createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options)
    };
});

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction_1(options)) {
        callback = options;
        if (typeof uri === "string") {
            params = {uri:uri};
        }
    } else {
        params = immutable(options, {uri: uri});
    }

    params.callback = callback;
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false;
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true;
            options.callback(err, response, body);
        }
    };

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0);
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined;

        if (xhr.response) {
            body = xhr.response;
        } else {
            body = xhr.responseText || getXml(xhr);
        }

        if (isJson) {
            try {
                body = JSON.parse(body);
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status;
        clearTimeout(timeoutTimer);
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200;
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status);
        }
        var response = failureResponse;
        var err = null;

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            };
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders());
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null;

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest();
        }else{
            xhr = new createXHR.XMLHttpRequest();
        }
    }

    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json);
        }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    };
    xhr.onabort = function(){
        aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials;
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true;//IE9 may still call readystatechange
            xhr.abort("timeout");
            var e = new Error("XMLHttpRequest timeout");
            e.code = "ETIMEDOUT";
            errorFunc(e);
        }, options.timeout );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr);
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null);

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

/**
 * @file text-track.js
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new window_1.WebVTT.Parser(window_1, window_1.vttjs, window_1.WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (window_1.console && window_1.console.groupCollapsed) {
      window_1.console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return log$2.error(error);
    });
    if (window_1.console && window_1.console.groupEnd) {
      window_1.console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * Load a `TextTrack` from a specifed url.
 *
 * @param {string} src
 *        Url to load track from.
 *
 * @param {TextTrack} track
 *        Track to add cues to. Comes from the content at the end of `url`.
 *
 * @private
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  xhr(opts, bind(this, function (err, response, responseBody) {
    if (err) {
      return log$2.error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof window_1.WebVTT !== 'function') {
      if (track.tech_) {
        var loadHandler = function loadHandler() {
          return parseCues(responseBody, track);
        };

        track.tech_.on('vttjsloaded', loadHandler);
        track.tech_.on('vttjserror', function () {
          log$2.error('vttjs failed to load, stopping trying to process ' + track.src);
          track.tech_.off('vttjsloaded', loadHandler);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A representation of a single `TextTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
 * @extends Track
 */

var TextTrack = function (_Track) {
  inherits(TextTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function TextTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = mergeOptions(options, {
      kind: TextTrackKind[options.kind] || options.kind || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);

    tt.tech_ = settings.tech;

    if (IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new TextTrackCueList(tt.cues_);
    var activeCues = new TextTrackCueList(tt.activeCues_);
    var changed = false;
    var timeupdateHandler = bind(tt, function () {

      // Accessing this.activeCues for the side-effects of updating itself
      // due to it's nature as a getter function. Do not remove or cues will
      // stop updating!
      /* eslint-disable no-unused-expressions */
      this.activeCues;
      /* eslint-enable no-unused-expressions */
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.ready(function () {
        tt.tech_.on('timeupdate', timeupdateHandler);
      }, true);
    }

    /**
     * @memberof TextTrack
     * @member {boolean} default
     *         If this track was set to be on or off by default. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */
    Object.defineProperty(tt, 'default', {
      get: function get$$1() {
        return default_;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {string} mode
     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
     *         not be set if setting to an invalid mode.
     * @instance
     *
     * @fires TextTrack#modechange
     */
    Object.defineProperty(tt, 'mode', {
      get: function get$$1() {
        return mode;
      },
      set: function set$$1(newMode) {
        var _this2 = this;

        if (!TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {

          this.tech_.ready(function () {
            _this2.tech_.on('timeupdate', timeupdateHandler);
          }, true);
        }
        /**
         * An event that fires when mode changes on this track. This allows
         * the TextTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec!
         *
         * @event TextTrack#modechange
         * @type {EventTarget~Event}
         */
        this.trigger('modechange');
      }
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} cues
     *         The text track cue list for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'cues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} activeCues
     *         The list text track cues that are currently active for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'activeCues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var _i = 0; _i < active.length; _i++) {
            if (this.activeCues_.indexOf(active[_i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set$$1() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return _ret = tt, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */


  TextTrack.prototype.addCue = function addCue(originalCue) {
    var cue = originalCue;

    if (window_1.vttjs && !(originalCue instanceof window_1.vttjs.VTTCue)) {
      cue = new window_1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);

      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }

      // make sure that `id` is copied over
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }

    var tracks = this.tech_.textTracks();

    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */


  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;

    while (i--) {
      var cue = this.cues_[i];

      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };

  return TextTrack;
}(Track);

/**
 * cuechange - One or more cues in the track have become active or stopped being active.
 */


TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

var AudioTrack = function (_Track) {
  inherits(AudioTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  function AudioTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AudioTrack);

    var settings = mergeOptions(options, {
      kind: AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var enabled = false;

    if (IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }
    /**
     * @memberof AudioTrack
     * @member {boolean} enabled
     *         If this `AudioTrack` is enabled or not. When setting this will
     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'enabled', {
      get: function get$$1() {
        return enabled;
      },
      set: function set$$1(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;

        /**
         * An event that fires when enabled changes on this track. This allows
         * the AudioTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event AudioTrack#enabledchange
         * @type {EventTarget~Event}
         */
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return AudioTrack;
}(Track);

var VideoTrack = function (_Track) {
  inherits(VideoTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  function VideoTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VideoTrack);

    var settings = mergeOptions(options, {
      kind: VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var selected = false;

    if (IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    /**
     * @memberof VideoTrack
     * @member {boolean} selected
     *         If this `VideoTrack` is selected or not. When setting this will
     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'selected', {
      get: function get$$1() {
        return selected;
      },
      set: function set$$1(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;

        /**
         * An event that fires when selected changes on this track. This allows
         * the VideoTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event VideoTrack#selectedchange
         * @type {EventTarget~Event}
         */
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return VideoTrack;
}(Track);

/**
 * @file html-track-element.js
 */

var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * A single track represented in the DOM.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
 * @extends EventTarget
 */

var HTMLTrackElement = function (_EventTarget) {
  inherits(HTMLTrackElement, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function HTMLTrackElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HTMLTrackElement);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var readyState = void 0;
    var trackElement = _this; // eslint-disable-line

    if (IS_IE8) {
      trackElement = document_1.createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new TextTrack(options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    /**
     * @memberof HTMLTrackElement
     * @member {HTMLTrackElement~ReadyState} readyState
     *         The current ready state of the track element.
     * @instance
     */
    Object.defineProperty(trackElement, 'readyState', {
      get: function get$$1() {
        return readyState;
      }
    });

    /**
     * @memberof HTMLTrackElement
     * @member {TextTrack} track
     *         The underlying TextTrack object.
     * @instance
     *
     */
    Object.defineProperty(trackElement, 'track', {
      get: function get$$1() {
        return track;
      }
    });

    readyState = NONE;

    /**
     * @listens TextTrack#loadeddata
     * @fires HTMLTrackElement#load
     */
    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (IS_IE8) {
      var _ret;

      return _ret = trackElement, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  return HTMLTrackElement;
}(EventTarget);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: 'Audio'
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: 'Video'
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'Text'
  }
};

Object.keys(NORMAL).forEach(function (type) {
  NORMAL[type].getterName = type + 'Tracks';
  NORMAL[type].privateName = type + 'Tracks_';
});

var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'RemoteText',
    getterName: 'remoteTextTracks',
    privateName: 'remoteTextTracks_'
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: 'RemoteTextTrackEls',
    getterName: 'remoteTextTrackEls',
    privateName: 'remoteTextTrackEls_'
  }
};

var ALL = mergeOptions(NORMAL, REMOTE);

REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
var _objCreate = Object.create || (function() {
  function F() {}
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error('Object.create shim only accepts one parameter.');
    }
    F.prototype = o;
    return new F();
  };
})();

// Creates a new ParserError object from an errorData object. The errorData
// object should have default code and message properties. The default message
// property can be overriden by passing in a message parameter.
// See ParsingError.Errors below for acceptable errors.
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;

// ParsingError metadata for acceptable ParsingErrors.
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0,  m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = _objCreate(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) { // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    var m;
    if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                            "Malformed timestamp: " + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
      case "region":
        // Find the last region we parsed with the same region id.
        for (var i = regionList.length - 1; i >= 0; i--) {
          if (regionList[i].id === v) {
            settings.set(k, regionList[i].region);
            break;
          }
        }
        break;
      case "vertical":
        settings.alt(k, v, ["rl", "lr"]);
        break;
      case "line":
        var vals = v.split(","),
            vals0 = vals[0];
        settings.integer(k, vals0);
        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
        settings.alt(k, vals0, ["auto"]);
        if (vals.length === 2) {
          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "position":
        vals = v.split(",");
        settings.percent(k, vals[0]);
        if (vals.length === 2) {
          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "size":
        settings.percent(k, v);
        break;
      case "align":
        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
        break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get("region", null);
    cue.vertical = settings.get("vertical", "");
    cue.line = settings.get("line", "auto");
    cue.lineAlign = settings.get("lineAlign", "start");
    cue.snapToLines = settings.get("snapToLines", true);
    cue.size = settings.get("size", 100);
    cue.align = settings.get("align", "middle");
    cue.position = settings.get("position", {
      start: 0,
      left: 0,
      middle: 50,
      end: 100,
      right: 100
    }, cue.align);
    cue.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      middle: "middle",
      end: "end",
      right: "end"
    }, cue.align);
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp();   // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
    throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                           "Malformed time stamp (time stamps must be separated by '-->'): " +
                           oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();     // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

var ESCAPE = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&lrm;": "\u200e",
  "&rlm;": "\u200f",
  "&nbsp;": "\u00a0"
};

var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};

var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};

var NEEDS_PARENT = {
  rt: "ruby"
};

// Parse content into a document fragment.
function parseContent(window, input) {
  function nextToken() {
    // Check for end-of-string.
    if (!input) {
      return null;
    }

    // Consume 'n' characters from the input.
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }

    var m = input.match(/^([^<]*)(<[^>]+>?)?/);
    // If there is some text before the next tag, return it, otherwise return
    // the tag.
    return consume(m[1] ? m[1] : m[2]);
  }

  // Unescape a string 's'.
  function unescape1(e) {
    return ESCAPE[e];
  }
  function unescape(s) {
    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
      s = s.replace(m[0], unescape1);
    }
    return s;
  }

  function shouldAdd(current, element) {
    return !NEEDS_PARENT[element.localName] ||
           NEEDS_PARENT[element.localName] === current.localName;
  }

  // Create an element for this tag.
  function createElement(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window.document.createElement(tagName);
    element.localName = tagName;
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }

  var rootDiv = window.document.createElement("div"),
      current = rootDiv,
      t,
      tagStack = [];

  while ((t = nextToken()) !== null) {
    if (t[0] === '<') {
      if (t[1] === "/") {
        // If the closing tag matches, move back up to the parent node.
        if (tagStack.length &&
            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        // Otherwise just ignore the end tag.
        continue;
      }
      var ts = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts) {
        // Timestamps are lead nodes as well.
        node = window.document.createProcessingInstruction("timestamp", ts);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      // If we can't parse the tag, skip to the next tag.
      if (!m) {
        continue;
      }
      // Try to construct an element, and ignore the tag if we couldn't.
      node = createElement(m[1], m[3]);
      if (!node) {
        continue;
      }
      // Determine if the tag should be added based on the context of where it
      // is placed in the cuetext.
      if (!shouldAdd(current, node)) {
        continue;
      }
      // Set the class list (as a list of classes, separated by space).
      if (m[2]) {
        node.className = m[2].substr(1).replace('.', ' ');
      }
      // Append the node to the current node, and enter the scope of the new
      // node.
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }

    // Text nodes are leaf nodes.
    current.appendChild(window.document.createTextNode(unescape(t)));
  }

  return rootDiv;
}

// This is a list of all the Unicode characters that have a strong
// right-to-left category. What this means is that these characters are
// written right-to-left for sure. It was generated by pulling all the strong
// right-to-left characters out of the Unicode data table. That table can
// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
 [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
 [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
 [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
 [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
 [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
 [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
 [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
 [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
 [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
 [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
 [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
 [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
 [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
 [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
 [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
 [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
 [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
 [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
 [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
 [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
 [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
 [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
 [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
 [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }

  return false;
}

function determineBidi(cueDiv) {
  var nodeStack = [],
      text = "",
      charCode;

  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }

  function pushNodes(nodeStack, node) {
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      nodeStack.push(node.childNodes[i]);
    }
  }

  function nextTextNode(nodeStack) {
    if (!nodeStack || !nodeStack.length) {
      return null;
    }

    var node = nodeStack.pop(),
        text = node.textContent || node.innerText;
    if (text) {
      // TODO: This should match all unicode type B characters (paragraph
      // separator characters). See issue #115.
      var m = text.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack.length = 0;
        return m[0];
      }
      return text;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack);
    }
    if (node.childNodes) {
      pushNodes(nodeStack, node);
      return nextTextNode(nodeStack);
    }
  }

  pushNodes(nodeStack, cueDiv);
  while ((text = nextTextNode(nodeStack))) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}

function computeLinePos(cue) {
  if (typeof cue.line === "number" &&
      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList ||
      !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track,
      trackList = track.textTrackList,
      count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}

function StyleBox() {
}

// Apply styles to a div. If there is no div passed then it defaults to the
// div on 'this'.
StyleBox.prototype.applyStyles = function(styles, div) {
  div = div || this.div;
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      div.style[prop] = styles[prop];
    }
  }
};

StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};

// Constructs the computed display state of the cue (a div). Places the div
// into the overlay which should be a block level element (usually a div).
function CueStyleBox(window, cue, styleOptions) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var color = "rgba(255, 255, 255, 1)";
  var backgroundColor = "rgba(0, 0, 0, 0.8)";

  if (isIE8) {
    color = "rgb(255, 255, 255)";
    backgroundColor = "rgb(0, 0, 0)";
  }

  StyleBox.call(this);
  this.cue = cue;

  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
  // have inline positioning and will function as the cue background box.
  this.cueDiv = parseContent(window, cue.text);
  var styles = {
    color: color,
    backgroundColor: backgroundColor,
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline"
  };

  if (!isIE8) {
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl";
    styles.unicodeBidi = "plaintext";
  }
  this.applyStyles(styles, this.cueDiv);

  // Create an absolutely positioned div that will be used to position the cue
  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
  // mirrors of them except "middle" which is "center" in CSS.
  this.div = window.document.createElement("div");
  styles = {
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };

  if (!isIE8) {
    styles.direction = determineBidi(this.cueDiv);
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl".
    stylesunicodeBidi =  "plaintext";
  }

  this.applyStyles(styles);

  this.div.appendChild(this.cueDiv);

  // Calculate the distance from the reference edge of the viewport to the text
  // position of the cue box. The reference edge will be resolved later when
  // the box orientation styles are applied.
  var textPos = 0;
  switch (cue.positionAlign) {
  case "start":
    textPos = cue.position;
    break;
  case "middle":
    textPos = cue.position - (cue.size / 2);
    break;
  case "end":
    textPos = cue.position - cue.size;
    break;
  }

  // Horizontal box orientation; textPos is the distance from the left edge of the
  // area to the left edge of the box and cue.size is the distance extending to
  // the right from there.
  if (cue.vertical === "") {
    this.applyStyles({
      left:  this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  // Vertical box orientation; textPos is the distance from the top edge of the
  // area to the top edge of the box and cue.size is the height extending
  // downwards from there.
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }

  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;

// Represents the co-ordinates of an Element in a way that we can easily
// compute things with such as if it overlaps or intersects with another Element.
// Can initialize it with either a StyleBox or another BoxPosition.
function BoxPosition(obj) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
  // was passed in and we need to copy the results of 'getBoundingClientRect'
  // as the object returned is readonly. All co-ordinate values are in reference
  // to the viewport origin (top left).
  var lh, height, width, top;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top = obj.div.offsetTop;

    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    // In certain cases the outter div will be slightly larger then the sum of
    // the inner div's lines. This could be due to bold text, etc, on some platforms.
    // In this case we should get the average line height and use that. This will
    // result in the desired behaviour.
    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
               : 0;

  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top;
  this.height = obj.height || height;
  this.bottom = obj.bottom || (top + (obj.height || height));
  this.width = obj.width || width;
  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

  if (isIE8 && !this.lineHeight) {
    this.lineHeight = 13;
  }
}

// Move the box along a particular axis. Optionally pass in an amount to move
// the box. If no amount is passed then the default is the line height of the
// box.
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== undefined ? toMove : this.lineHeight;
  switch (axis) {
  case "+x":
    this.left += toMove;
    this.right += toMove;
    break;
  case "-x":
    this.left -= toMove;
    this.right -= toMove;
    break;
  case "+y":
    this.top += toMove;
    this.bottom += toMove;
    break;
  case "-y":
    this.top -= toMove;
    this.bottom -= toMove;
    break;
  }
};

// Check if this box overlaps another box, b2.
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right &&
         this.right > b2.left &&
         this.top < b2.bottom &&
         this.bottom > b2.top;
};

// Check if this box overlaps any other boxes in boxes.
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};

// Check if this box is within another box.
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top &&
         this.bottom <= container.bottom &&
         this.left >= container.left &&
         this.right <= container.right;
};

// Check if this box is entirely within the container or it is overlapping
// on the edge opposite of the axis direction passed. For example, if "+x" is
// passed and the box is overlapping on the left edge of the container, then
// return true.
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
  case "+x":
    return this.left < container.left;
  case "-x":
    return this.right > container.right;
  case "+y":
    return this.top < container.top;
  case "-y":
    return this.bottom > container.bottom;
  }
};

// Find the percentage of the area that this box is overlapping with another
// box.
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
      intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};

// Convert the positions from this box to CSS compatible positions using
// the reference container's positions. This has to be done because this
// box's positions are in reference to the viewport origin, whereas, CSS
// values are in referecne to their respective edges.
BoxPosition.prototype.toCSSCompatValues = function(reference) {
  return {
    top: this.top - reference.top,
    bottom: reference.bottom - this.bottom,
    left: this.left - reference.left,
    right: reference.right - this.right,
    height: this.height,
    width: this.width
  };
};

// Get an object that represents the box's position without anything extra.
// Can pass a StyleBox, HTMLElement, or another BoxPositon.
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

  obj = obj.div ? obj.div.getBoundingClientRect() :
                obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top,
    height: obj.height || height,
    bottom: obj.bottom || (top + (obj.height || height)),
    width: obj.width || width
  };
  return ret;
};

// Move a StyleBox to its specified, or next best, position. The containerBox
// is the box that contains the StyleBox, such as a div. boxPositions are
// a list of other boxes that the styleBox can't overlap with.
function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

  // Find the best position for a cue box, b, on the video. The axis parameter
  // is a list of axis, the order of which, it will move the box along. For example:
  // Passing ["+x", "-x"] will move the box first along the x axis in the positive
  // direction. If it doesn't find a good position for it there it will then move
  // it along the x axis in the negative direction.
  function findBestPosition(b, axis) {
    var bestPosition,
        specifiedPosition = new BoxPosition(b),
        percentage = 1; // Highest possible so the first thing we get is better.

    for (var i = 0; i < axis.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
             (b.within(containerBox) && b.overlapsAny(boxPositions))) {
        b.move(axis[i]);
      }
      // We found a spot where we aren't overlapping anything. This is our
      // best position.
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      // If we're outside the container box less then we were on our last try
      // then remember this position as the best position.
      if (percentage > p) {
        bestPosition = new BoxPosition(b);
        percentage = p;
      }
      // Reset the box position to the specified position.
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition || specifiedPosition;
  }

  var boxPosition = new BoxPosition(styleBox),
      cue = styleBox.cue,
      linePos = computeLinePos(cue),
      axis = [];

  // If we have a line number to align the cue to.
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
    case "":
      axis = [ "+y", "-y" ];
      size = "height";
      break;
    case "rl":
      axis = [ "+x", "-x" ];
      size = "width";
      break;
    case "lr":
      axis = [ "-x", "+x" ];
      size = "width";
      break;
    }

    var step = boxPosition.lineHeight,
        position = step * Math.round(linePos),
        maxPosition = containerBox[size] + step,
        initialAxis = axis[0];

    // If the specified intial position is greater then the max position then
    // clamp the box to the amount of steps it would take for the box to
    // reach the max position.
    if (Math.abs(position) > maxPosition) {
      position = position < 0 ? -1 : 1;
      position *= Math.ceil(maxPosition / step) * step;
    }

    // If computed line position returns negative then line numbers are
    // relative to the bottom of the video instead of the top. Therefore, we
    // need to increase our initial position by the length or width of the
    // video, depending on the writing direction, and reverse our axis directions.
    if (linePos < 0) {
      position += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }

    // Move the box to the specified position. This may not be its best
    // position.
    boxPosition.move(initialAxis, position);

  } else {
    // If we have a percentage line value for the cue.
    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

    switch (cue.lineAlign) {
    case "middle":
      linePos -= (calculatedPercentage / 2);
      break;
    case "end":
      linePos -= calculatedPercentage;
      break;
    }

    // Apply initial line position to the cue box.
    switch (cue.vertical) {
    case "":
      styleBox.applyStyles({
        top: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "rl":
      styleBox.applyStyles({
        left: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "lr":
      styleBox.applyStyles({
        right: styleBox.formatStyle(linePos, "%")
      });
      break;
    }

    axis = [ "+y", "-x", "+x", "-y" ];

    // Get the box position again after we've applied the specified positioning
    // to it.
    boxPosition = new BoxPosition(styleBox);
  }

  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}

function WebVTT$1() {
  // Nothing
}

// Helper to allow strings to be decoded instead of the default binary utf8 data.
WebVTT$1.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

WebVTT$1.convertCueToDOMTree = function(window, cuetext) {
  if (!window || !cuetext) {
    return null;
  }
  return parseContent(window, cuetext);
};

var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";

// Runs the processing model over the cues and regions passed to it.
// @param overlay A block level element (usually a div) that the computed cues
//                and regions will be placed into.
WebVTT$1.processCues = function(window, cues, overlay) {
  if (!window || !cues || !overlay) {
    return null;
  }

  // Remove all previous children.
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }

  var paddedOverlay = window.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);

  // Determine if we need to compute the display states of the cues. This could
  // be the case if a cue's state has been changed since the last computation or
  // if it has not been computed yet.
  function shouldCompute(cues) {
    for (var i = 0; i < cues.length; i++) {
      if (cues[i].hasBeenReset || !cues[i].displayState) {
        return true;
      }
    }
    return false;
  }

  // We don't need to recompute the cues' display states. Just reuse them.
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }

  var boxPositions = [],
      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };

  (function() {
    var styleBox, cue;

    for (var i = 0; i < cues.length; i++) {
      cue = cues[i];

      // Compute the intial position and styles of the cue div.
      styleBox = new CueStyleBox(window, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);

      // Move the cue div to it's correct line position.
      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

      // Remember the computed div so that we don't have to recompute it later
      // if we don't have too.
      cue.displayState = styleBox.div;

      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};

WebVTT$1.Parser = function(window, vttjs, decoder) {
  if (!decoder) {
    decoder = vttjs;
    vttjs = {};
  }
  if (!vttjs) {
    vttjs = {};
  }

  this.window = window;
  this.vttjs = vttjs;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};

WebVTT$1.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function (data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, {stream: true});
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.4 WebVTT region and WebVTT region settings syntax
    function parseRegion(input) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "id":
          settings.set(k, v);
          break;
        case "width":
          settings.percent(k, v);
          break;
        case "lines":
          settings.integer(k, v);
          break;
        case "regionanchor":
        case "viewportanchor":
          var xy = v.split(',');
          if (xy.length !== 2) {
            break;
          }
          // We have to make sure both x and y parse, so use a temporary
          // settings object here.
          var anchor = new Settings();
          anchor.percent("x", xy[0]);
          anchor.percent("y", xy[1]);
          if (!anchor.has("x") || !anchor.has("y")) {
            break;
          }
          settings.set(k + "X", anchor.get("x"));
          settings.set(k + "Y", anchor.get("y"));
          break;
        case "scroll":
          settings.alt(k, v, ["up"]);
          break;
        }
      }, /=/, /\s/);

      // Create the region, using default values for any values that were not
      // specified.
      if (settings.has("id")) {
        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        // Register the region.
        self.onregion && self.onregion(region);
        // Remember the VTTRegion for later in case we parse any VTTCues that
        // reference it.
        self.regionList.push({
          id: settings.get("id"),
          region: region
        });
      }
    }

    // draft-pantos-http-live-streaming-20
    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
    // 3.5 WebVTT
    function parseTimestampMap(input) {
      var settings = new Settings();

      parseOptions(input, function(k, v) {
        switch(k) {
        case "MPEGT":
          settings.integer(k + 'S', v);
          break;
        case "LOCA":
          settings.set(k + 'L', parseTimeStamp(v));
          break;
        }
      }, /[^\d]:/, /,/);

      self.ontimestampmap && self.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        // This line contains HLS X-TIMESTAMP-MAP metadata
        parseOptions(input, function(k, v) {
          switch(k) {
          case "X-TIMESTAMP-MAP":
            parseTimestampMap(v);
            break;
          }
        }, /=/);
      } else {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === "INITIAL") {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }

        self.state = "HEADER";
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
        case "HEADER":
          // 13-18 - Allow a header (metadata) under the WEBVTT line.
          if (/:/.test(line)) {
            parseHeader(line);
          } else if (!line) {
            // An empty line terminates the header and starts the body (cues).
            self.state = "ID";
          }
          continue;
        case "NOTE":
          // Ignore NOTE blocks.
          if (!line) {
            self.state = "ID";
          }
          continue;
        case "ID":
          // Check for the start of NOTE blocks.
          if (/^NOTE($|[ \t])/.test(line)) {
            self.state = "NOTE";
            break;
          }
          // 19-29 - Allow any number of line terminators, then initialize new cue values.
          if (!line) {
            continue;
          }
          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
          self.state = "CUE";
          // 30-39 - Check if self line contains an optional identifier or timing data.
          if (line.indexOf("-->") === -1) {
            self.cue.id = line;
            continue;
          }
          // Process line as start of a cue.
          /*falls through*/
        case "CUE":
          // 40 - Collect cue timings and settings.
          try {
            parseCue(line, self.cue, self.regionList);
          } catch (e) {
            self.reportOrThrowError(e);
            // In case of an error ignore rest of the cue.
            self.cue = null;
            self.state = "BADCUE";
            continue;
          }
          self.state = "CUETEXT";
          continue;
        case "CUETEXT":
          var hasSubstring = line.indexOf("-->") !== -1;
          // 34 - If we have an empty line then report the cue.
          // 35 - If we have the special substring '-->' then report the cue,
          // but do not collect the line as we need to process the current
          // one as a new cue.
          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
            // We are done parsing self cue.
            self.oncue && self.oncue(self.cue);
            self.cue = null;
            self.state = "ID";
            continue;
          }
          if (self.cue.text) {
            self.cue.text += "\n";
          }
          self.cue.text += line;
          continue;
        case "BADCUE": // BADCUE
          // 54-62 - Collect and discard the remaining cue.
          if (!line) {
            self.state = "ID";
          }
          continue;
        }
      }
    } catch (e) {
      self.reportOrThrowError(e);

      // If we are currently parsing a cue, report what we have.
      if (self.state === "CUETEXT" && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function () {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === "HEADER") {
        self.buffer += "\n\n";
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch(e) {
      self.reportOrThrowError(e);
    }
    self.onflush && self.onflush();
    return this;
  }
};

var vtt$1 = WebVTT$1;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var autoKeyword = "auto";
var directionSetting = {
  "": true,
  "lr": true,
  "rl": true
};
var alignSetting = {
  "start": true,
  "middle": true,
  "end": true,
  "left": true,
  "right": true
};

function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

function extend$2(obj) {
  var i = 1;
  for (; i < arguments.length; i++) {
    var cobj = arguments[i];
    for (var p in cobj) {
      obj[p] = cobj[p];
    }
  }

  return obj;
}

function VTTCue(startTime, endTime, text) {
  var cue = this;
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var baseObj = {};

  if (isIE8) {
    cue = document.createElement('custom');
  } else {
    baseObj.enumerable = true;
  }

  /**
   * Shim implementation specific properties. These properties are not in
   * the spec.
   */

  // Lets us know when the VTTCue's data has changed in such a way that we need
  // to recompute its display state. This lets us compute its display state
  // lazily.
  cue.hasBeenReset = false;

  /**
   * VTTCue and TextTrackCue properties
   * http://dev.w3.org/html5/webvtt/#vttcue-interface
   */

  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = 50;
  var _positionAlign = "middle";
  var _size = 50;
  var _align = "middle";

  Object.defineProperty(cue,
    "id", extend$2({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));

  Object.defineProperty(cue,
    "pauseOnExit", extend$2({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));

  Object.defineProperty(cue,
    "startTime", extend$2({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "endTime", extend$2({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "text", extend$2({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "region", extend$2({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "vertical", extend$2({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "snapToLines", extend$2({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "line", extend$2({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "lineAlign", extend$2({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "position", extend$2({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "positionAlign", extend$2({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "size", extend$2({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "align", extend$2({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

  /**
   * Other <track> spec defined properties
   */

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
  cue.displayState = undefined;

  if (isIE8) {
    return cue;
  }
}

/**
 * VTTCue methods
 */

VTTCue.prototype.getCueAsHTML = function() {
  // Assume WebVTT.convertCueToDOMTree is on the global.
  return WebVTT.convertCueToDOMTree(window, this.text);
};

var vttcue = VTTCue;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scrollSetting = {
  "": true,
  "up": true
};

function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll = scrollSetting[value.toLowerCase()];
  return scroll ? value.toLowerCase() : false;
}

function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}

// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";

  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if(!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        // Have to check for false as an empty string is a legal value.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _scroll = setting;
      }
    }
  });
}

var vttregion = VTTRegion;

var browserIndex = createCommonjsModule(function (module) {
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Default exports for Node. Export the extended versions of VTTCue and
// VTTRegion in Node since we likely want the capability to convert back and
// forth between JSON. If we don't then it's not that big of a deal since we're
// off browser.



var vttjs = module.exports = {
  WebVTT: vtt$1,
  VTTCue: vttcue,
  VTTRegion: vttregion
};

window_1.vttjs = vttjs;
window_1.WebVTT = vttjs.WebVTT;

var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window_1.VTTCue;
var nativeVTTRegion = window_1.VTTRegion;

vttjs.shim = function() {
  window_1.VTTCue = cueShim;
  window_1.VTTRegion = regionShim;
};

vttjs.restore = function() {
  window_1.VTTCue = nativeVTTCue;
  window_1.VTTRegion = nativeVTTRegion;
};

if (!window_1.VTTCue) {
  vttjs.shim();
}
});

/**
 * @file tech.js
 */

function createTrackHelper(self, kind, label, language) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new ALL.text.TrackClass(options);

  tracks.addTrack(track);

  return track;
}

/**
 * This is the base class for media playback technology controllers, such as
 * {@link Flash} and {@link HTML5}
 *
 * @extends Component
 */

var Tech = function (_Component) {
  inherits(Tech, _Component);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Tech(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ready = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
    classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    _this.hasStarted_ = false;
    _this.on('playing', function () {
      this.hasStarted_ = true;
    });
    _this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    ALL.names.forEach(function (name) {
      var props = ALL[name];

      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }

    ['Text', 'Audio', 'Video'].forEach(function (track) {
      if (options['native' + track + 'Tracks'] === false) {
        _this['featuresNative' + track + 'Tracks'] = false;
      }
    });

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }

    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }

    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();

    _this.initTrackListeners();

    // Turn on component tap events only if not using native controls
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }

    if (_this.constructor) {
      _this.name_ = _this.constructor.name || 'Unknown Tech';
    }
    return _this;
  }

  /* Fallbacks for unsupported event types
  ================================================================================ */

  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */


  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */


  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {EventTarget~Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */


  Tech.prototype.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        /**
         * See {@link Player#progress}
         *
         * @event Tech#progress
         * @type {EventTarget~Event}
         */
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {EventTarget~Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */


  Tech.prototype.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Tech.prototype.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };

  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */


  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */


  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */


  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */


  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */


  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      /**
       * Triggered at an interval of 250ms to indicated that time is passing in the video.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });

      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }, 250);
  };

  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */


  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */


  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(NORMAL.names);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */


  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this2 = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this2[type + 'Tracks']() || [];
      var i = list.length;

      while (i--) {
        var track = list[i];

        if (type === 'text') {
          _this2.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };

  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */


  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;

    while (i--) {
      var track = list[i];

      this.removeRemoteTextTrack(track);
    }
  };

  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */


  Tech.prototype.reset = function reset() {};

  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */


  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new MediaError(err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks wether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */


  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };

  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @fires Tech#timeupdate
   */


  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      /**
       * A manual `timeupdate` event.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */


  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this3 = this;

    /**
     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
     *
     * @event Tech#audiotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
     *
     * @event Tech#videotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
     *
     * @event Tech#texttrackchange
     * @type {EventTarget~Event}
     */
    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges() {
        _this3.trigger(name + 'trackchange');
      };

      var tracks = _this3[props.getterName]();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this3.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */


  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {
    var _this4 = this;

    if (window_1.WebVTT) {
      return;
    }

    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
    // signals that the Tech is ready at which point Tech.el_ is part of the DOM
    // before inserting the WebVTT script
    if (document_1.body.contains(this.el())) {

      // load via require if available and vtt.js script location was not passed in
      // as an option. novtt builds will turn the above require call into an empty object
      // which will cause this if check to always fail.
      if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {
        this.trigger('vttjsloaded');
        return;
      }

      // load vtt.js via the script location option or the cdn of no location was
      // passed in
      var script = document_1.createElement('script');

      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';
      script.onload = function () {
        /**
         * Fired when vtt.js is loaded.
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjsloaded');
      };
      script.onerror = function () {
        /**
         * Fired when vtt.js was not loaded due to an error
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjserror');
      };
      this.on('dispose', function () {
        script.onload = null;
        script.onerror = null;
      });
      // but have not loaded yet and we set it to true before the inject so that
      // we don't overwrite the injected window.WebVTT if it loads right away
      window_1.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };

  /**
   * Emulate texttracks
   *
   */


  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this5 = this;

    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack(e) {
      return tracks.removeTrack(e.track);
    };

    remoteTracks.on('addtrack', handleAddTrack);
    remoteTracks.on('removetrack', handleRemoveTrack);

    this.addWebVttScript_();

    var updateDisplay = function updateDisplay() {
      return _this5.trigger('texttrackchange');
    };

    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);
    tracks.addEventListener('addtrack', textTracksChanges);
    tracks.addEventListener('removetrack', textTracksChanges);

    this.on('dispose', function () {
      remoteTracks.off('addtrack', handleAddTrack);
      remoteTracks.off('removetrack', handleRemoveTrack);
      tracks.removeEventListener('change', textTracksChanges);
      tracks.removeEventListener('addtrack', textTracksChanges);
      tracks.removeEventListener('removetrack', textTracksChanges);

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
      }
    });
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions(options, {
      tech: this
    });

    return new REMOTE.remoteTextEl.TrackClass(track);
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=true]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   * @deprecated The default functionality for this function will be equivalent
   *             to "manualCleanup=false" in the future. The manualCleanup parameter will
   *             also be removed.
   */


  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var _this6 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var htmlTrackElement = this.createRemoteTextTrack(options);

    if (manualCleanup !== true && manualCleanup !== false) {
      // deprecation warning
      log$2.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }

    return htmlTrackElement;
  };

  Tech.prototype.addAudioTrack = function addAudioTrack() {
    var _this7 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var track = mergeOptions(options, {
      tech: this
    });

    // const htmlTrackElement = new TRACK_TYPES.NORMAL.audio.ListClass(track);
    var htmlTrackElement = new NORMAL.audio.TrackClass(track);

    // store HTMLTrackElement and TextTrack to remote list
    this.audioTracks_.addTrack(htmlTrackElement);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this7.audioTracks_.addTrack(htmlTrackElement);
      });
    }

    return htmlTrackElement;
  };

  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */


  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */


  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };

  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */


  Tech.prototype.setPoster = function setPoster() {};

  /**
   * A method to check for the presence of the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.playsinline = function playsinline() {};

  /**
   * A method to set or unset the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.setPlaysinline = function setPlaysinline() {};

  /*
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */


  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */


  Tech.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the tech can support the given source
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */


  Tech.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */


  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */


  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    if (!Tech.canPlayType) {
      throw new Error('Techs must have a static canPlayType method on them');
    }
    if (!Tech.canPlaySource) {
      throw new Error('Techs must have a static canPlaySource method on them');
    }

    name = toTitleCase(name);

    Tech.techs_[name] = tech;
    if (name !== 'Tech') {
      // camel case the techName for use in techOrder
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  };

  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requsted.
   */


  Tech.getTech = function getTech(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (window_1 && window_1.videojs && window_1.videojs[name]) {
      log$2.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return window_1.videojs[name];
    }
  };

  return Tech;
}(Component);

/**
 * Get the {@link VideoTrackList}
 *
 * @returns {VideoTrackList}
 * @method Tech.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 *
 * @returns {AudioTrackList}
 * @method Tech.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.textTracks
 */

/**
 * Get the remote element {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.remoteTextTracks
 */

/**
 * Get the remote element {@link HtmlTrackElementList}
 *
 * @returns {HtmlTrackElementList}
 * @method Tech.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name) {
  var props = ALL[name];

  Tech.prototype[props.getterName] = function () {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * List of associated text tracks
 *
 * @type {TextTrackList}
 * @private
 * @property Tech#textTracks_
 */

/**
 * List of associated audio tracks.
 *
 * @type {AudioTrackList}
 * @private
 * @property Tech#audioTracks_
 */

/**
 * List of associated video tracks.
 *
 * @type {VideoTrackList}
 * @private
 * @property Tech#videoTracks_
 */

/**
 * Boolean indicating wether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresVolumeControl = true;

/**
 * Boolean indicating wether the `Tech` supports mute control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresMuteControl = true;

/**
 * Boolean indicating wether the `Tech` support fullscreen resize control.
 * Resizing plugins using request fullscreen reloads the plugin
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresFullscreenResize = false;

/**
 * Boolean indicating wether the `Tech` supports changing the speed at which the video
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresPlaybackRate = false;

/**
 * Boolean indicating wether the `Tech` supports the `progress` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualProgressOn} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresProgressEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualTimeUpdates} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresTimeupdateEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the native `TextTrack`s.
 * This will help us integrate with native `TextTrack`s if the browser supports them.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 * Source handlers are scripts for handling specific formats.
 * The source handler pattern is used for adaptive formats (HLS, DASH) that
 * manually load video data and feed it into a Source Buffer (Media Source Extensions)
 * Example: `Tech.withSourceHandlers.call(MyTech);`
 *
 * @param {Tech} _Tech
 *        The tech to add source handler functions to.
 *
 * @mixes Tech~SourceHandlerAdditions
 */
Tech.withSourceHandlers = function (_Tech) {

  /**
   * Register a source handler
   *
   * @param {Function} handler
   *        The source handler class
   *
   * @param {number} [index]
   *        Register it at the following index
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Check if the tech can support the given type. Also checks the
   * Techs sourceHandlers.
   *
   * @param {string} type
   *         The mimetype to check.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /**
   * Returns the first source handler that supports the source.
   *
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {SourceHandler|null}
   *          The first source handler that supports the source or null if
   *          no SourceHandler supports the source
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
   * Check if the tech can support the given source.
   *
   * @param {Tech~SourceObject} srcObj
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /**
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'duration'];

  /**
   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
   * function if it exists, with a fallback to the Techs seekable function.
   *
   * @method _Tech.seekable
   */

  /**
   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
   * function if it exists, otherwise it will fallback to the techs duration function.
   *
   * @method _Tech.duration
   */

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   *
   * @param {Tech~SourceObject} source
   *        A source object with src and type keys
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$2.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);
  };

  /**
   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
   *
   * @listens Tech#dispose
   */
  _Tech.prototype.disposeSourceHandler = function () {
    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);
      this.currentSource_ = null;
    }

    // always clean up auto-text tracks
    this.cleanupAutoTextTracks();

    if (this.sourceHandler_) {

      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }

      this.sourceHandler_ = null;
    }
  };
};

// The base Tech class needs to be registered as a Component. It is the only
// Tech that can be registered as a Component.
Component.registerComponent('Tech', Tech);
Tech.registerTech('Tech', Tech);

/**
 * A list of techs that should be added to techOrder on Players
 *
 * @private
 */
Tech.defaultTechOrder_ = [];

var middlewares = {};

function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}



function setSource(player, src, next) {
  console.log('setSource', src);
  // 可以在这里异步加载tech，player ready回调是在loadtech 触发的，所以异步加载tech后ready也会异步化
  // resourceLoader('//unpkg.com/videojs-contrib-hls.js@3.0.3/dist/videojs-contrib-hlsjs.min.js', {
  //   success: function () {
  //     console.log('load hls done');
  player.setTimeout(function () {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
  //   }
  // });
}

function setTech(middleware, tech) {
  middleware.forEach(function (mw) {
    return mw.setTech && mw.setTech(tech);
  });
}

function get$1(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}

function set$1(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}

var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  seekable: 1,
  played: 1
};

var allowedSetters = {
  setCurrentTime: 1
};

function middlewareIterator(method) {
  return function (value, mw) {
    if (mw[method]) {
      return mw[method](value);
    }

    return value;
  };
}

function setSourceHelper() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var next = arguments[2];
  var player = arguments[3];
  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var mwFactory = middleware[0],
      mwrest = middleware.slice(1);
  // if mwFactory is a string, then we're at a fork in the road

  if (typeof mwFactory === 'string') {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

    // if we have an mwFactory, call it with the player to get the mw,
    // then call the mw's setSource method
  } else if (mwFactory) {
    var mw = mwFactory(player);

    mw.setSource(assign({}, src), function (err, _src) {

      // something happened, try the next middleware on the current level
      // make sure to use the old src
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }

      // we've succeeded, now we need to go deeper
      acc.push(mw);

      // if it's the same time, continue does the current chain
      // otherwise, we want to go down the new chain
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares['*'], next, player, acc, true);
  }
}

var MimetypesKind = {
  opus: 'video/ogg',
  ogv: 'video/ogg',
  mp4: 'video/mp4',
  mov: 'video/mp4',
  m4v: 'video/mp4',
  mkv: 'video/x-matroska',
  m4a: 'audio/mp4',
  mp3: 'audio/mpeg',
  aac: 'audio/aac',
  caf: 'audio/x-caf',
  flac: 'audio/flac',
  oga: 'audio/ogg',
  wav: 'audio/wav',
  m3u8: 'application/x-mpegURL',
  jpg: 'image/jpeg',
  jpeg: 'image/jpeg',
  gif: 'image/gif',
  png: 'image/png',
  svg: 'image/svg+xml',
  webp: 'image/webp'
};

/**
 * Get the mimetype of a given src url if possible
 *
 * @param {string} src
 *        The url to the src
 *
 * @return {string}
 *         return the mimetype if it was known or empty string otherwise
 */
var getMimetype = function getMimetype() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var ext = getFileExtension(src);
  var mimetype = MimetypesKind[ext.toLowerCase()];

  return mimetype || '';
};

/**
 * Find the mime type of a given source string if possible. Uses the player
 * source cache.
 *
 * @param {Player} player
 *        The player object
 *
 * @param {string} src
 *        The source string
 *
 * @return {string}
 *         The type that was found
 */

/**
 * @module filter-source
 */
var filterSource = function filterSource(src) {
  // traverse array
  if (Array.isArray(src)) {
    var newsrc = [];

    src.forEach(function (srcobj) {
      srcobj = filterSource(srcobj);

      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject$1(srcobj)) {
        newsrc.push(srcobj);
      }
    });

    src = newsrc;
  } else if (typeof src === 'string' && src.trim()) {
    // convert string into object
    src = [fixSource({ src: src })];
  } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
    // src is already valid
    src = [fixSource(src)];
  } else {
    // invalid source, turn it into an empty array
    src = [];
  }
  return src;
};

var fixSource = function fixSource(src) {
  if (!src.type) {
    var mimetype = getMimetype(src.src);

    if (mimetype) {
      src.type = mimetype;
    }
  }

  return src;
};

/**
 * @file loader.js
 */
var MediaLoader = function (_Component) {
  inherits(MediaLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaLoader(player, options, ready) {
    classCallCheck(this, MediaLoader);

    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase(j[i]);
        var tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = Component.getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // Loop through playback technologies (HTML5, Flash) and check for support.
      // Then load the best source.
      // A few assumptions here:
      //   All playback technologies respect preload false.
      player.src(options.playerOptions.sources);
    }
    return _this;
  }

  return MediaLoader;
}(Component);

Component.registerComponent('MediaLoader', MediaLoader);

/**
 * @file button.js
 */
var ClickableComponent = function (_Component) {
  inherits(ClickableComponent, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ClickableComponent(player, options) {
    classCallCheck(this, ClickableComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.emitTapEvents();

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  ClickableComponent.prototype.createEl = function createEl$$1() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      log$2.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = assign({
      'role': 'button',

      // let the screen reader user know that the text of the element may change
      'aria-live': 'polite'
    }, attributes);

    this.tabIndex_ = props.tabIndex;

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  ClickableComponent.prototype.dispose = function dispose() {
    // remove controlTextEl_ on dipose
    this.controlTextEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create a control text element on this `Component`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */


  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl('span', {
      className: 'vjs-control-text'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Get or set the localize text to use for the controls on the `Component`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();

    if (text === undefined) {
      return this.controlText_ || 'Need Text';
    }

    var localizedText = this.localize(text);

    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl) {
      // Set title attribute if only an icon is shown
      el.setAttribute('title', localizedText);
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Enable this `Component`s element.
   */


  ClickableComponent.prototype.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'false');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.setAttribute('tabIndex', this.tabIndex_);
      }
      this.on(['tap', 'click'], this.handleClick);
      this.on('focus', this.handleFocus);
      this.on('blur', this.handleBlur);
    }
  };

  /**
   * Disable this `Component`s element.
   */


  ClickableComponent.prototype.disable = function disable() {
    this.enabled_ = false;
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    if (typeof this.tabIndex_ !== 'undefined') {
      this.el_.removeAttribute('tabIndex');
    }
    this.off(['tap', 'click'], this.handleClick);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
  };

  /**
   * This gets called when a `ClickableComponent` gets:
   * - Clicked (via the `click` event, listening starts in the constructor)
   * - Tapped (via the `tap` event, listening starts in the constructor)
   * - The following things happen in order:
   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the
   *      `ClickableComponent`.
   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using
   *      {@link ClickableComponent#handleKeyPress}.
   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses
   *      the space or enter key.
   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`
   *      event as a parameter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */


  ClickableComponent.prototype.handleClick = function handleClick(event) {};

  /**
   * This gets called when a `ClickableComponent` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  ClickableComponent.prototype.handleFocus = function handleFocus(event) {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when this ClickableComponent has focus and a key gets pressed down. By
   * default it will call `this.handleClick` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.trigger('click');
    } else if (_Component.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Component.prototype.handleKeyPress.call(this, event);
    }
  };

  /**
   * Called when a `ClickableComponent` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  ClickableComponent.prototype.handleBlur = function handleBlur(event) {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
}(Component);

Component.registerComponent('ClickableComponent', ClickableComponent);

/**
 * @file poster-image.js
 */
var PosterImage = function (_ClickableComponent) {
  inherits(PosterImage, _ClickableComponent);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PosterImage(player, options) {
    classCallCheck(this, PosterImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.update();
    player.on('posterchange', bind(_this, _this.update));
    return _this;
  }

  /**
   * Clean up and dispose of the `PosterImage`.
   */


  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  PosterImage.prototype.createEl = function createEl$$1() {
    var el = createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = createEl('img');
      var pH = this.player().height() || parseInt(this.player().el().style.height),
          pW = this.player().width() || parseInt(this.player().el().style.width);
      this.fallbackImg_.onload = function () {
        var imgW = this.width,
            imgH = this.height;
        if (imgH > pH) {
          this.style.maxHeight = pH + 'px';
          this.style.width = 'auto';
        }
      };
      var table = createEl('div');
      var cell = createEl('span');
      cell.appendChild(this.fallbackImg_);
      table.appendChild(cell);
      el.appendChild(table);
      // el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {EventTarget~Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */


  PosterImage.prototype.update = function update(event) {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the source of the `PosterImage` depending on the display method.
   *
   * @param {string} url
   *        The URL to the source for the `PosterImage`.
   */


  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';

      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {EventTarget~Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */


  PosterImage.prototype.handleClick = function handleClick(event) {
    // We don't want a click to trigger playback when controls are disabled
    if (!this.player_.controls()) {
      return;
    }

    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
}(ClickableComponent);

Component.registerComponent('PosterImage', PosterImage);

/**
 * @file text-track-display.js
 */
var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * Construct an rgba color from a given hex color code.
 *
 * @param {number} color
 *        Hex number for color, like #f0e.
 *
 * @param {number} opacity
 *        Value for opacity, 0.0 - 1.0.
 *
 * @return {string}
 *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
 *
 * @private
 */
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update the style of a DOM element. Some style changes will throw an error,
 * particularly in IE8. Those should be noops.
 *
 * @param {Element} el
 *        The DOM element to be styled.
 *
 * @param {string} style
 *        The CSS property on the element that should be styled.
 *
 * @param {string} rule
 *        The style rule that should be applied to the property.
 *
 * @private
 */
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {

    // Satisfies linter.
    return;
  }
}

/**
 * The component for displaying text track cues.
 *
 * @extends Component
 */

var TextTrackDisplay = function (_Component) {
  inherits(TextTrackDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  function TextTrackDisplay(player, options, ready) {
    classCallCheck(this, TextTrackDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    player.on('loadstart', bind(_this, _this.toggleDisplay));
    player.on('texttrackchange', bind(_this, _this.updateDisplay));
    player.on('loadstart', bind(_this, _this.preselectTrack));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(bind(_this, function () {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions.tracks || [];

      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }

      this.preselectTrack();
    }));
    return _this;
  }

  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */


  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {
    var modes = { captions: 1, subtitles: 1 };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc = void 0;
    var firstCaptions = void 0;
    var preferredTrack = void 0;

    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];

      if (userPref && userPref.enabled && userPref.language === track.language) {
        // Always choose the track that matches both language and kind
        if (track.kind === userPref.kind) {
          preferredTrack = track;
          // or choose the first track that matches language
        } else if (!preferredTrack) {
          preferredTrack = track;
        }

        // clear everything if offTextTrackMenuItem was clicked
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track['default']) {
        if (track.kind === 'descriptions' && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }

    // The preferredTrack matches the user preference and takes
    // precendence over all the other tracks.
    // So, display the preferredTrack before the first default track
    // and the subtitles/captions track before the descriptions track
    if (preferredTrack) {
      preferredTrack.mode = 'showing';
    } else if (firstCaptions) {
      firstCaptions.mode = 'showing';
    } else if (firstDesc) {
      firstDesc.mode = 'showing';
    }
  };

  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */


  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */


  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'off',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear all displayed {@link TextTrack}s.
   */


  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof window_1.WebVTT === 'function') {
      window_1.WebVTT.processCues(window_1, [], this.el_);
    }
  };

  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */


  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;

    while (i--) {
      var track = tracks[i];

      if (track.mode === 'showing') {
        if (track.kind === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      if (this.getAttribute('aria-live') !== 'off') {
        this.setAttribute('aria-live', 'off');
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute('aria-live') !== 'assertive') {
        this.setAttribute('aria-live', 'assertive');
      }
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack} track
   *        Text track object to be added to the list.
   */


  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof window_1.WebVTT !== 'function' || !track.activeCues) {
      return;
    }

    var overrides = this.player_.textTrackSettings.getValues();
    var cues = [];

    for (var _i = 0; _i < track.activeCues.length; _i++) {
      cues.push(track.activeCues[_i]);
    }

    window_1.WebVTT.processCues(window_1, cues, this.el_);

    var i = cues.length;

    while (i--) {
      var cue = cues[i];

      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;

      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = window_1.parseFloat(cueDiv.style.fontSize);

        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
}(Component);

Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

/**
 * @file loading-spinner.js
 */
var LoadingSpinner = function (_Component) {
  inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    classCallCheck(this, LoadingSpinner);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  LoadingSpinner.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });
  };

  return LoadingSpinner;
}(Component);

Component.registerComponent('LoadingSpinner', LoadingSpinner);

/**
 * @file button.js
 */
var Button = function (_ClickableComponent) {
  inherits(Button, _ClickableComponent);

  function Button() {
    classCallCheck(this, Button);
    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  Button.prototype.createEl = function createEl(tag) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    tag = 'button';

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass()
    }, props);

    // Add attributes for button element
    attributes = assign({

      // Necessary since the default button type is "submit"
      'type': 'button',

      // let the screen reader user know that the text of the button may change
      'aria-live': 'polite'
    }, attributes);

    var el = Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */


  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var className = this.constructor.name;

    log$2.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */


  Button.prototype.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute('disabled');
  };

  /**
   * Enable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */


  Button.prototype.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute('disabled', 'disabled');
  };

  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */


  Button.prototype.handleKeyPress = function handleKeyPress(event) {

    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {
      return;
    }

    // Pass keypress handling up for unsupported keys
    _ClickableComponent.prototype.handleKeyPress.call(this, event);
  };

  return Button;
}(ClickableComponent);

Component.registerComponent('Button', Button);

/**
 * @file big-play-button.js
 */
var BigPlayButton = function (_Button) {
  inherits(BigPlayButton, _Button);

  function BigPlayButton(player, options) {
    classCallCheck(this, BigPlayButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.mouseused_ = false;

    _this.on('mousedown', _this.handleMouseDown);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */


  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  BigPlayButton.prototype.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();

    // exit early if clicked via the mouse
    if (this.mouseused_ && event.clientX && event.clientY) {
      return;
    }

    var cb = this.player_.getChild('controlBar');
    var playToggle = cb && cb.getChild('playToggle');

    if (!playToggle) {
      this.player_.focus();
      return;
    }

    var playFocus = function playFocus() {
      return playToggle.focus();
    };

    if (isPromise(playPromise)) {
      playPromise.then(playFocus, function () {});
    } else {
      this.setTimeout(playFocus, 1);
    }
  };

  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {
    this.mouseused_ = false;

    _Button.prototype.handleKeyPress.call(this, event);
  };

  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };

  return BigPlayButton;
}(Button);

/**
 * The text that should display over the `BigPlayButton`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


BigPlayButton.prototype.controlText_ = 'Play Video';

Component.registerComponent('BigPlayButton', BigPlayButton);

/**
 * @file close-button.js
 */
var CloseButton = function (_Button) {
  inherits(CloseButton, _Button);

  /**
   * Creates an instance of the this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function CloseButton(player, options) {
    classCallCheck(this, CloseButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.controlText(options && options.controlText || _this.localize('Close'));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when this will be
   * triggered
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */


  CloseButton.prototype.handleClick = function handleClick(event) {

    /**
     * Triggered when the a `CloseButton` is clicked.
     *
     * @event CloseButton#close
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up to parents if there is no listener
     */
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
}(Button);

Component.registerComponent('CloseButton', CloseButton);

/**
 * @file play-toggle.js
 */
var PlayToggle = function (_Button) {
  inherits(PlayToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlayToggle(player, options) {
    classCallCheck(this, PlayToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'play', _this.handlePlay);
    _this.on(player, 'pause', _this.handlePause);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlayToggle.prototype.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * This gets called once after the video has ended and the user seeks so that
   * we can change the replay button back to a play button.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#seeked
   */


  PlayToggle.prototype.handleSeeked = function handleSeeked(event) {
    this.removeClass('vjs-ended');

    if (this.player_.paused()) {
      this.handlePause(event);
    } else {
      this.handlePlay(event);
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */


  PlayToggle.prototype.handlePlay = function handlePlay(event) {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    // change the button text to "Pause"
    this.controlText('Pause');
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */


  PlayToggle.prototype.handlePause = function handlePause(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    // change the button text to "Play"
    this.controlText('Play');
  };

  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ended
   */


  PlayToggle.prototype.handleEnded = function handleEnded(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-ended');
    // change the button text to "Replay"
    this.controlText('Replay');

    // on the next seek remove the replay button
    this.one(this.player_, 'seeked', this.handleSeeked);
  };

  return PlayToggle;
}(Button);

/**
 * The text that should display over the `PlayToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlayToggle.prototype.controlText_ = 'Play';

Component.registerComponent('PlayToggle', PlayToggle);

/**
 * @file format-time.js
 * @module Format-time
 */

/**
 * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)
 * will force a number of leading zeros to cover the length of the guide.
 *
 * @param {number} seconds
 *        Number of seconds to be turned into a string
 *
 * @param {number} guide
 *        Number (in seconds) to model the string after
 *
 * @return {string}
 *         Time formatted as H:MM:SS or M:SS
 */
function formatTime(seconds) {
  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;

  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = h > 0 || gh > 0 ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = s < 10 ? '0' + s : s;

  return h + m + s;
}

/**
 * @file time-display.js
 */
var TimeDisplay = function (_Component) {
  inherits(TimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TimeDisplay(player, options) {
    classCallCheck(this, TimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, 'timeupdate', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  TimeDisplay.prototype.createEl = function createEl$$1(plainName) {
    var className = this.buildCSSClass();
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: className + ' vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: className + '-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize(this.controlText_)
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  TimeDisplay.prototype.dispose = function dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Updates the "remaining time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  TimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (!this.contentEl_) {
      return;
    }

    while (this.contentEl_.firstChild) {
      this.contentEl_.removeChild(this.contentEl_.firstChild);
    }

    this.textNode_ = document_1.createTextNode(this.formattedTime_ || '0:00');
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Generates a formatted time for this component to use in display.
   *
   * @param  {number} time
   *         A numeric time, in seconds.
   *
   * @return {string}
   *         A formatted time
   *
   * @private
   */


  TimeDisplay.prototype.formatTime_ = function formatTime_(time) {
    return formatTime(time);
  };

  /**
   * Updates the time display text node if it has what was passed in changed
   * the formatted time.
   *
   * @param {number} time
   *        The time to update to
   *
   * @private
   */


  TimeDisplay.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {
    var formattedTime = this.formatTime_(time);

    if (formattedTime === this.formattedTime_) {
      return;
    }

    this.formattedTime_ = formattedTime;
    this.requestAnimationFrame(this.updateTextNode_);
  };

  /**
   * To be filled out in the child class, should update the displayed time
   * in accordance with the fact that the current time has changed.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate`  event that caused this to run.
   *
   * @listens Player#timeupdate
   */


  TimeDisplay.prototype.updateContent = function updateContent(event) {};

  return TimeDisplay;
}(Component);

/**
 * The text that should display over the `TimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


TimeDisplay.prototype.controlText_ = 'Time';

Component.registerComponent('TimeDisplay', TimeDisplay);

/**
 * @file current-time-display.js
 */
var CurrentTimeDisplay = function (_TimeDisplay) {
  inherits(CurrentTimeDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CurrentTimeDisplay(player, options) {
    classCallCheck(this, CurrentTimeDisplay);

    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CurrentTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-current-time';
  };

  /**
   * Update current time display
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */


  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    this.updateFormattedTime_(time);
  };

  /**
   * When the player fires ended there should be no time left. Sadly
   * this is not always the case, lets make it seem like that is the case
   * for users.
   *
   * @param {EventTarget~Event} [event]
   *        The `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  CurrentTimeDisplay.prototype.handleEnded = function handleEnded(event) {
    if (!this.player_.duration()) {
      return;
    }
    this.updateFormattedTime_(this.player_.duration());
  };

  return CurrentTimeDisplay;
}(TimeDisplay);

/**
 * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


CurrentTimeDisplay.prototype.controlText_ = 'Current Time';

Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

/**
 * @file duration-display.js
 */
var DurationDisplay = function (_TimeDisplay) {
  inherits(DurationDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function DurationDisplay(player, options) {
    classCallCheck(this, DurationDisplay);

    // we do not want to/need to throttle duration changes,
    // as they should always display the changed duration as
    // it has changed
    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'durationchange', _this.updateContent);

    // Also listen for timeupdate (in the parent) and loadedmetadata because removing those
    // listeners could have broken dependent applications/libraries. These
    // can likely be removed for 7.0.
    _this.on(player, 'loadedmetadata', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DurationDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-duration';
  };

  /**
   * Update duration time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */


  DurationDisplay.prototype.updateContent = function updateContent(event) {
    var duration = this.player_.duration();

    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      this.updateFormattedTime_(duration);
    }
  };

  return DurationDisplay;
}(TimeDisplay);

/**
 * The text that should display over the `DurationDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


DurationDisplay.prototype.controlText_ = 'Duration Time';

Component.registerComponent('DurationDisplay', DurationDisplay);

/**
 * @file time-divider.js
 */
var TimeDivider = function (_Component) {
  inherits(TimeDivider, _Component);

  function TimeDivider() {
    classCallCheck(this, TimeDivider);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
}(Component);

Component.registerComponent('TimeDivider', TimeDivider);

/**
 * @file remaining-time-display.js
 */
var RemainingTimeDisplay = function (_TimeDisplay) {
  inherits(RemainingTimeDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function RemainingTimeDisplay(player, options) {
    classCallCheck(this, RemainingTimeDisplay);

    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'durationchange', _this.throttledUpdateContent);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  RemainingTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-remaining-time';
  };

  /**
   * The remaining time display prefixes numbers with a "minus" character.
   *
   * @param  {number} time
   *         A numeric time, in seconds.
   *
   * @return {string}
   *         A formatted time
   *
   * @private
   */


  RemainingTimeDisplay.prototype.formatTime_ = function formatTime_(time) {
    return '-' + _TimeDisplay.prototype.formatTime_.call(this, time);
  };

  /**
   * Update remaining time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */


  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {
    if (!this.player_.duration()) {
      return;
    }

    // @deprecated We should only use remainingTimeDisplay
    // as of video.js 7
    if (this.player_.remainingTimeDisplay) {
      this.updateFormattedTime_(this.player_.remainingTimeDisplay());
    } else {
      this.updateFormattedTime_(this.player_.remainingTime());
    }
  };

  /**
   * When the player fires ended there should be no time left. Sadly
   * this is not always the case, lets make it seem like that is the case
   * for users.
   *
   * @param {EventTarget~Event} [event]
   *        The `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  RemainingTimeDisplay.prototype.handleEnded = function handleEnded(event) {
    if (!this.player_.duration()) {
      return;
    }
    this.updateFormattedTime_(0);
  };

  return RemainingTimeDisplay;
}(TimeDisplay);

/**
 * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';

Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

/**
 * @file live-display.js
 */
var LiveDisplay = function (_Component) {
  inherits(LiveDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LiveDisplay(player, options) {
    classCallCheck(this, LiveDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.isLoadedMetaData = false;
    _this.hide();
    _this.on(_this.player(), 'durationchange', _this.onDurationChange);
    _this.on(_this.player(), 'loadedmetadata', _this.onLoadMetadata);
    player.on('loadnewvideo', videojs.bind(_this, _this.resetStatus));
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LiveDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  LiveDisplay.prototype.dispose = function dispose() {
    this.contentEl_ = null;
    _Component.prototype.dispose.call(this);
  };

  LiveDisplay.prototype.resetStatus = function resetStatus() {
    this.setStatus(false);
  };

  LiveDisplay.prototype.onDurationChange = function onDurationChange() {
    if (this.isLoadedMetaData) {
      this.update();
    }
  };

  LiveDisplay.prototype.onLoadMetadata = function onLoadMetadata() {
    this.setStatus(true);
    this.update();
  };

  LiveDisplay.prototype.setStatus = function setStatus(status) {
    this.isLoadedMetaData = status;
  };

  LiveDisplay.prototype.update = function update() {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
}(Component);

Component.registerComponent('LiveDisplay', LiveDisplay);

/**
 * @file slider.js
 */
var Slider = function (_Component) {
  inherits(Slider, _Component);

  /**
   * Create an instance of this class
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function Slider(player, options) {
    classCallCheck(this, Slider);

    // Set property names to bar to match with the child Slider class is looking for
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.bar = _this.getChild(_this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    _this.vertical(!!_this.options_.vertical);

    _this.enable();
    return _this;
  }

  /**
   * Are controls are currently enabled for this slider or not.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */


  Slider.prototype.enabled = function enabled() {
    return this.enabled_;
  };

  /**
   * Enable controls for this slider if they are disabled
   */


  Slider.prototype.enable = function enable() {
    if (this.enabled()) {
      return;
    }

    this.on('mousedown', this.handleMouseDown);
    this.on('touchstart', this.handleMouseDown);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
    this.on('click', this.handleClick);

    this.on(this.player_, 'controlsvisible', this.update);

    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }

    this.removeClass('disabled');
    this.setAttribute('tabindex', 0);

    this.enabled_ = true;
  };

  /**
   * Disable controls for this slider if they are enabled
   */


  Slider.prototype.disable = function disable() {
    if (!this.enabled()) {
      return;
    }
    var doc = this.bar.el_.ownerDocument;

    this.off('mousedown', this.handleMouseDown);
    this.off('touchstart', this.handleMouseDown);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
    this.off('click', this.handleClick);
    this.off(this.player_, 'controlsvisible', this.update);
    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);
    this.removeAttribute('tabindex');

    this.addClass('disabled');

    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  };

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Slider.prototype.createEl = function createEl$$1(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = assign({
      tabIndex: 0
    }, props);

    attributes = assign({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      'tabIndex': 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */


  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    event.preventDefault();
    blockTextSelection();

    this.addClass('vjs-sliding');
    /**
     * Triggered when the slider is in an active state
     *
     * @event Slider#slideractive
     * @type {EventTarget~Event}
     */
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event);
  };

  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {EventTarget~Event} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};

  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */


  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    unblockTextSelection();

    this.removeClass('vjs-sliding');
    /**
     * Triggered when the slider is no longer in an active state.
     *
     * @event Slider#sliderinactive
     * @type {EventTarget~Event}
     */
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update the progress bar of the `Slider`.
   *
   * @returns {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */


  Slider.prototype.update = function update() {

    // In VolumeBar init we have a setTimeout for update that pops and update
    // to the end of the execution stack. The player is destroyed before then
    // update will cause an error
    if (!this.el_) {
      return;
    }

    // If scrubbing, we could use a cached value to make the handle keep up
    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but
    // some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) {
      return;
    }

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';
    var style = bar.el().style;

    // Set the new bar width or height
    if (this.vertical()) {
      style.height = percentage;
    } else {
      style.width = percentage;
    }

    return progress;
  };

  /**
   * Calculate distance for slider
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - postition.x for vertical `Slider`s
   *         - postition.y for horizontal `Slider`s
   */


  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);

    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle a `focus` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to run.
   *
   * @listens focus
   */


  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {EventTarget~Event} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */


  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepBack();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle a `blur` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to run.
   *
   * @listens blur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */


  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */


  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }
  };

  return Slider;
}(Component);

Component.registerComponent('Slider', Slider);

/**
 * @file load-progress-bar.js
 */
var LoadProgressBar = function (_Component) {
  inherits(LoadProgressBar, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LoadProgressBar(player, options) {
    classCallCheck(this, LoadProgressBar);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.partEls_ = [];
    _this.on(player, 'progress', _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LoadProgressBar.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  LoadProgressBar.prototype.dispose = function dispose() {
    this.partEls_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Update progress bar
   *
   * @param {EventTarget~Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */


  LoadProgressBar.prototype.update = function update(event) {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.partEls_;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      // no NaN
      var percent = time / end || 0;

      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(createEl());
        children[i] = part;
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var _i = children.length; _i > buffered.length; _i--) {
      this.el_.removeChild(children[_i - 1]);
    }
    children.length = buffered.length;
  };

  return LoadProgressBar;
}(Component);

Component.registerComponent('LoadProgressBar', LoadProgressBar);

/**
 * @file time-tooltip.js
 */
var TimeTooltip = function (_Component) {
  inherits(TimeTooltip, _Component);

  function TimeTooltip() {
    classCallCheck(this, TimeTooltip);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeTooltip.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-tooltip'
    });
  };

  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = getBoundingClientRect(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;

    // do nothing if either rect isn't available
    // for example, if the player isn't in the DOM for testing
    if (!playerRect || !tooltipRect) {
      return;
    }

    // This is the space left of the `seekBarPoint` available within the bounds
    // of the player. We calculate any gap between the left edge of the player
    // and the left edge of the `SeekBar` and add the number of pixels in the
    // `SeekBar` before hitting the `seekBarPoint`
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

    // This is the space right of the `seekBarPoint` available within the bounds
    // of the player. We calculate the number of pixels from the `seekBarPoint`
    // to the right edge of the `SeekBar` and add to that any gap between the
    // right edge of the `SeekBar` and the player.
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

    // This is the number of pixels by which the tooltip will need to be pulled
    // further to the right to center it over the `seekBarPoint`.
    var pullTooltipBy = tooltipRect.width / 2;

    // Adjust the `pullTooltipBy` distance to the left or right depending on
    // the results of the space calculations above.
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }

    // Due to the imprecision of decimal/ratio based calculations and varying
    // rounding behaviors, there are cases where the spacing adjustment is off
    // by a pixel or two. This adds insurance to these calculations.
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }

    this.el_.style.right = '-' + pullTooltipBy + 'px';
    textContent(this.el_, content);
  };

  return TimeTooltip;
}(Component);

Component.registerComponent('TimeTooltip', TimeTooltip);

/**
 * @file play-progress-bar.js
 */
var PlayProgressBar = function (_Component) {
  inherits(PlayProgressBar, _Component);

  function PlayProgressBar() {
    classCallCheck(this, PlayProgressBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();

      var content = formatTime(time, _this2.player_.duration());
      var timeTooltip = _this2.getChild('timeTooltip');

      if (timeTooltip) {
        timeTooltip.update(seekBarRect, seekBarPoint, content);
      }
    });
  };

  return PlayProgressBar;
}(Component);

/**
 * Default options for {@link PlayProgressBar}.
 *
 * @type {Object}
 * @private
 */


PlayProgressBar.prototype.options_ = {
  children: []
};

// Time tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push('timeTooltip');
}

Component.registerComponent('PlayProgressBar', PlayProgressBar);

/**
 * @file mouse-time-display.js
 */
var MouseTimeDisplay = function (_Component) {
  inherits(MouseTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MouseTimeDisplay(player, options) {
    classCallCheck(this, MouseTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 25);
    return _this;
  }

  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */


  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var duration = _this2.player_.duration();
      var content = formatTime(seekBarPoint * duration, duration);

      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return MouseTimeDisplay;
}(Component);

/**
 * Default options for `MouseTimeDisplay`
 *
 * @type {Object}
 * @private
 */


MouseTimeDisplay.prototype.options_ = {
  children: ['timeTooltip']
};

Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

/**
 * @file seek-bar.js
 */
var STEP_SECONDS = 5;

// The interval at which the bar should update as it progresses.
var UPDATE_REFRESH_INTERVAL = 30;

/**
 * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
 * as its `bar`.
 *
 * @extends Slider
 */

var SeekBar = function (_Slider) {
  inherits(SeekBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function SeekBar(player, options) {
    classCallCheck(this, SeekBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), UPDATE_REFRESH_INTERVAL);

    _this.on(player, 'timeupdate', _this.update);
    _this.on(player, 'ended', _this.handleEnded);

    // when playing, let's ensure we smoothly update the play progress bar
    // via an interval
    _this.updateInterval = null;

    _this.on(player, ['playing'], function () {
      _this.clearInterval(_this.updateInterval);

      _this.updateInterval = _this.setInterval(function () {
        _this.requestAnimationFrame(function () {
          _this.update();
        });
      }, UPDATE_REFRESH_INTERVAL);
    });

    _this.on(player, ['ended', 'pause', 'waiting'], function () {
      _this.clearInterval(_this.updateInterval);
    });

    _this.on(player, ['timeupdate', 'ended'], _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  SeekBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };

  /**
   * This function updates the play progress bar and accessiblity
   * attributes to whatever is passed in.
   *
   * @param {number} currentTime
   *        The currentTime value that should be used for accessiblity
   *
   * @param {number} percent
   *        The percentage as a decimal that the bar should be filled from 0-1.
   *
   * @private
   */


  SeekBar.prototype.update_ = function update_(currentTime, percent) {
    var duration = this.player_.duration();

    // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));

    // human readable value of progress bar (time complete)
    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));

    // Update the `PlayProgressBar`.
    this.bar.update(getBoundingClientRect(this.el_), percent);
  };

  /**
   * Update the seek bar's UI.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   *
   * @returns {number}
   *          The current percent at a number from 0-1
   */


  SeekBar.prototype.update = function update(event) {
    var percent = _Slider.prototype.update.call(this);

    this.update_(this.getCurrentTime_(), percent);
    return percent;
  };

  /**
   * Get the value of current time but allows for smooth scrubbing,
   * when player can't keep up.
   *
   * @return {number}
   *         The current time value to display
   *
   * @private
   */


  SeekBar.prototype.getCurrentTime_ = function getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  };

  /**
   * We want the seek bar to be full on ended
   * no matter what the actual internal values are. so we force it.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  SeekBar.prototype.handleEnded = function handleEnded(event) {
    this.update_(this.player_.duration(), 1);
  };

  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */


  SeekBar.prototype.getPercent = function getPercent() {
    var percent = this.getCurrentTime_() / this.player_.duration();

    return percent >= 1 ? 1 : percent;
  };

  /**
   * Handle mouse down on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    this.player_.trigger('beforeseek');

    // console.log('before seeking', this.player_.currentTime());

    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    var newTime = this.calculateDistance(event) * this.player_.duration();

    // Don't let video end while scrubbing.
    if (newTime === this.player_.duration()) {
      newTime = newTime - 0.1;
    }

    // Set new time (tell player to seek to new time)
    this.player_.currentTime(newTime);
  };

  SeekBar.prototype.enable = function enable() {
    _Slider.prototype.enable.call(this);
    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');

    if (!mouseTimeDisplay) {
      return;
    }

    mouseTimeDisplay.show();
  };

  SeekBar.prototype.disable = function disable() {
    _Slider.prototype.disable.call(this);
    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');

    if (!mouseTimeDisplay) {
      return;
    }

    mouseTimeDisplay.hide();
  };

  /**
   * Handle mouse up on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */


  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    this.player_.scrubbing(false);

    /**
     * Trigger timeupdate because we're done seeking and the time has changed.
     * This is particularly useful for if the player is paused to time the time displays.
     *
     * @event Tech#timeupdate
     * @type {EventTarget~Event}
     */
    this.player_.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   */


  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
  };

  /**
   * Move more quickly rewind for keyboard-only users
   */


  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
  };

  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called
   *
   */


  SeekBar.prototype.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Called when this SeekBar has focus and a key gets pressed down. By
   * default it will call `this.handleAction` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleAction(event);
    } else if (_Slider.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Slider.prototype.handleKeyPress.call(this, event);
    }
  };

  return SeekBar;
}(Slider);

/**
 * Default options for the `SeekBar`
 *
 * @type {Object}
 * @private
 */


SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'playProgressBar'],
  barName: 'playProgressBar'
};

// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
}

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
SeekBar.prototype.playerEvent = 'timeupdate';

Component.registerComponent('SeekBar', SeekBar);

/**
 * @file progress-control.js
 */
var ProgressControl = function (_Component) {
  inherits(ProgressControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ProgressControl(player, options) {
    classCallCheck(this, ProgressControl);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  ProgressControl.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */


  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild('seekBar');
    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
    var seekBarEl = seekBar.el();
    var seekBarRect = getBoundingClientRect(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;

    // The default skin has a gap on either side of the `SeekBar`. This means
    // that it's possible to trigger this behavior outside the boundaries of
    // the `SeekBar`. This ensures we stay within it at all times.
    if (seekBarPoint > 1) {
      seekBarPoint = 1;
    } else if (seekBarPoint < 0) {
      seekBarPoint = 0;
    }

    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
  };

  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */

  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild('seekBar');

    seekBar.handleMouseMove(event);
  };

  /**
   * Are controls are currently enabled for this progress control.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */


  ProgressControl.prototype.enabled = function enabled() {
    return this.enabled_;
  };

  /**
   * Disable all controls on the progress control and its children
   */


  ProgressControl.prototype.disable = function disable() {
    this.children().forEach(function (child) {
      return child.disable && child.disable();
    });

    if (!this.enabled()) {
      return;
    }

    this.off(['mousedown', 'touchstart'], this.handleMouseDown);
    this.off(this.el_, 'mousemove', this.handleMouseMove);
    this.handleMouseUp();

    this.addClass('disabled');

    this.enabled_ = false;
  };

  /**
   * Enable all controls on the progress control and its children
   */


  ProgressControl.prototype.enable = function enable() {
    this.children().forEach(function (child) {
      return child.enable && child.enable();
    });

    if (this.enabled()) {
      return;
    }

    this.on(['mousedown', 'touchstart'], this.handleMouseDown);
    this.on(this.el_, 'mousemove', this.handleMouseMove);
    this.removeClass('disabled');

    this.enabled_ = true;
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  return ProgressControl;
}(Component);

/**
 * Default options for `ProgressControl`
 *
 * @type {Object}
 * @private
 */


ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

Component.registerComponent('ProgressControl', ProgressControl);

/**
 * @file fullscreen-toggle.js
 */
var FullscreenToggle = function (_Button) {
  inherits(FullscreenToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function FullscreenToggle(player, options) {
    classCallCheck(this, FullscreenToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */


  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  FullscreenToggle.prototype.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
}(Button);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


FullscreenToggle.prototype.controlText_ = 'Fullscreen';

Component.registerComponent('FullscreenToggle', FullscreenToggle);

/**
 * Check if volume control is supported and if it isn't hide the
 * `Component` that was passed  using the `vjs-hidden` class.
 *
 * @param {Component} self
 *        The component that should be hidden if volume is unsupported
 *
 * @param {Player} player
 *        A reference to the player
 *
 * @private
 */
var checkVolumeSupport = function checkVolumeSupport(self, player) {
  // hide volume controls when they're not supported by the current tech
  if (player.tech_ && !player.tech_.featuresVolumeControl && !player.tech_.featuresMuteControl) {
    self.addClass('vjs-hidden');
  } else if (player.tech_ && player.tech_.featuresVolumeControl) {
    self.addClass('enable-volume-control');
  }

  self.on(player, 'loadstart', function () {
    if (!player.tech_.featuresVolumeControl && !player.tech_.featuresMuteControl) {
      self.addClass('vjs-hidden');
    } else if (player.tech_.featuresVolumeControl) {
      self.removeClass('vjs-hidden');
      self.addClass('enable-volume-control');
    }
  });
};

/**
 * @file volume-level.js
 */
var VolumeLevel = function (_Component) {
  inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    classCallCheck(this, VolumeLevel);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
}(Component);

Component.registerComponent('VolumeLevel', VolumeLevel);

/**
 * @file volume-bar.js
 */
var VolumeBar = function (_Slider) {
  inherits(VolumeBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function VolumeBar(player, options) {
    classCallCheck(this, VolumeBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.on('slideractive', _this.updateLastVolume_);
    _this.on(player, 'volumechange', _this.updateARIAAttributes);
    player.ready(function () {
      return _this.updateARIAAttributes();
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': this.localize('Volume Level'),
      'aria-live': 'polite'
    });
  };

  /**
   * Handle mouse down on volume bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  VolumeBar.prototype.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */


  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  /**
   * If the player is muted unmute it.
   */


  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */


  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };

  /**
   * Increase volume level for keyboard users
   */


  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   */


  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @param {EventTarget~Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */


  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();

    this.el_.setAttribute('aria-valuenow', ariaValue);
    this.el_.setAttribute('aria-valuetext', ariaValue + '%');
  };

  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */


  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };

  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */


  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;

    var volumeBeforeDrag = this.player_.volume();

    this.one('sliderinactive', function () {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };

  return VolumeBar;
}(Slider);

/**
 * Default options for the `VolumeBar`
 *
 * @type {Object}
 * @private
 */


VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  barName: 'volumeLevel'
};

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
VolumeBar.prototype.playerEvent = 'volumechange';

Component.registerComponent('VolumeBar', VolumeBar);

/**
 * @file volume-control.js
 */
var VolumeControl = function (_Component) {
  inherits(VolumeControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumeControl(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumeControl);

    options.vertical = options.vertical || false;

    // Pass the vertical option down to the VolumeBar if
    // the VolumeBar is turned on.
    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
      _this.volumeBar.addClass('vjs-slider-active');
      _this.addClass('vjs-slider-active');
      _this.trigger('slideractive');
    });

    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
      _this.volumeBar.removeClass('vjs-slider-active');
      _this.removeClass('vjs-slider-active');
      _this.trigger('sliderinactive');
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeControl.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-horizontal';

    if (this.options_.vertical) {
      orientationClass = 'vjs-volume-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control ' + orientationClass
    });
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseMove);
    this.on(doc, 'touchmove', this.throttledHandleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseMove);
    this.off(doc, 'touchmove', this.throttledHandleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };

  return VolumeControl;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

Component.registerComponent('VolumeControl', VolumeControl);

/**
 * @file mute-toggle.js
 */
var MuteToggle = function (_Button) {
  inherits(MuteToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MuteToggle(player, options) {
    classCallCheck(this, MuteToggle);

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.on(player, ['loadstart', 'volumechange'], _this.update);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MuteToggle.prototype.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();

    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;

      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };

  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */


  MuteToggle.prototype.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };

  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */


  MuteToggle.prototype.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // TODO improve muted icon classes
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, 'vjs-vol-' + i);
    }
    addClass(this.el_, 'vjs-vol-' + level);
  };

  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */


  MuteToggle.prototype.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? 'Unmute' : 'Mute';

    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };

  return MuteToggle;
}(Button);

/**
 * The text that should display over the `MuteToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


MuteToggle.prototype.controlText_ = 'Mute';

Component.registerComponent('MuteToggle', MuteToggle);

/**
 * @file volume-control.js
 */
var VolumePanel = function (_Component) {
  inherits(VolumePanel, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumePanel(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumePanel);

    if (typeof options.inline !== 'undefined') {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }

    // pass the inline option down to the VolumeControl as vertical if
    // the VolumeControl is on.
    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);
    _this.on(_this.muteToggle, 'focus', _this.sliderActive_);

    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
    _this.on(_this.muteToggle, 'blur', _this.sliderInactive_);
    return _this;
  }

  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */


  VolumePanel.prototype.sliderActive_ = function sliderActive_() {
    var IS_Mobile = IS_ANDROID || IS_IOS;
    if (!IS_Mobile) {
      this.addClass('vjs-slider-active');
    }
  };

  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */


  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {
    var IS_Mobile = IS_ANDROID || IS_IOS;
    if (!IS_Mobile) {
      this.removeClass('vjs-slider-active');
    }
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumePanel.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-panel-horizontal';

    if (!this.options_.inline) {
      orientationClass = 'vjs-volume-panel-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-panel vjs-control ' + orientationClass
    });
  };

  return VolumePanel;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumePanel.prototype.options_ = {
  children: ['muteToggle', 'volumeControl']
};

Component.registerComponent('VolumePanel', VolumePanel);

/**
 * @file menu.js
 */
var Menu = function (_Component) {
  inherits(Menu, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  function Menu(player, options) {
    classCallCheck(this, Menu);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    if (options) {
      _this.menuButton_ = options.menuButton;
    }

    _this.focusedChild_ = -1;

    _this.on('keydown', _this.handleKeyPress);
    return _this;
  }

  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */


  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', bind(this, function (event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere and it logs an error on IE8
        if (component.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }));
  };

  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */


  Menu.prototype.createEl = function createEl$$1() {
    var contentElType = this.options_.contentElType || 'ul';

    this.contentEl_ = createEl(contentElType, {
      className: 'vjs-menu-content'
    });

    this.contentEl_.setAttribute('role', 'menu');

    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });

    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  Menu.prototype.dispose = function dispose() {
    this.contentEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {EventTarget~Event} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */


  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepForward();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users.
   */


  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users.
   */


  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */


  Menu.prototype.focus = function focus() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
}(Component);

Component.registerComponent('Menu', Menu);

/**
 * @file menu-button.js
 */
var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function MenuButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, MenuButton);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.menuButton_ = new Button(player, options);

    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

    // Add buildCSSClass values to the button, not the wrapper
    var buttonClass = Button.prototype.buildCSSClass();

    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
    _this.menuButton_.removeClass('vjs-control');

    _this.addChild(_this.menuButton_);

    _this.update();

    _this.enabled_ = true;

    _this.on(_this.menuButton_, 'tap', _this.handleClick);
    _this.on(_this.menuButton_, 'click', _this.handleClick);
    _this.on(_this.menuButton_, 'focus', _this.handleFocus);
    _this.on(_this.menuButton_, 'blur', _this.handleBlur);

    _this.on('keydown', _this.handleSubmenuKeyPress);
    return _this;
  }

  /**
   * Update the menu based on the current state of its items.
   */


  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */


  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player_, { menuButton: this });

    /**
     * Hide the menu if the number of items is less than or equal to this threshold. This defaults
     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
     * it here because every time we run `createMenu` we need to reset the value.
     *
     * @protected
     * @type {Number}
     */
    this.hideThreshold_ = 0;

    // Add a title list item to the top
    if (this.options_.title) {
      var title = createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: toTitleCase(this.options_.title),
        tabIndex: -1
      });

      this.hideThreshold_ += 1;

      menu.children_.unshift(title);
      prependTo(title, menu.contentEl());
    }

    this.items = this.createItems();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */


  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuButton.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildWrapperCSSClass()
    }, {});
  };

  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */


  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    // TODO: Fix the CSS so that this isn't necessary
    var buttonClass = Button.prototype.buildCSSClass();

    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  MenuButton.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();

    return this.menuButton_.controlText(text, el);
  };

  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuButton.prototype.handleClick = function handleClick(event) {
    // When you click the button it adds focus, which will show the menu.
    // So we'll remove focus when the mouse leaves the button. Focus is needed
    // for tab navigation.

    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Set the focus to the actual button, not to this element
   */


  MenuButton.prototype.focus = function focus() {
    this.menuButton_.focus();
  };

  /**
   * Remove the focus from the actual button, not this element
   */


  MenuButton.prototype.blur = function blur() {
    this.menuButton_.blur();
  };

  /**
   * This gets called when a `MenuButton` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  MenuButton.prototype.handleFocus = function handleFocus() {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when a `MenuButton` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  MenuButton.prototype.handleBlur = function handleBlur() {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyPress} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
      if (!this.buttonPressed_) {
        this.pressButton();
        event.preventDefault();
      }
    }
  };

  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {EventTarget~Event} event
   *        Key press event
   *
   * @listens keydown
   */


  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
    }
  };

  /**
   * Put the current `MenuButton` into a pressed state.
   */


  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'true');

      // set the focus into the submenu, except on iOS where it is resulting in
      // undesired scrolling behavior when the player is in an iframe
      if (IS_IOS && isInFrame()) {
        // Return early so that the menu isn't focused
        return;
      }

      this.menu.focus();
    }
  };

  /**
   * Take the current `MenuButton` out of a pressed state.
   */


  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
    }
  };

  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */


  MenuButton.prototype.disable = function disable() {
    this.unpressButton();

    this.enabled_ = false;
    this.addClass('vjs-disabled');

    this.menuButton_.disable();
  };

  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */


  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;
    this.removeClass('vjs-disabled');

    this.menuButton_.enable();
  };

  return MenuButton;
}(Component);

Component.registerComponent('MenuButton', MenuButton);

/**
 * @file track-button.js
 */
var TrackButton = function (_MenuButton) {
  inherits(TrackButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TrackButton(player, options) {
    classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    if (_this.items.length <= 1) {
      _this.hide();
    }

    if (!tracks) {
      return possibleConstructorReturn(_this);
    }

    var updateHandler = bind(_this, _this.update);

    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);
    _this.player_.on('ready', updateHandler);

    _this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
    return _this;
  }

  return TrackButton;
}(MenuButton);

Component.registerComponent('TrackButton', TrackButton);

/**
 * @file menu-item.js
 */
var MenuItem = function (_ClickableComponent) {
  inherits(MenuItem, _ClickableComponent);

  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  function MenuItem(player, options) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.selectable = options.selectable;

    _this.selected(options.selected);

    if (_this.selectable) {
      // TODO: May need to be either menuitemcheckbox or menuitemradio,
      //       and may need logical grouping of menu items.
      _this.el_.setAttribute('role', 'menuitemcheckbox');
    } else {
      _this.el_.setAttribute('role', 'menuitem');
    }
    return _this;
  }

  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    // The control is textual, not just an icon
    this.nonIconControl = true;

    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({
      className: 'vjs-menu-item',
      innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + '</span>',
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Any click on a `MenuItem` puts int into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuItem.prototype.handleClick = function handleClick(event) {
    this.selected(true);
  };

  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */


  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        this.controlText('');
      }
    }
  };

  return MenuItem;
}(ClickableComponent);

Component.registerComponent('MenuItem', MenuItem);

/**
 * @file text-track-menu-item.js
 */
var TextTrackMenuItem = function (_MenuItem) {
  inherits(TextTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TextTrackMenuItem(player, options) {
    classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.mode === 'showing';

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    var changeHandler = function changeHandler() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.handleTracksChange.apply(_this, args);
    };
    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this.handleSelectedLanguageChange.apply(_this, args);
    };

    player.on(['loadstart', 'texttrackchange'], changeHandler);
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    _this.on('dispose', function () {
      player.off(['loadstart', 'texttrackchange'], changeHandler);
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    });

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks.onchange === undefined) {
      var event = void 0;

      _this.on(['tap', 'click'], function () {
        if (_typeof(window_1.Event) !== 'object') {
          // Android 2.3 throws an Illegal Constructor error for window.Event
          try {
            event = new window_1.Event('change');
          } catch (err) {
            // continue regardless of error
          }
        }

        if (!event) {
          event = document_1.createEvent('Event');
          event.initEvent('change', true, true);
        }

        tracks.dispatchEvent(event);
      });
    }

    // set the default state based on current tracks
    _this.handleTracksChange();
    return _this;
  }

  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track.kind;
    var kinds = this.track.kinds;
    var tracks = this.player_.textTracks();

    if (!kinds) {
      kinds = [kind];
    }

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) {
      return;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track === this.track && kinds.indexOf(track.kind) > -1) {
        if (track.mode !== 'showing') {
          track.mode = 'showing';
        }
      } else if (track.mode !== 'disabled') {
        track.mode = 'disabled';
      }
    }
  };

  /**
   * Handle text track list change
   *
   * @param {EventTarget~Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */


  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.mode === 'showing');
  };

  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === 'showing') {
      var selectedLanguage = this.player_.cache_.selectedLanguage;

      // Don't replace the kind of track across the same language
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }

      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };

  TextTrackMenuItem.prototype.dispose = function dispose() {
    // remove reference to track object on dispose
    this.track = null;

    _MenuItem.prototype.dispose.call(this);
  };

  return TextTrackMenuItem;
}(MenuItem);

Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

/**
 * @file off-text-track-menu-item.js
 */
var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function OffTextTrackMenuItem(player, options) {
    classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      player: player,
      kind: options.kind,
      kinds: options.kinds,
      'default': false,
      mode: 'disabled'
    };

    if (!options.kinds) {
      options.kinds = [options.kind];
    }

    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(' and ') + ' off';
    }

    // MenuItem is selectable
    options.selectable = true;

    return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   */


  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var selected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
        selected = false;
        break;
      }
    }

    this.selected(selected);
  };

  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
        allHidden = false;
        break;
      }
    }

    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };

  return OffTextTrackMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

/**
 * @file text-track-button.js
 */
var TextTrackButton = function (_TrackButton) {
  inherits(TextTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function TextTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */


  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;


    // Label is an overide for the [track] off label
    // USed to localise captions/subtitles
    var label = void 0;

    if (this.label_) {
      label = this.label_ + ' off';
    }
    // Add an OFF menu item to turn all tracks off
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: label
    }));

    this.hideThreshold_ += 1;

    var tracks = this.player_.textTracks();

    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of an appropriate kind and have a label
      if (this.kinds_.indexOf(track.kind) > -1) {

        var item = new TrackMenuItem(this.player_, {
          track: track,
          // MenuItem is selectable
          selectable: true
        });

        item.addClass('vjs-' + track.kind + '-menu-item');
        items.push(item);
      }
    }

    return items;
  };

  return TextTrackButton;
}(TrackButton);

Component.registerComponent('TextTrackButton', TextTrackButton);

/**
 * @file chapters-track-menu-item.js
 */
var ChaptersTrackMenuItem = function (_MenuItem) {
  inherits(ChaptersTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ChaptersTrackMenuItem(player, options) {
    classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.selectable = true;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    _this.cue = cue;
    track.addEventListener('cuechange', bind(_this, _this.update));
    return _this;
  }

  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @param {EventTarget~Event} [event]
   *        The `cuechange` event that caused this function to run.
   *
   * @listens TextTrack#cuechange
   */


  ChaptersTrackMenuItem.prototype.update = function update(event) {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
  };

  return ChaptersTrackMenuItem;
}(MenuItem);

Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

/**
 * @file chapters-button.js
 */
var ChaptersButton = function (_TextTrackButton) {
  inherits(ChaptersButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this function is ready.
   */
  function ChaptersButton(player, options, ready) {
    classCallCheck(this, ChaptersButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Update the menu based on the current state of its items.
   *
   * @param {EventTarget~Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */


  ChaptersButton.prototype.update = function update(event) {
    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
      this.setTrack(this.findChaptersTrack());
    }
    _TextTrackButton.prototype.update.call(this);
  };

  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */


  ChaptersButton.prototype.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }

    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }

    // here this.track_ refers to the old track instance
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
      }

      this.track_ = null;
    }

    this.track_ = track;

    // here this.track_ refers to the new track instance
    if (this.track_) {
      this.track_.mode = 'hidden';

      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
      }
    }
  };

  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */


  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];

    for (var i = tracks.length - 1; i >= 0; i--) {
      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track.kind === this.kind_) {
        return track;
      }
    }
  };

  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */


  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase(this.kind_));
  };

  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */


  ChaptersButton.prototype.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items
   */


  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    if (!this.track_) {
      return items;
    }

    var cues = this.track_.cues;

    if (!cues) {
      return items;
    }

    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });

      items.push(mi);
    }

    return items;
  };

  return ChaptersButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


ChaptersButton.prototype.kind_ = 'chapters';

/**
 * The text that should display over the `ChaptersButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
ChaptersButton.prototype.controlText_ = 'Chapters';

Component.registerComponent('ChaptersButton', ChaptersButton);

/**
 * @file descriptions-button.js
 */
var DescriptionsButton = function (_TextTrackButton) {
  inherits(DescriptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function DescriptionsButton(player, options, ready) {
    classCallCheck(this, DescriptionsButton);

    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));

    var tracks = player.textTracks();
    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */


  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (track.kind !== this.kind_ && track.mode === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return DescriptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


DescriptionsButton.prototype.kind_ = 'descriptions';

/**
 * The text that should display over the `DescriptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
DescriptionsButton.prototype.controlText_ = 'Descriptions';

Component.registerComponent('DescriptionsButton', DescriptionsButton);

/**
 * @file subtitles-button.js
 */
var SubtitlesButton = function (_TextTrackButton) {
  inherits(SubtitlesButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function SubtitlesButton(player, options, ready) {
    classCallCheck(this, SubtitlesButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return SubtitlesButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


SubtitlesButton.prototype.kind_ = 'subtitles';

/**
 * The text that should display over the `SubtitlesButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
SubtitlesButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubtitlesButton', SubtitlesButton);

/**
 * @file caption-settings-menu-item.js
 */
var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CaptionSettingsMenuItem(player, options) {
    classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      player: player,
      kind: options.kind,
      label: options.kind + ' settings',
      selectable: false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options.selectable = false;

    options.name = 'CaptionSettingsMenuItem';

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.addClass('vjs-texttrack-settings');
    _this.controlText(', opens ' + options.kind + ' settings dialog');
    return _this;
  }

  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {
    this.player().getChild('textTrackSettings').open();
  };

  return CaptionSettingsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

/**
 * @file captions-button.js
 */
var CaptionsButton = function (_TextTrackButton) {
  inherits(CaptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function CaptionsButton(player, options, ready) {
    classCallCheck(this, CaptionsButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));

      this.hideThreshold_ += 1;
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


CaptionsButton.prototype.kind_ = 'captions';

/**
 * The text that should display over the `CaptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
CaptionsButton.prototype.controlText_ = 'Captions';

Component.registerComponent('CaptionsButton', CaptionsButton);

/**
 * @file subs-caps-menu-item.js
 */
var SubsCapsMenuItem = function (_TextTrackMenuItem) {
  inherits(SubsCapsMenuItem, _TextTrackMenuItem);

  function SubsCapsMenuItem() {
    classCallCheck(this, SubsCapsMenuItem);
    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
  }

  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {
    var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);

    if (this.options_.track.kind === 'captions') {
      innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize('Captions') + '</span>\n      ';
    }

    innerHTML += '</span>';

    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
      innerHTML: innerHTML
    }, props), attrs);

    return el;
  };

  return SubsCapsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

/**
 * @file sub-caps-button.js
 */
var SubsCapsButton = function (_TextTrackButton) {
  inherits(SubsCapsButton, _TextTrackButton);

  function SubsCapsButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, SubsCapsButton);

    // Although North America uses "captions" in most cases for
    // "captions and subtitles" other locales use "subtitles"
    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));

    _this.label_ = 'subtitles';
    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
      _this.label_ = 'captions';
    }
    _this.menuButton_.controlText(toTitleCase(_this.label_));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  SubsCapsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));

      this.hideThreshold_ += 1;
    }

    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };

  return SubsCapsButton;
}(TextTrackButton);

/**
 * `kind`s of TextTrack to look for to associate it with this menu.
 *
 * @type {array}
 * @private
 */


SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

/**
 * The text that should display over the `SubsCapsButton`s controls.
 *
 *
 * @type {string}
 * @private
 */
SubsCapsButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubsCapsButton', SubsCapsButton);

/**
 * @file audio-track-menu-item.js
 */
var AudioTrackMenuItem = function (_MenuItem) {
  inherits(AudioTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function AudioTrackMenuItem(player, options) {
    classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;

    var changeHandler = function changeHandler() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.handleTracksChange.apply(_this, args);
    };
    _this.changeHandler = changeHandler;
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('enabledchange', changeHandler);

    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('enabledchange', changeHandler);
    });
    return _this;
  }

  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    this.player_.tech_.hlsProvider.hls.audioTrack = this.track.id;
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */


  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
}(MenuItem);

Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

/**
 * @file audio-track-button.js
 */
var AudioTrackButton = function (_TrackButton) {
  inherits(AudioTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function AudioTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */


  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // if there's only one audio track, there no point in showing it
    this.hideThreshold_ = 1;

    var tracks = this.player_.audioTracks();

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new AudioTrackMenuItem(this.player_, {
        track: track,
        // MenuItem is selectable
        selectable: true
      }));
    }

    return items;
  };

  return AudioTrackButton;
}(TrackButton);

/**
 * The text that should display over the `AudioTrackButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


AudioTrackButton.prototype.controlText_ = 'Audio Track';
Component.registerComponent('AudioTrackButton', AudioTrackButton);

/**
 * @file playback-rate-menu-item.js
 */
var PlaybackRateMenuItem = function (_MenuItem) {
  inherits(PlaybackRateMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuItem(player, options) {
    classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.label = label;
    _this.rate = rate;

    _this.on(player, 'ratechange', _this.update);
    return _this;
  }

  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {EventTarget~Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuItem.prototype.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
}(MenuItem);

/**
 * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuItem.prototype.contentElType = 'button';

Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

/**
 * @file playback-rate-menu-button.js
 */
var PlaybackRateMenuButton = function (_MenuButton) {
  inherits(PlaybackRateMenuButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuButton(player, options) {
    classCallCheck(this, PlaybackRateMenuButton);

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    _this.updateVisibility();
    _this.updateLabel();

    _this.on(player, 'loadstart', _this.updateVisibility);
    _this.on(player, 'ratechange', _this.updateLabel);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: '1x'
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  PlaybackRateMenuButton.prototype.dispose = function dispose() {
    this.labelEl_ = null;

    _MenuButton.prototype.dispose.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu}
   *         Menu object populated with {@link PlaybackRateMenuItem}s
   */


  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   */


  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * This gets called when an `PlaybackRateMenuButton` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];

    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */


  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */


  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */


  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {
    var playbackRate = this.player().playbackRate();
    if (playbackRate === 1.1) {
      return false;
    }

    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = playbackRate + 'x';
    }
  };

  return PlaybackRateMenuButton;
}(MenuButton);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

/**
 * @file spacer.js
 */
var Spacer = function (_Component) {
  inherits(Spacer, _Component);

  function Spacer() {
    classCallCheck(this, Spacer);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
}(Component);

Component.registerComponent('Spacer', Spacer);

/**
 * @file custom-control-spacer.js
 */
var CustomControlSpacer = function (_Spacer) {
  inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    classCallCheck(this, CustomControlSpacer);
    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '\xA0';
    return el;
  };

  return CustomControlSpacer;
}(Spacer);

Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

/**
 * @file control-bar.js
 */
var ControlBar = function (_Component) {
  inherits(ControlBar, _Component);

  function ControlBar() {
    classCallCheck(this, ControlBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    }, {
      // The control bar is a group, but we don't aria-label it to avoid
      //  over-announcing by JAWS
      role: 'group'
    });
  };

  return ControlBar;
}(Component);

/**
 * Default options for `ControlBar`
 *
 * @type {Object}
 * @private
 */


ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'audioTrackButton',
  // 'subsCapsButton',
  'fullscreenToggle']
};

if (IS_ENABLED_MSE && !IS_SAFARI) {
  var controlChildren = ControlBar.prototype.options_.children;
  controlChildren.splice(controlChildren.length - 2, 0, 'subsCapsButton');
}

Component.registerComponent('ControlBar', ControlBar);

/**
 * @file error-display.js
 */
var ErrorDisplay = function (_ModalDialog) {
  inherits(ErrorDisplay, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ErrorDisplay(player, options) {
    classCallCheck(this, ErrorDisplay);

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.on(player, 'error', _this.open);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */


  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */


  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();

    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
}(ModalDialog);

/**
 * The default options for an `ErrorDisplay`.
 *
 * @private
 */


ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

Component.registerComponent('ErrorDisplay', ErrorDisplay);

/**
 * @file text-track-settings.js
 */
var LOCAL_STORAGE_KEY = 'vjs-text-track-settings';

var COLOR_BLACK = ['#000', 'Black'];
var COLOR_BLUE = ['#00F', 'Blue'];
var COLOR_CYAN = ['#0FF', 'Cyan'];
var COLOR_GREEN = ['#0F0', 'Green'];
var COLOR_MAGENTA = ['#F0F', 'Magenta'];
var COLOR_RED = ['#F00', 'Red'];
var COLOR_WHITE = ['#FFF', 'White'];
var COLOR_YELLOW = ['#FF0', 'Yellow'];

var OPACITY_OPAQUE = ['1', 'Opaque'];
var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
var OPACITY_TRANS = ['0', 'Transparent'];

// Configuration for the various <select> elements in the DOM of this component.
//
// Possible keys include:
//
// `default`:
//   The default option index. Only needs to be provided if not zero.
// `parser`:
//   A function which is used to parse the value from the selected option in
//   a customized way.
// `selector`:
//   The selector used to find the associated <select> element.
var selectConfigs = {
  backgroundColor: {
    selector: '.vjs-bg-color > select',
    id: 'captions-background-color-%s',
    label: 'Color',
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  backgroundOpacity: {
    selector: '.vjs-bg-opacity > select',
    id: 'captions-background-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },

  color: {
    selector: '.vjs-fg-color > select',
    id: 'captions-foreground-color-%s',
    label: 'Color',
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  edgeStyle: {
    selector: '.vjs-edge-style > select',
    id: '%s',
    label: 'Text Edge Style',
    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
  },

  fontFamily: {
    selector: '.vjs-font-family > select',
    id: 'captions-font-family-%s',
    label: 'Font Family',
    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
  },

  fontPercent: {
    selector: '.vjs-font-percent > select',
    id: 'captions-font-size-%s',
    label: 'Font Size',
    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
    'default': 2,
    parser: function parser(v) {
      return v === '1.00' ? null : Number(v);
    }
  },

  textOpacity: {
    selector: '.vjs-text-opacity > select',
    id: 'captions-foreground-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },

  // Options for this object are defined below.
  windowColor: {
    selector: '.vjs-window-color > select',
    id: 'captions-window-color-%s',
    label: 'Color'
  },

  // Options for this object are defined below.
  windowOpacity: {
    selector: '.vjs-window-opacity > select',
    id: 'captions-window-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};

selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

/**
 * Get the actual value of an option.
 *
 * @param  {string} value
 *         The value to get
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function parseOptionValue(value, parser) {
  if (parser) {
    value = parser(value);
  }

  if (value && value !== 'none') {
    return value;
  }
}

/**
 * Gets the value of the selected <option> element within a <select> element.
 *
 * @param  {Element} el
 *         the element to look in
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function getSelectedOptionValue(el, parser) {
  var value = el.options[el.options.selectedIndex].value;

  return parseOptionValue(value, parser);
}

/**
 * Sets the selected <option> element within a <select> element based on a
 * given value.
 *
 * @param {Element} el
 *        The element to look in.
 *
 * @param {string} value
 *        the property to look on.
 *
 * @param {Function} [parser]
 *        Optional function to adjust the value before comparing.
 *
 * @private
 */
function setSelectedOption(el, value, parser) {
  if (!value) {
    return;
  }

  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}

/**
 * Manipulate Text Tracks settings.
 *
 * @extends ModalDialog
 */

var TextTrackSettings = function (_ModalDialog) {
  inherits(TextTrackSettings, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  function TextTrackSettings(player, options) {
    classCallCheck(this, TextTrackSettings);

    options.temporary = false;

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.updateDisplay = bind(_this, _this.updateDisplay);

    // fill the modal and pretend we have opened it
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;

    _this.endDialog = createEl('p', {
      className: 'vjs-control-text',
      textContent: _this.localize('End of dialog window.')
    });
    _this.el().appendChild(_this.endDialog);

    _this.setDefaults();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }

    _this.on(_this.$('.vjs-done-button'), 'click', function () {
      _this.saveSettings();
      _this.close();
    });

    _this.on(_this.$('.vjs-default-button'), 'click', function () {
      _this.setDefaults();
      _this.updateDisplay();
    });

    each(selectConfigs, function (config) {
      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
    });

    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }

  TextTrackSettings.prototype.dispose = function dispose() {
    this.endDialog = null;

    _ModalDialog.prototype.dispose.call(this);
  };

  /**
   * Create a <select> element with configured options.
   *
   * @param {string} key
   *        Configuration key to use during creation.
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {
    var _this2 = this;

    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';

    var config = selectConfigs[key];
    var id = config.id.replace('%s', this.id_);

    return ['<' + type + ' id="' + id + '" class="' + (type === 'label' ? 'vjs-label' : '') + '">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby="' + (legendId !== '' ? legendId + ' ' : '') + id + '">'].concat(config.options.map(function (o) {
      var optionId = id + '-' + o[1];

      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + (legendId !== '' ? legendId + ' ' : '') + id + ' ' + optionId + '">', _this2.localize(o[1]), '</option>'].join('');
    })).concat('</select>').join('');
  };

  /**
   * Create foreground color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {
    var legendId = 'captions-text-legend-' + this.id_;

    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create background color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {
    var legendId = 'captions-background-' + this.id_;

    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create window color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {
    var legendId = 'captions-window-' + this.id_;

    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create color elements for the component
   *
   * @return {Element}
   *         The element that was created
   *
   * @private
   */


  TextTrackSettings.prototype.createElColors_ = function createElColors_() {
    return createEl('div', {
      className: 'vjs-track-settings-colors',
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
    });
  };

  /**
   * Create font elements for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFont_ = function createElFont_() {
    return createEl('div', {
      className: 'vjs-track-settings-font">',
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
    });
  };

  /**
   * Create controls for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize('restore all settings to the default values');

    return createEl('div', {
      className: 'vjs-track-settings-controls',
      innerHTML: ['<button class="vjs-default-button" title="' + defaultsDescription + '">', this.localize('Reset'), '<span class="vjs-control-text"> ' + defaultsDescription + '</span>', '</button>', '<button class="vjs-done-button">' + this.localize('Done') + '</button>'].join('')
    });
  };

  TextTrackSettings.prototype.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };

  TextTrackSettings.prototype.label = function label() {
    return this.localize('Caption Settings Dialog');
  };

  TextTrackSettings.prototype.description = function description() {
    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
  };

  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
  };

  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.getValues = function getValues() {
    var _this3 = this;

    return reduce(selectConfigs, function (accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);

      if (value !== undefined) {
        accum[key] = value;
      }

      return accum;
    }, {});
  };

  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.setValues = function setValues(values) {
    var _this4 = this;

    each(selectConfigs, function (config, key) {
      setSelectedOption(_this4.$(config.selector), values[key], config.parser);
    });
  };

  /**
   * Sets all `<select>` elements to their default values.
   */


  TextTrackSettings.prototype.setDefaults = function setDefaults() {
    var _this5 = this;

    each(selectConfigs, function (config) {
      var index = config.hasOwnProperty('default') ? config['default'] : 0;

      _this5.$(config.selector).selectedIndex = index;
    });
  };

  /**
   * Restore texttrack settings from localStorage
   */


  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var values = void 0;

    try {
      values = JSON.parse(window_1.localStorage.getItem(LOCAL_STORAGE_KEY));
    } catch (err) {
      log$2.warn(err);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save text track settings to localStorage
   */


  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();

    try {
      if (Object.keys(values).length) {
        window_1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
      } else {
        window_1.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    } catch (err) {
      log$2.warn(err);
    }
  };

  /**
   * Update display of text track settings
   */


  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');

    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  /**
   * conditionally blur the element and refocus the captions button
   *
   * @private
   */


  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    this.off(document_1, 'keydown', this.handleKeyDown);

    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;

    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };

  return TextTrackSettings;
}(ModalDialog);

Component.registerComponent('TextTrackSettings', TextTrackSettings);

var _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.']);

/**
 * @file html5.js
 */
var Html5 = function (_Tech) {
  inherits(Html5, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Html5(player, options, ready) {
    classCallCheck(this, Html5);

    var _this = possibleConstructorReturn(this, _Tech.call(this, player, options, ready));

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }

    if (_this.el_.hasChildNodes()) {

      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!_this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }

    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$2.warn(tsml(_templateObject$2));
    }

    // prevent iOS Safari from disabling metadata text tracks during native playback
    _this.restoreMetadataTracksInIOSNativePlayer_();

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }

    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
    // into a `fullscreenchange` event
    _this.proxyWebkitFullscreen_();

    _this.triggerReady();
    return _this;
  }

  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */


  Html5.prototype.dispose = function dispose() {
    Html5.disposeMediaElement(this.el_);
    this.options_ = null;

    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */


  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState = void 0;

    // captures a snapshot of every metadata track's current state
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {
      metadataTracksPreFullscreenState = [];

      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];

        if (track.kind === 'metadata') {
          metadataTracksPreFullscreenState.push({
            track: track,
            storedMode: track.mode
          });
        }
      }
    };

    // snapshot each metadata track's initial state, and update the snapshot
    // each time there is a track 'change' event
    takeMetadataTrackSnapshot();
    textTracks.addEventListener('change', takeMetadataTrackSnapshot);

    this.on('dispose', function () {
      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
    });

    var restoreTrackMode = function restoreTrackMode() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];

        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      // we only want this handler to be executed on the first 'change' event
      textTracks.removeEventListener('change', restoreTrackMode);
    };

    // when we enter fullscreen playback, stop updating the snapshot and
    // restore all track modes to their pre-fullscreen state
    this.on('webkitbeginfullscreen', function () {
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);

      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', restoreTrackMode);
      textTracks.addEventListener('change', restoreTrackMode);
    });

    // start updating the snapshot again after leaving fullscreen
    this.on('webkitendfullscreen', function () {
      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
      textTracks.addEventListener('change', takeMetadataTrackSnapshot);

      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback
      textTracks.removeEventListener('change', restoreTrackMode);
    });
  };

  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */


  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this2 = this;

    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var elTracks = _this2.el()[props.getterName];
      var techTracks = _this2[props.getterName]();

      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          techTracks.trigger({
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          });
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];

        for (var i = 0; i < techTracks.length; i++) {
          var found = false;

          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }

          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }

        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };

      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];

        elTracks.addEventListener(eventName, listener);
        _this2.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });

      // Remove (native) tracks that are not used anymore
      _this2.on('loadstart', removeOldTracks);
      _this2.on('dispose', function (e) {
        return _this2.off('loadstart', removeOldTracks);
      });
    });
  };

  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Html5.prototype.createEl = function createEl$$1() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    // If we ingested the player div, we do not need to move the media element.
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);

        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document_1.createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions({}, tagAttributes);

        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    if (typeof this.options_.preload !== 'undefined') {
      setAttribute(el, 'preload', this.options_.preload);
    }

    // Update specific tag settings, in case they were overridden
    // `autoplay` has to be *last* so that `muted` and `playsinline` are present
    // when iOS/Safari or other browsers attempt to autoplay.
    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];

    for (var i = 0; i < settingsAttrs.length; i++) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];

      if (typeof value !== 'undefined') {
        if (value) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value;
      }
    }

    return el;
  };

  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */


  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      // NetworkState is set synchronously BUT loadstart is fired at the
      // end of the current stack, usually before setInterval(fn, 0).
      // So at this point we know loadstart may have already fired or is
      // about to fire, and either way the player hasn't seen it yet.
      // We don't want to fire loadstart prematurely here and cause a
      // double loadstart so we'll wait and see if it happens between now
      // and the next loop, and fire it if not.
      // HOWEVER, we also want to make sure it fires before loadedmetadata
      // which could also happen between now and the next loop, so we'll
      // watch for that also.
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired() {
        loadstartFired = true;
      };

      this.on('loadstart', setLoadstartFired);

      var triggerLoadstart = function triggerLoadstart() {
        // We did miss the original loadstart. Make sure the player
        // sees loadstart before loadedmetadata
        if (!loadstartFired) {
          this.trigger('loadstart');
        }
      };

      this.on('loadedmetadata', triggerLoadstart);

      this.ready(function () {
        this.off('loadstart', setLoadstartFired);
        this.off('loadedmetadata', triggerLoadstart);

        if (!loadstartFired) {
          // We did miss the original native loadstart. Fire it now.
          this.trigger('loadstart');
        }
      });

      return;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */


  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      log$2(e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */


  Html5.prototype.duration = function duration() {
    var _this3 = this;

    // Android Chrome will report duration as Infinity for VOD HLS until after
    // playback has started, which triggers the live display erroneously.
    // Return NaN if playback has not started and trigger a durationupdate once
    // the duration can be reliably known.
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      // Wait for the first `timeupdate` with currentTime > 0 - there may be
      // several with 0
      var checkProgress = function checkProgress() {
        if (_this3.el_.currentTime > 0) {
          // Trigger durationchange for genuinely live video
          if (_this3.el_.duration === Infinity) {
            _this3.trigger('durationchange');
          }
          _this3.off('timeupdate', checkProgress);
        }
      };

      this.on('timeupdate', checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };

  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */


  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The heigth of the HTML5 media element.
   */


  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */


  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this4 = this;

    if (!('webkitDisplayingFullscreen' in this.el_)) {
      return;
    }

    var endFn = function endFn() {
      this.trigger('fullscreenchange', { isFullscreen: false });
    };

    var beginFn = function beginFn() {
      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
        this.one('webkitendfullscreen', endFn);

        this.trigger('fullscreenchange', { isFullscreen: true });
      }
    };

    this.on('webkitbeginfullscreen', beginFn);
    this.on('dispose', function () {
      _this4.off('webkitbeginfullscreen', beginFn);
      _this4.off('webkitendfullscreen', endFn);
    });
  };

  /**
   * Check if fullscreen is supported on the current playback device.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */


  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = window_1.navigator && window_1.navigator.userAgent || '';

      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */


  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;
    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      console.warn('tech enterFullScreen', video.paused, video.networkState, video.HAVE_METADATA);
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      console.log('webkitEnterFullScreen');
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */


  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    }

    // Setting src through `src` instead of `setSrc` will be deprecated
    this.setSrc(_src);
  };

  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */


  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */


  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };

  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */


  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to intialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document_1.createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    return htmlTrackElement;
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be
   * automatically removed from the video element whenever the source changes
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   * @deprecated The default value of the "manualCleanup" parameter will default
   * to "false" in upcoming versions of Video.js
   */


  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);

    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }

    return htmlTrackElement;
  };

  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */


  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);

    if (this.featuresNativeTextTracks) {
      var tracks = this.$$('track');

      var i = tracks.length;

      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === 'function') {
      return this.el().getVideoPlaybackQuality();
    }

    var videoPlaybackQuality = {};

    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }

    if (window_1.performance && typeof window_1.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window_1.performance.now();
    } else if (window_1.performance && window_1.performance.timing && typeof window_1.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window_1.Date.now() - window_1.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Html5;
}(Tech);

/* HTML5 Support Testing ---------------------------------------------------- */

if (isReal()) {

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  Html5.TEST_VID = document_1.createElement('video');
  var track = document_1.createElement('track');

  track.kind = 'captions';
  track.srclang = 'en';
  track.label = 'English';
  Html5.TEST_VID.appendChild(track);
}

/**
 * Check if HTML5 media is supported by this browser/device.
 *
 * @return {boolean}
 *         - True if HTML5 media is supported.
 *         - False if HTML5 media is not supported.
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};

/**
 * Check if the tech can support the given type
 *
 * @param {string} type
 *        The mimetype to check
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlayType = function (type) {
  return Html5.TEST_VID.canPlayType(type);
};

/**
 * Check if the tech can support the given source
 * @param {Object} srcObj
 *        The source object
 * @param {Object} options
 *        The options passed to the tech
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlaySource = function (srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {boolean}
 *         - True if volume can be controlled
 *         - False otherwise
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;

    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the mute can be changed in this browser/device.
 * Volume can be changed in a lot of mobile devices.
 *
 * @return {boolean}
 *         - True if mute can be controlled
 *         - False otherwise
 */
Html5.canControlMute = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var muted = Html5.TEST_VID.muted;

    Html5.TEST_VID.muted = true;
    return muted !== Html5.TEST_VID.muted;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the playback rate can be changed in this browser/device.
 *
 * @return {boolean}
 *         - True if playback rate can be controlled
 *         - False otherwise
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;

    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/**
 * Check to see if native `TextTrack`s are supported by this browser/device.
 *
 * @return {boolean}
 *         - True if native `TextTrack`s are supported.
 *         - False otherwise
 */
Html5.supportsNativeTextTracks = function () {
  return IS_ANY_SAFARI;
};

/**
 * Check to see if native `VideoTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `VideoTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeVideoTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};

/**
 * Check to see if native `AudioTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `AudioTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeAudioTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

/**
 * Boolean indicating whether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Boolean indicating whether the `Tech` supports mute control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresMuteControl = Html5.canControlMute();

/**
 * Boolean indicating whether the `Tech` supports changing the speed at which the media
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default {@link Html5.canControlPlaybackRate}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Boolean indicating whether the `HTML5` tech currently supports the media element
 * moving in the DOM. iOS breaks if you move the media element, so this is set this to
 * false there. Everywhere else this should be true.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.movingMediaElementInDOM = !IS_IOS;

// TODO: Previous comment: No longer appears to be used. Can probably be removed.
//       Is this true?
/**
 * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
 * when going into fullscreen.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the progress event.
 * If this is false, manual `progress` events will be triggred instead.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
 * If this is false, manual `timeupdate` events will be triggred instead.
 *
 * @default
 */
Html5.prototype.featuresTimeupdateEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeTextTracks}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeVideoTracks}
 */
Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeAudioTracks}
 */
Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {
  console.log('patchCanPlayType');
  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };

    // Override Android 2.2 and less canPlayType method which is broken
  } else if (IS_OLD_ANDROID) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;

  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  return r;
};

// by default, patch the media element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;

  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // satisfy linter
      }
    })();
  }
};

/* Native HTML5 element property wrapping ----------------------------------- */
// Wrap native boolean attributes with getters that check both property and attribute
// The list is as followed:
// muted, defaultMuted, autoplay, controls, loop, playsinline
[
/**
 * Get the value of `muted` from the media element. `muted` indicates
 * that the volume for the media should be set to silent. This does not actually change
 * the `volume` attribute.
 *
 * @method Html5#muted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
 * current state.
 *
 * @method Html5#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the media element.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `autoplay` from the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the media element.
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Get the value of `controls` from the media element. `controls` indicates
 * whether the native media controls should be shown or hidden.
 *
 * @method Html5#controls
 * @return {boolean}
 *         - The value of `controls` from the media element.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
 */
'controls',

/**
 * Get the value of `loop` from the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#loop
 * @return {boolean}
 *         - The value of `loop` from the media element.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Get the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#playsinline
 * @return {boolean}
 *         - The value of `playsinline` from the media element.
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});

// Wrap native boolean attributes with setters that set both property and attribute
// The list is as followed:
// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline
// setControls is special-cased above
[
/**
 * Set the value of `muted` on the media element. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Html5#setMuted
 * @param {boolean} muted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
 * audio level should be silent, but will only effect the muted level on intial playback..
 *
 * @method Html5.prototype.setDefaultMuted
 * @param {boolean} defaultMuted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Set the value of `autoplay` on the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#setAutoplay
 * @param {boolean} autoplay
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Set the value of `loop` on the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#setLoop
 * @param {boolean} loop
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Set the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#setPlaysinline
 * @param {boolean} playsinline
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;

    if (v) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});

// Wrap native properties with a getter
// The list is as followed
// paused, currentTime, buffered, volume, poster, preload, error, seeking
// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState
// readyState, videoWidth, videoHeight
[
/**
 * Get the value of `paused` from the media element. `paused` indicates whether the media element
 * is currently paused or not.
 *
 * @method Html5#paused
 * @return {boolean}
 *         The value of `paused` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
 */
'paused',

/**
 * Get the value of `currentTime` from the media element. `currentTime` indicates
 * the current second that the media is at in playback.
 *
 * @method Html5#currentTime
 * @return {number}
 *         The value of `currentTime` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
 */
'currentTime',

/**
 * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
 * object that represents the parts of the media that are already downloaded and
 * available for playback.
 *
 * @method Html5#buffered
 * @return {TimeRange}
 *         The value of `buffered` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
 */
'buffered',

/**
 * Get the value of `volume` from the media element. `volume` indicates
 * the current playback volume of audio for a media. `volume` will be a value from 0
 * (silent) to 1 (loudest and default).
 *
 * @method Html5#volume
 * @return {number}
 *         The value of `volume` from the media element. Value will be between 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Get the value of `poster` from the media element. `poster` indicates
 * that the url of an image file that can/will be shown when no media data is available.
 *
 * @method Html5#poster
 * @return {string}
 *         The value of `poster` from the media element. Value will be a url to an
 *         image.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
 */
'poster',

/**
 * Get the value of `preload` from the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#preload
 * @return {string}
 *         The value of `preload` from the media element. Will be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Get the value of the `error` from the media element. `error` indicates any
 * MediaError that may have occured during playback. If error returns null there is no
 * current error.
 *
 * @method Html5#error
 * @return {MediaError|null}
 *         The value of `error` from the media element. Will be `MediaError` if there
 *         is a current error and null otherwise.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
 */
'error',

/**
 * Get the value of `seeking` from the media element. `seeking` indicates whether the
 * media is currently seeking to a new position or not.
 *
 * @method Html5#seeking
 * @return {boolean}
 *         - The value of `seeking` from the media element.
 *         - True indicates that the media is currently seeking to a new position.
 *         - Flase indicates that the media is not seeking to a new position at this time.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
 */
'seeking',

/**
 * Get the value of `seekable` from the media element. `seekable` returns a
 * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
 *
 * @method Html5#seekable
 * @return {TimeRange}
 *         The value of `seekable` from the media element. A `TimeRange` object
 *         indicating the current ranges of time that can be seeked to.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
 */
'seekable',

/**
 * Get the value of `ended` from the media element. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Html5#ended
 * @return {boolean}
 *         - The value of `ended` from the media element.
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */
'ended',

/**
 * Get the value of `playbackRate` from the media element. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
 * the rate at which the media is currently playing back. This value will not indicate the current
 * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
 *
 * Examples:
 *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
 *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.defaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'defaultPlaybackRate',

/**
 * Get the value of `played` from the media element. `played` returns a `TimeRange`
 * object representing points in the media timeline that have been played.
 *
 * @method Html5#played
 * @return {TimeRange}
 *         The value of `played` from the media element. A `TimeRange` object indicating
 *         the ranges of time that have been played.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
 */
'played',

/**
 * Get the value of `networkState` from the media element. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Html5#networkState
 * @return {number}
 *         The value of `networkState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
 */
'networkState',

/**
 * Get the value of `readyState` from the media element. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Html5#readyState
 * @return {number}
 *         The value of `readyState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
 */
'readyState',

/**
 * Get the value of `videoWidth` from the video element. `videoWidth` indicates
 * the current width of the video in css pixels.
 *
 * @method Html5#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoWidth',

/**
 * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
 * the current height of the video in css pixels.
 *
 * @method Html5#videoHeight
 * @return {number}
 *         The value of `videoHeight` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoHeight'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop];
  };
});

// Wrap native properties with a setter in this format:
// set + toTitleCase(name)
// The list is as follows:
// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate
[
/**
 * Set the value of `volume` on the media element. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Html5#setVolume
 * @param {number} percentAsDecimal
 *        The volume percent as a decimal. Valid range is from 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Set the value of `src` on the media element. `src` indicates the current
 * {@link Tech~SourceObject} for the media.
 *
 * @method Html5#setSrc
 * @param {Tech~SourceObject} src
 *        The source object to set as the current source.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
 */
'src',

/**
 * Set the value of `poster` on the media element. `poster` is the url to
 * an image file that can/will be shown when no media data is available.
 *
 * @method Html5#setPoster
 * @param {string} poster
 *        The url to an image that should be used as the `poster` for the media
 *        element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
 */
'poster',

/**
 * Set the value of `preload` on the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#setPreload
 * @param {string} preload
 *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Set the value of `playbackRate` on the media element. `playbackRate` indicates
 * the rate at which the media should play back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#setPlaybackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
 * the rate at which the media should play back upon initial startup. Changing this value
 * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
 *
 * Example Values:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.setDefaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
 */
'defaultPlaybackRate'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;
  };
});

// wrap native functions with a function
// The list is as follows:
// pause, load play
[
/**
 * A wrapper around the media elements `pause` function. This will call the `HTML5`
 * media elements `pause` function.
 *
 * @method Html5#pause
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
 */
'pause',

/**
 * A wrapper around the media elements `load` function. This will call the `HTML5`s
 * media element `load` function.
 *
 * @method Html5#load
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
 */
'load',

/**
 * A wrapper around the media elements `play` function. This will call the `HTML5`s
 * media element `play` function.
 *
 * @method Html5#play
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
 */
'play'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop]();
  };
});

Tech.withSourceHandlers(Html5);

/**
 * Native source handler for Html5, simply passes the source to the media element.
 *
 * @proprety {Tech~SourceObject} source
 *        The source object
 *
 * @proprety {Html5} tech
 *        The instance of the HTML5 tech.
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the media element can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  console.log('Html5.canPlayType', type);
  setTimeout(function () {
    console.log('Html5.canPlayType', type);
  }, 2000);
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string).
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);

    // If no type, fall back to checking 'video/[EXTENSION]'
  } else if (source.src) {
    var ext = getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the native media element.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Html5} tech
 *        The instance of the Html5 tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * A noop for the native dispose function, as cleanup is not needed.
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

Tech.registerTech('Html5', Html5);

var _templateObject$1 = taggedTemplateLiteralLoose(['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      '], ['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      ']);

/**
 * @file player.js
 */
// Subclasses Component
var TECH_EVENTS_RETRIGGER = [
/**
 * Fired while the user agent is downloading media data.
 *
 * @event Player#progress
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `progress` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechProgress_
 * @fires Player#progress
 * @listens Tech#progress
 */
'progress',

/**
 * Fires when the loading of an audio/video is aborted.
 *
 * @event Player#abort
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `abort` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechAbort_
 * @fires Player#abort
 * @listens Tech#abort
 */
'abort',

/**
 * Fires when the browser is intentionally not getting media data.
 *
 * @event Player#suspend
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `suspend` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechSuspend_
 * @fires Player#suspend
 * @listens Tech#suspend
 */
'suspend',

/**
 * Fires when the current playlist is empty.
 *
 * @event Player#emptied
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `emptied` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechEmptied_
 * @fires Player#emptied
 * @listens Tech#emptied
 */
'emptied',
/**
 * Fires when the browser is trying to get media data, but data is not available.
 *
 * @event Player#stalled
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechStalled_
 * @fires Player#stalled
 * @listens Tech#stalled
 */
'stalled',

/**
 * Fires when the browser has loaded meta data for the audio/video.
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoadedmetadata_
 * @fires Player#loadedmetadata
 * @listens Tech#loadedmetadata
 */
'loadedmetadata',

/**
 * Fires when the browser has loaded the current frame of the audio/video.
 *
 * @event Player#loadeddata
 * @type {event}
 */
/**
 * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoaddeddata_
 * @fires Player#loadeddata
 * @listens Tech#loadeddata
 */
'loadeddata',

/**
 * Fires when the current playback position has changed.
 *
 * @event Player#timeupdate
 * @type {event}
 */
/**
 * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTimeUpdate_
 * @fires Player#timeupdate
 * @listens Tech#timeupdate
 */
'timeupdate',

/**
 * Fires when the playing speed of the audio/video is changed
 *
 * @event Player#ratechange
 * @type {event}
 */
/**
 * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechRatechange_
 * @fires Player#ratechange
 * @listens Tech#ratechange
 */
'ratechange',

/**
 * Fires when the video's intrinsic dimensions change
 *
 * @event Player#resize
 * @type {event}
 */
/**
 * Retrigger the `resize` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechResize_
 * @fires Player#resize
 * @listens Tech#resize
 */
'resize',

/**
 * Fires when the volume has been changed
 *
 * @event Player#volumechange
 * @type {event}
 */
/**
 * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechVolumechange_
 * @fires Player#volumechange
 * @listens Tech#volumechange
 */
'volumechange',

/**
 * Fires when the text track has been changed
 *
 * @event Player#texttrackchange
 * @type {event}
 */
/**
 * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTexttrackchange_
 * @fires Player#texttrackchange
 * @listens Tech#texttrackchange
 */
'texttrackchange'];

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods
 * are used to initialize a video.
 *
 * After an instance has been created it can be accessed globally in two ways:
 * 1. By calling `videojs('example_video_1');`
 * 2. By using it directly via  `videojs.players.example_video_1;`
 *
 * @extends Component
 */

var Player = function (_Component) {
  inherits(Player, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Ready callback function.
   */
  function Player(tag, options, ready) {
    classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = assign(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // don't auto mixin the evented mixin
    options.evented = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');

        if (closest && closest.getAttribute) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;

        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options

    // Turn off API access because we're loading a new tech that might load asynchronously
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.isReady_ = false;

    // Init state hasStarted_
    _this.hasStarted_ = false;

    // Init state userActive_
    _this.userActive_ = false;

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    // Store the original tag used to set options
    _this.tag = tag;

    // Store the tag attributes used to restore html5 element
    _this.tagAttributes = tag && getAttributes(tag);

    // Update current language
    _this.language(_this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      // Normalise player option languages to lowercase
      var languagesToLower = {};

      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {
        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    _this.cache_ = {};

    // Set poster
    _this.poster_ = options.poster || '';

    // Set controls
    _this.controls_ = !!options.controls;

    // Set default values for lastVolume
    _this.cache_.lastVolume = 1;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;
    tag.removeAttribute('controls');

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    _this.scrubbing_ = false;

    _this.el_ = _this.createEl();

    // Make this an evented object and use `el_` as its event bus.
    evented(_this, { eventBusKey: 'el_' });

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = mergeOptions(_this.options_);

    // Load plugins
    if (options.plugins) {
      var plugins = options.plugins;

      Object.keys(plugins).forEach(function (name$$1) {
        if (typeof this[name$$1] === 'function') {
          this[name$$1](plugins[name$$1]);
        } else {
          throw new Error('plugin "' + name$$1 + '" does not exist');
        }
      }, _this);
    }

    _this.options_.playerOptions = playerOptionsCopy;

    _this.middleware_ = [];

    _this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (_this.controls()) {
      _this.addClass('vjs-controls-enabled');
    } else {
      _this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    _this.el_.setAttribute('role', 'region');
    if (_this.isAudio()) {
      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
    } else {
      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
    }

    if (_this.isAudio()) {
      _this.addClass('vjs-audio');
    }

    if (_this.flexNotSupported_()) {
      _this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari & Android has broken hover handling
    if (!IS_IOS && !IS_ANDROID) {
      _this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[_this.id_] = _this;

    // Add a major version class to aid css in plugins
    // const majorVersion = version.split('.')[0];
    //
    // this.addClass(`vjs-v${majorVersion}`);

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    _this.userActive(true);
    _this.reportUserActivity();
    _this.listenForUserActivity_();

    _this.on('fullscreenchange', _this.handleFullscreenChange_);
    _this.on('stageclick', _this.handleStageClick_);

    _this.changingSrc_ = false;
    _this.playWaitingForReady_ = false;
    _this.playOnLoadstart_ = null;

    _this.forceAutoplayInChrome_();
    return _this;
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */


  Player.prototype.dispose = function dispose() {
    /**
     * Called when the player is being disposed of.
     *
     * @event Player#dispose
     * @type {EventTarget~Event}
     */
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }

    // Kill reference to this player
    Player.players[this.id_] = null;

    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }

    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
    }

    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }

    if (this.tag) {
      this.tag = null;
    }

    // the actual .el_ is removed here
    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  Player.prototype.createEl = function createEl$$1() {
    var tag = this.tag;
    var el = void 0;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');
    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';

    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    }

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = getAttributes(tag);

    if (divEmbed) {
      el = this.el_ = tag;
      tag = this.tag = document_1.createElement('video');
      while (el.children.length) {
        tag.appendChild(el.firstChild);
      }

      if (!hasClass(el, 'video-js')) {
        addClass(el, 'video-js');
      }

      el.appendChild(tag);

      playerElIngest = this.playerElIngest_ = el;
    }

    // set tabindex to -1 so we could focus on the player element
    tag.setAttribute('tabindex', '-1');

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className += ' ' + attrs[attr];

        if (divEmbed) {
          tag.className += ' ' + attrs[attr];
        }
      } else {
        el.setAttribute(attr, attrs[attr]);

        if (divEmbed) {
          tag.setAttribute(attr, attrs[attr]);
        }
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = $('.vjs-styles-defaults');
      var head = $('head');

      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');

    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);

      addClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    //
    // Breaks iPhone, fixed in HTML5 setup.
    prependTo(tag, el);
    this.children_.unshift(tag);

    // Set lang attr on player to ensure CSS :lang() in consistent with player
    // if it's been set to something different to the doc
    this.el_.setAttribute('lang', this.language_);

    this.el_ = el;

    return el;
  };

  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s width to.
   *
   * @param {boolean} [skipListeners]
   *        Skip the playerresize event trigger
   *
   * @return {number}
   *         The current width of the `Player` when getting.
   */


  Player.prototype.width = function width(value, skipListeners) {
    return this.dimension('width', value, skipListeners);
  };

  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s heigth to.
   *
   * @param {boolean} [skipListeners]
   *        Skip the playerresize event trigger
   *
   * @return {number}
   *         The current height of the `Player` when getting.
   */


  Player.prototype.height = function height(value, skipListeners) {
    return this.dimension('height', value, skipListeners);
  };

  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @fires Player#playerresize
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number} [value]
   *        Value for dimension specified in the first argument.
   *
   * @param {boolean} [skipListeners]
   *        Skip the playerresize event trigger
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */


  Player.prototype.dimension = function dimension(_dimension, value, skipListeners) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
      this.updateStyleEl_();
      return;
    }

    var parsedVal = parseFloat(value);

    if (isNaN(parsedVal)) {
      log$2.error('Improper value "' + value + '" supplied for for ' + _dimension);
      return;
    }

    this[privDimension] = parsedVal;
    this.updateStyleEl_();

    // skipListeners allows us to avoid triggering the resize event when setting both width and height
    if (this.isReady_ && !skipListeners) {
      /**
       * Triggered when the player is resized.
       *
       * @event Player#playerresize
       * @type {EventTarget~Event}
       */
      this.trigger('playerresize');
    }
  };

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will toggle the fluid class.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */


  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }

    this.updateStyleEl_();
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player's aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */


  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */


  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = void 0;
    var height = void 0;
    var aspectRatio = void 0;
    var idClass = void 0;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */


  Player.prototype.loadTech_ = function loadTech_(techName, source) {
    var _this2 = this;

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    var titleTechName = toTitleCase(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (titleTechName !== 'Html5' && this.tag) {
      Tech.getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = titleTechName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = {
      source: source,
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'playerId': this.id(),
      'techId': this.id() + '_' + titleTechName + '_api',
      'autoplay': this.options_.autoplay,
      'playsinline': this.options_.playsinline,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'playerElIngest': this.playerElIngest_ || false,
      'vtt.js': this.options_['vtt.js'],
      'swf': this.options_['swf'],
      'hlsConfig': this.options_['hlsConfig'],
      'dashConfig': this.options_['dashConfig'],
      'flvConfig': this.options_['flvConfig'],
      'webrtcConfig': this.options_['webrtcConfig']
    };

    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      techOptions[props.getterName] = _this2[props.privateName];
    });

    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }

    // Initialize tech instance
    var TechClass = Tech.getTech(techName);

    if (!TechClass) {
      throw new Error('No Tech named \'' + titleTechName + '\' exists! \'' + titleTechName + '\' should be registered using videojs.registerTech()\'');
    }

    this.tech_ = new TechClass(this, techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(bind(this, this.handleTechReady_), true);

    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);
    });
    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);
    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);
    this.on(this.tech_, 'playing', this.handleTechPlaying_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'seeked', this.handleTechSeeked_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);
    this.on(this.tech_, 'x5videoexitfullscreen', this.handleX5ExitFullscreen_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */


  Player.prototype.unloadTech_ = function unloadTech_() {
    var _this3 = this;

    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      _this3[props.privateName] = _this3[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;
  };

  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */


  Player.prototype.tech = function tech(safety) {
    if (safety === undefined) {
      log$2.warn(tsml(_templateObject$1));
    }

    return this.tech_;
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */


  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    if (!this.tech_) {
      return;
    }
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    // webkitEnterFullscreen 全屏后会出现点击video 暂停又播放的情况
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */


  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    if (!this.tech_) {
      return;
    }
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @private
   */


  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        // Chrome Fix. Fixed in Chrome v16.
        delete this.tag.poster;
      } catch (e) {
        log$2('deleting tag.poster throws in some browsers', e);
      }
    }
  };

  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This
   * function will also trigger {@link Player#firstplay} if it is the first loadstart
   * for a video.
   *
   * @fires Player#loadstart
   * @fires Player#firstplay
   * @listens Tech#loadstart
   * @private
   */


  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');
    this.removeClass('vjs-seeking');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      /**
       * Fired when the user agent begins looking for media data
       *
       * @event Player#loadstart
       * @type {EventTarget~Event}
       */
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @fires Player#firstplay
   *
   * @param {boolean} request
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted_
   */


  Player.prototype.hasStarted = function hasStarted(request) {
    if (request === undefined) {
      // act as getter, if we have no request to change
      return this.hasStarted_;
    }

    if (request === this.hasStarted_) {
      return;
    }

    this.hasStarted_ = request;

    if (this.hasStarted_) {
      this.addClass('vjs-has-started');
      this.trigger('firstplay');
    } else {
      this.removeClass('vjs-has-started');
    }
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */


  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    this.hasStarted(true);
    /**
     * Triggered whenever an {@link Tech#play} event happens. Indicates that
     * playback has started or resumed.
     *
     * @event Player#play
     * @type {EventTarget~Event}
     */
    this.trigger('play');
  };

  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */


  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this4 = this;

    this.addClass('vjs-waiting');
    /**
     * A readyState change on the DOM element has caused playback to stop.
     *
     * @event Player#waiting
     * @type {EventTarget~Event}
     */
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this4.removeClass('vjs-waiting');
    });
  };

  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */


  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_FUTURE_DATA or greater.
     *
     * @event Player#canplay
     * @type {EventTarget~Event}
     */
    this.trigger('canplay');
  };

  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */


  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
     * entire media file can be played without buffering.
     *
     * @event Player#canplaythrough
     * @type {EventTarget~Event}
     */
    this.trigger('canplaythrough');
  };

  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */


  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    /**
     * The media is no longer blocked from playback, and has started playing.
     *
     * @event Player#playing
     * @type {EventTarget~Event}
     */
    this.trigger('playing');
  };

  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */


  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    /**
     * Fired whenever the player is jumping to a new time
     *
     * @event Player#seeking
     * @type {EventTarget~Event}
     */
    this.trigger('seeking');
  };

  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */


  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    /**
     * Fired when the player has finished jumping to a new time
     *
     * @event Player#seeked
     * @type {EventTarget~Event}
     */
    this.trigger('seeked');
  };

  /**
   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.
   *
   * @fires Player#firstplay
   * @listens Tech#firstplay
   * @deprecated As of 6.0 firstplay event is deprecated.
   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.
   * @private
   */


  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    // If the first starttime attribute is specified
    // then we will start at the given offset in seconds
    if (this.options_.starttime) {
      log$2.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    /**
     * Fired the first time a video is played. Not part of the HLS spec, and this is
     * probably not the best implementation yet, so use sparingly. If you don't have a
     * reason to prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event Player#firstplay
     * @deprecated As of 6.0 firstplay event is deprecated.
     * @type {EventTarget~Event}
     */
    this.trigger('firstplay');
  };

  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */


  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    /**
     * Fired whenever the media has been paused
     *
     * @event Player#pause
     * @type {EventTarget~Event}
     */
    this.trigger('pause');
  };

  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */


  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     *
     * @event Player#ended
     * @type {EventTarget~Event}
     */
    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */


  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {EventTarget~Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#mousedown
   * @private
   */


  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    // console.log('handleTechClick_', event, this.tech(true).el().webkitDisplayingFullscreen)
    if (!isSingleLeftClick(event)) {
      return;
    }

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    // 如果在桌面端强制调用 webkitDisplayingFullscreen ，全屏后会出现点击后暂停又播放的问题，这里需要屏蔽mousedown 的处理逻辑，避免和原生click逻辑冲突 || this.tech(true).el().webkitDisplayingFullscreen
    if (!this.controls_) {
      return;
    }

    if (this.paused()) {
      this.play();
    } else {
      this.pause();
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */


  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */


  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */


  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @param {EventTarget~Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */


  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @listens Player#fullscreenchange
   */


  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    // iOS 增加.vjs-fullscreen的样式，播放 mediaStream (webrtc)场景下画面会静止
    if (IS_IOS) {
      return;
    }
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @listens stageclick
   */


  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * @private
   */


  Player.prototype.toggleFullscreenClass_ = function toggleFullscreenClass_() {
    if (IS_IOS) {
      return;
    }
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * when the document fschange event triggers it calls this
   */


  Player.prototype.documentFullscreenChange_ = function documentFullscreenChange_(e) {
    var fsApi = FullscreenApi;

    this.isFullscreen(document_1[fsApi.fullscreenElement]);

    // If cancelling fullscreen, remove event listener.
    if (this.isFullscreen() === false) {
      off(document_1, fsApi.fullscreenchange, bind(this, this.documentFullscreenChange_));
    }

    if (!prefixedAPI) {
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @param {EventTarget~Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */


  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    /**
     * Fired when going in and out of fullscreen.
     *
     * @event Player#fullscreenchange
     * @type {EventTarget~Event}
     */
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */


  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();

    this.error(error);
  };

  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */


  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;

    if (arguments.length > 1) {
      data = arguments[1];
    }

    /**
     * Fires when we get a textdata event from tech
     *
     * @event Player#textdata
     * @type {EventTarget~Event}
     */
    this.trigger('textdata', data);
  };

  Player.prototype.handleX5ExitFullscreen_ = function handleX5ExitFullscreen_() {
    this.removeClass('vjs-fullscreen');
    this.isFullscreen_ = !this.isFullscreen_;
  };
  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */


  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} arg
   *        the argument to pass
   *
   * @private
   */


  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is

    this.ready(function () {
      if (method in allowedSetters) {
        return set$1(this.middleware_, this.tech_, method, arg);
      }

      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$2(e);
        throw e;
      }
    }, true);
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {Function|undefined}
   *         the method or undefined
   *
   * @private
   */


  Player.prototype.techGet_ = function techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }

    if (method in allowedGetters) {
      return get$1(this.middleware_, this.tech_, method);
    }

    // Flash likes to die and reload when you hide or reposition it.
    // In these cases the object methods go away and we get errors.
    // When that happens we'll catch the errors and inform tech that it's not ready any more.
    try {
      return this.tech_[method]();
    } catch (e) {

      // When building additional tech libs, an expected method may not be defined yet
      if (this.tech_[method] === undefined) {
        log$2('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);
        throw e;
      }

      // When a method isn't available on the object it throws a TypeError
      if (e.name === 'TypeError') {
        log$2('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
        this.tech_.isReady_ = false;
        throw e;
      }

      // If error unknown, just log and throw
      log$2(e);
      throw e;
    }
  };

  /**
   * Attempt to begin playback at the first opportunity.
   *
   * @return {Promise|undefined}
   *         Returns a `Promise` only if the browser returns one and the player
   *         is ready to begin playback. For some browsers and all non-ready
   *         situations, this will return `undefined`.
   */


  Player.prototype.play = function play() {
    var _this5 = this;

    // If this is called while we have a play queued up on a loadstart, remove
    // that listener to avoid getting in a potentially bad state.
    if (this.playOnLoadstart_) {
      this.off('loadstart', this.playOnLoadstart_);
    }

    // If the player/tech is not ready, queue up another call to `play()` for
    // when it is. This will loop back into this method for another attempt at
    // playback when the tech is ready.
    if (!this.isReady_) {

      // Bail out if we're already waiting for `ready`!
      if (this.playWaitingForReady_) {
        return;
      }

      this.playWaitingForReady_ = true;
      this.ready(function () {
        _this5.playWaitingForReady_ = false;
        silencePromise(_this5.play());
      });

      // If the player/tech is ready and we have a source, we can attempt playback.
    } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {
      return this.techGet_('play');

      // If the tech is ready, but we do not have a source, we'll need to wait
      // for both the `ready` and a `loadstart` when the source is finally
      // resolved by middleware and set on the player.
      //
      // This can happen if `play()` is called while changing sources or before
      // one has been set on the player.
    } else {

      this.playOnLoadstart_ = function () {
        _this5.playOnLoadstart_ = null;
        silencePromise(_this5.play());
      };

      this.one('loadstart', this.playOnLoadstart_);
    }
  };

  /**
   * Pause the video playback
   *
   * @return {Player}
   *         A reference to the player object this function was called on
   */


  Player.prototype.pause = function pause() {
    this.techCall_('pause');
  };

  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */


  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */


  Player.prototype.played = function played() {
    return this.techGet_('played') || createTimeRanges(0, 0);
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        wether the user is or is not scrubbing
   *
   * @return {boolean}
   *         The value of scrubbing when getting
   */


  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === 'undefined') {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;

    if (isScrubbing) {
      this.addClass('vjs-scrubbing');
    } else {
      this.removeClass('vjs-scrubbing');
    }
  };

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number}
   *         - the current time in seconds when getting
   */


  Player.prototype.currentTime = function currentTime(seconds) {
    if (typeof seconds !== 'undefined') {
      if (seconds < 0) {
        seconds = 0;
      }
      this.techCall_('setCurrentTime', seconds);
      return;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    this.cache_.currentTime = this.techGet_('currentTime') || 0;
    return this.cache_.currentTime;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number}
   *         - The duration of the video in seconds when getting
   */


  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      // return NaN if the duration is not known
      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
    }

    seconds = parseFloat(seconds);

    // Standardize on Inifity for signaling video is live
    if (seconds <= 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }
      /**
       * @event Player#durationchange
       * @type {EventTarget~Event}
       */
      this.trigger('durationchange');
    }
  };

  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */


  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  /**
   * A remaining time function that is intented to be used when
   * the time is to be displayed directly to the user.
   *
   * @return {number}
   *         The rounded time remaining in seconds
   */


  Player.prototype.remainingTimeDisplay = function remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  };

  //
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock TimeRange object (following HTML spec)
   */


  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is bufferred 0 being 0% and 1 being 100%
   */


  Player.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */


  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration = this.duration();
    var end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */


  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = void 0;

    if (percentAsDecimal !== undefined) {
      // Force value to between 0 and 1
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      if (vol > 0) {
        this.lastVolume_(vol);
      }

      return;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */


  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return;
    }
    return this.techGet_('muted') || false;
  };

  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on intial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|Player}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - A reference to the current player when setting
   */


  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== undefined) {
      return this.techCall_('setDefaultMuted', _defaultMuted);
    }
    return this.techGet_('defaultMuted') || false;
  };

  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         the current value of lastVolume as a percent when getting
   *
   * @private
   */


  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };

  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS, so not our flash swf)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */


  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   */


  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      this.toggleFullscreenClass_();
      return;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      console.warn('support fullscreen api', fsApi.requestFullscreen);
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      // Events.on(document, fsApi.fullscreenchange, Fn.bind(this, function documentFullscreenChange(e) {
      //   this.isFullscreen(document[fsApi.fullscreenElement]);
      //
      //   // If cancelling fullscreen, remove event listener.
      //   if (this.isFullscreen() === false) {
      //     Events.off(document, fsApi.fullscreenchange, documentFullscreenChange);
      //   }
      //   /**
      //    * @event Player#fullscreenchange
      //    * @type {EventTarget~Event}
      //    */
      //   this.trigger('fullscreenchange');
      // }));

      on(document_1, fsApi.fullscreenchange, bind(this, this.documentFullscreenChange_));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      console.warn('not support fullscreen api, enter video fullscreen');
      this.techCall_('enterFullScreen');
    } else {
      console.warn('not support fullscreen api, enter full window');
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      document_1[fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */


  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = document_1.documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    on(document_1, 'keydown', bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    document_1.documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    addClass(document_1.body, 'vjs-full-window');

    /**
     * @event Player#enterFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */


  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */


  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    off(document_1, 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    document_1.documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    removeClass(document_1.body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    /**
     * @event Player#exitFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */


  Player.prototype.canPlayType = function canPlayType(type) {
    console.log('canPlayType', type);
    var can = void 0;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = Component.getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        log$2.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */


  Player.prototype.selectSource = function selectSource(sources) {
    var _this6 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(function (techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0],
          tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      log$2.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = void 0;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = void 0;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0],
          tech = _ref2[1];

      if (tech.canPlaySource(source, _this6.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */


  Player.prototype.src = function src(source) {
    var _this7 = this;

    // getter usage
    if (typeof source === 'undefined') {
      // master
      // return this.cache_.src || '';
      return this.cache_.src || this.techGet_('src');
    }
    // filter out invalid sources and turn our source into
    // an array of source objects
    var sources = filterSource(source);

    // if a source was passed in then it is invalid because
    // it was filtered to a zero length Array. So we have to
    // show an error
    if (!sources.length) {
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);
      return;
    }

    // 切换清晰度，webrtc场景需要额外处理，调用txliveplayer里的switchstream方法
    // 新旧地址都是 webrtc 且不相等
    // 无法放到webrtc.js的handleSource里，在进入handleSource前就会disposeSourceHandler中销毁实例
    if (this.cache_.source && isWebrtcUrl(this.cache_.source.src) && isWebrtcUrl(sources[0].src) && this.cache_.source.src !== sources[0].src) {
      var provider = this.tech_.webrtcProvider;
      if (provider && provider.webrtcPlayer && provider.webrtcPlayer.switchStream) {
        this.tech_.webrtcProvider.webrtcPlayer.switchStream(sources[0].src);
        this.cache_.sources = sources;
        this.cache_.source = sources[0];
        return false;
      }
    }

    this.cache_.sources = sources;
    this.changingSrc_ = true;
    // intial source
    this.cache_.source = sources[0];

    // 非webrtc场景，监听自动播放被阻止事件
    try {
      if (this.cache_.source && !isWebrtcUrl(this.cache_.source.src)) {
        if (this.options_.autoplay) {
          setTimeout(function () {
            _this7.play && _this7.play().then()['catch'](function () {
              _this7.trigger('blocked');
            });
          }, 1000);
        }
      }
    } catch (e) {
      console.log('err', e);
    }

    // middlewareSource is the source after it has been changed by middleware
    setSource(this, sources[0], function (middlewareSource, mws) {
      _this7.middleware_ = mws;

      var err = _this7.src_(middlewareSource);

      if (err) {
        if (sources.length > 1) {
          return _this7.src(sources.slice(1));
        }

        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        _this7.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        _this7.triggerReady();

        return;
      }

      _this7.changingSrc_ = false;
      // video element listed source
      _this7.cache_.src = middlewareSource.src;

      setTech(mws, _this7.tech_);
    });
  };

  /**
   * Set the source object on the tech, returns a boolean that indicates wether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {Boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */


  Player.prototype.src_ = function src_(source) {
    var sourceTech = this.selectSource([source]);
    console.log('src_', sourceTech);
    if (!sourceTech) {
      return true;
    }

    window_1.performance && window_1.performance.mark('firstFrameStart');
    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;

      // load this technology with the chosen source
      this.loadTech_(sourceTech.tech, sourceTech.source);
      return false;
    }

    // wait until the tech is ready to set the source
    this.ready(function () {
      // The setSource tech method was added with source handlers
      // so older techs won't support it
      // We need to check the direct prototype for the case where subclasses
      // of the tech do not support source handlers
      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
        this.techCall_('setSource', source);
      } else {
        this.techCall_('src', source.src);
      }

      if (this.options_.preload === 'auto') {
        this.load();
      }

      // Set the source synchronously if possible (#2326)
    }, true);

    return false;
  };

  /**
   * Begin loading the src data.
   */


  Player.prototype.load = function load() {
    this.techCall_('load');
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   */


  Player.prototype.reset = function reset() {
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_('reset');
  };

  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */


  Player.prototype.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];

    // assume `{}` or `{ src }`
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }

    return this.cache_.sources || sources;
  };

  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */


  Player.prototype.currentSource = function currentSource() {
    return this.cache_.source || {};
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */


  Player.prototype.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */


  Player.prototype.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {boolean} [value]
   *        - true means that we should preload
   *        - false maens that we should not preload
   *
   * @return {string}
   *         The preload attribute value when getting
   */


  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {boolean} [value]
   *        - true means that we should autoplay
   *        - false means that we should not autoplay
   *
   * @return {string}
   *         The current value of autoplay when getting
   */


  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      this.ready(this.forceAutoplayInChrome_);
      return;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * chrome started pausing the video when moving in the DOM
   * causing autoplay to not continue due to how Video.js functions.
   * See #4720 for more info.
   *
   * @private
   */


  Player.prototype.forceAutoplayInChrome_ = function forceAutoplayInChrome_() {
    if (this.paused() && (
    // read from the video element or options
    this.autoplay() || this.options_.autoplay) &&
    // only target desktop chrome
    IS_CHROME && !IS_ANDROID) {
      this.play();
    }
  };

  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|Player}
   *         - the current value of playsinline
   *         - the player when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Player.prototype.playsinline = function playsinline(value) {
    if (value !== undefined) {
      this.techCall_('setPlaysinline', value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_('playsinline');
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {string}
   *         The current value of loop when getting
   */


  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string}
   *         The current value of poster when getting
   */


  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    // video poster 在切换src会有图像残留问题，因此注释。
    // this.techCall_('setPoster', src);

    // alert components that the poster has been set
    /**
     * This event fires when the poster image is changed on the player.
     *
     * @event Player#posterchange
     * @type {EventTarget~Event}
     */
    this.trigger('posterchange');
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */


  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if (!this.poster_ && this.tech_ && this.tech_.poster) {
      this.poster_ = this.tech_.poster() || '';

      // Let components know the poster has changed
      this.trigger('posterchange');
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean}
   *         The current value of controls when getting
   */


  Player.prototype.controls = function controls(bool) {
    if (bool === undefined) {
      return !!this.controls_;
    }

    bool = !!bool;

    // Don't trigger a change event unless it actually changed
    if (this.controls_ === bool) {
      return;
    }

    this.controls_ = bool;

    if (this.usingNativeControls()) {
      this.techCall_('setControls', bool);
    }

    if (this.controls_) {
      this.removeClass('vjs-controls-disabled');
      this.addClass('vjs-controls-enabled');
      /**
       * @event Player#controlsenabled
       * @type {EventTarget~Event}
       */
      this.trigger('controlsenabled');
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass('vjs-controls-enabled');
      this.addClass('vjs-controls-disabled');
      /**
       * @event Player#controlsdisabled
       * @type {EventTarget~Event}
       */
      this.trigger('controlsdisabled');
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean}
   *         The current value of native controls when getting
   */


  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool === undefined) {
      return !!this.usingNativeControls_;
    }

    bool = !!bool;

    // Don't trigger a change event unless it actually changed
    if (this.usingNativeControls_ === bool) {
      return;
    }

    this.usingNativeControls_ = bool;

    if (this.usingNativeControls_) {
      this.addClass('vjs-using-native-controls');

      /**
       * player is using the native device controls
       *
       * @event Player#usingnativecontrols
       * @type {EventTarget~Event}
       */
      this.trigger('usingnativecontrols');
    } else {
      this.removeClass('vjs-using-native-controls');

      /**
       * player is using the custom HTML controls
       *
       * @event Player#usingcustomcontrols
       * @type {EventTarget~Event}
       */
      this.trigger('usingcustomcontrols');
    }
  };

  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null}
   *         The current MediaError when getting (or null)
   */


  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }

    this.error_ = new MediaError(err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    log$2.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    /**
     * @event Player#error
     * @type {EventTarget~Event}
     */
    this.trigger({ type: 'error', data: this.error_ });

    return;
  };

  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */


  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean}
   *         The current value of userActive when getting
   */


  Player.prototype.userActive = function userActive(bool) {
    if (bool === undefined) {
      return this.userActive_;
    }

    bool = !!bool;

    if (bool === this.userActive_) {
      return;
    }

    this.userActive_ = bool;

    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass('vjs-user-inactive');
      this.addClass('vjs-user-active');
      /**
       * @event Player#useractive
       * @type {EventTarget~Event}
       */
      this.trigger('useractive');
      return;
    }

    // Chrome/Safari/IE have bugs where when you change the cursor it can
    // trigger a mousemove event. This causes an issue when you're hiding
    // the cursor when the user is inactive, and a mousemove signals user
    // activity. Making it impossible to go into inactive mode. Specifically
    // this happens in fullscreen when we really need to hide the cursor.
    //
    // When this gets resolved in ALL browsers it can be removed
    // https://code.google.com/p/chromium/issues/detail?id=103041
    if (this.tech_) {
      this.tech_.one('mousemove', function (e) {
        e.stopPropagation();
        e.preventDefault();
      });
    }

    this.userActivity_ = false;
    this.removeClass('vjs-user-active');
    this.addClass('vjs-user-inactive');
    /**
     * @event Player#userinactive
     * @type {EventTarget~Event}
     */
    this.trigger('userinactive');
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */


  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = void 0;
    var lastMoveX = void 0;
    var lastMoveY = void 0;
    var handleActivity = bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = void 0;

    this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (!this.userActivity_) {
        return;
      }

      // Reset the activity tracker
      this.userActivity_ = false;

      // If the user state was inactive, set the state to active
      this.userActive(true);

      // Clear any existing inactivity timeout to start the timer over
      this.clearTimeout(inactivityTimeout);

      var timeout = this.options_.inactivityTimeout;

      if (timeout <= 0) {
        return;
      }

      // In <timeout> milliseconds, if no more activity has occurred the
      // user will be considered inactive
      inactivityTimeout = this.setTimeout(function () {
        // Protect against the case where the inactivityTimeout can trigger just
        // before the next user activity is picked up by the activity check loop
        // causing a flicker
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    }, 250);
  };

  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number}
   *         The current playback rate when getting or 1.0
   */


  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      this.techCall_('setPlaybackRate', rate);
      return;
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('playbackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|Player}
   *         - The default playback rate when getting or 1.0
   *         - the player when setting
   */


  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== undefined) {
      return this.techCall_('setDefaultPlaybackRate', rate);
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('defaultPlaybackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} bool
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean}
   *         The current value of isAudio when getting
   */


  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return;
    }

    return !!this.isAudio_;
  };

  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */


  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };

  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will
   * automatically removed from the video element whenever the source changes, unless
   * manualCleanup is set to false.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   * @deprecated The default value of the "manualCleanup" parameter will default
   *             to "false" in upcoming versions of Video.js
   */


  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };

  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */


  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$track = _ref3.track,
        track = _ref3$track === undefined ? arguments[0] : _ref3$track;

    // destructure the input into an object with a track argument, defaulting to arguments[0]
    // default the whole argument to an empty object if nothing was passed in

    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */


  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_('getVideoPlaybackQuality');
  };

  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */


  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */


  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string}
   *         The current language code when getting
   */


  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = String(code).toLowerCase();
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */


  Player.prototype.languages = function languages() {
    return mergeOptions(Player.prototype.options_.languages, this.languages_);
  };

  /**
   * returns a JavaScript object reperesenting the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */


  Player.prototype.toJSON = function toJSON() {
    var options = mergeOptions(this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = mergeOptions(track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */


  Player.prototype.createModal = function createModal(content, options) {
    var _this8 = this;

    options = options || {};
    options.content = content || '';

    var modal = new ModalDialog(this, options);

    this.addChild(modal);
    modal.on('dispose', function () {
      _this8.removeChild(modal);
    });

    modal.open();
    return modal;
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */


  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };

    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    if (hasClass(tag, 'vjs-fluid')) {
      tagOptions.fluid = true;
    }

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON
      // If empty string, make it a parsable json object.
      var _safeParseTuple = tuple(dataSetup || '{}'),
          err = _safeParseTuple[0],
          data = _safeParseTuple[1];

      if (err) {
        log$2.error(err);
      }
      assign(tagOptions, data);
    }

    assign(baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();

        if (childName === 'source') {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  /**
   * Determine wether or not flexbox is supported
   *
   * @return {boolean}
   *         - true if flexbox is supported
   *         - false if flexbox is not supported
   */


  Player.prototype.flexNotSupported_ = function flexNotSupported_() {
    var elem = document_1.createElement('i');

    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
    // common flex features that we can rely on when checking for flex support.
    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
    // IE10-specific (2012 flex spec)
    'msFlexOrder' in elem.style);
  };

  return Player;
}(Component);

/**
 * Get the {@link VideoTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * @return {VideoTrackList}
 *         the current video track list
 *
 * @method Player.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * @return {AudioTrackList}
 *         the current audio track list
 *
 * @method Player.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
 *
 * @return {TextTrackList}
 *         the current text track list
 *
 * @method Player.prototype.textTracks
 */

/**
 * Get the remote {@link TextTrackList}
 *
 * @return {TextTrackList}
 *         The current remote text track list
 *
 * @method Player.prototype.remoteTextTracks
 */

/**
 * Get the remote {@link HtmlTrackElementList} tracks.
 *
 * @return {HtmlTrackElementList}
 *         The current remote text track element list
 *
 * @method Player.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name$$1) {
  var props = ALL[name$$1];

  Player.prototype[props.getterName] = function () {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }

    // if we have not yet loadTech_, we create {video,audio,text}Tracks_
    // these will be passed to the tech during loading
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * Global player list
 *
 * @type {Object}
 */
Player.players = {};

var navigator$1 = window_1.navigator;

/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,

  html5: {},
  flash: {},

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings', 'videoStatisticPanel'],

  language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

[
/**
 * Returns whether or not the player is in the "ended" state.
 *
 * @return {Boolean} True if the player is in the ended state, false if not.
 * @method Player#ended
 */
'ended',
/**
 * Returns whether or not the player is in the "seeking" state.
 *
 * @return {Boolean} True if the player is in the seeking state, false if not.
 * @method Player#seeking
 */
'seeking',
/**
 * Returns the TimeRanges of the media that are currently available
 * for seeking to.
 *
 * @return {TimeRanges} the seekable intervals of the media timeline
 * @method Player#seekable
 */
'seekable',
/**
 * Returns the current state of network activity for the element, from
 * the codes in the list below.
 * - NETWORK_EMPTY (numeric value 0)
 *   The element has not yet been initialised. All attributes are in
 *   their initial states.
 * - NETWORK_IDLE (numeric value 1)
 *   The element's resource selection algorithm is active and has
 *   selected a resource, but it is not actually using the network at
 *   this time.
 * - NETWORK_LOADING (numeric value 2)
 *   The user agent is actively trying to download data.
 * - NETWORK_NO_SOURCE (numeric value 3)
 *   The element's resource selection algorithm is active, but it has
 *   not yet found a resource to use.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
 * @return {number} the current network activity state
 * @method Player#networkState
 */
'networkState',
/**
 * Returns a value that expresses the current state of the element
 * with respect to rendering the current playback position, from the
 * codes in the list below.
 * - HAVE_NOTHING (numeric value 0)
 *   No information regarding the media resource is available.
 * - HAVE_METADATA (numeric value 1)
 *   Enough of the resource has been obtained that the duration of the
 *   resource is available.
 * - HAVE_CURRENT_DATA (numeric value 2)
 *   Data for the immediate current playback position is available.
 * - HAVE_FUTURE_DATA (numeric value 3)
 *   Data for the immediate current playback position is available, as
 *   well as enough data for the user agent to advance the current
 *   playback position in the direction of playback.
 * - HAVE_ENOUGH_DATA (numeric value 4)
 *   The user agent estimates that enough data is available for
 *   playback to proceed uninterrupted.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
 * @return {number} the current playback rendering state
 * @method Player#readyState
 */
'readyState'].forEach(function (fn) {
  Player.prototype[fn] = function () {
    return this.techGet_(fn);
  };
});

TECH_EVENTS_RETRIGGER.forEach(function (event) {
  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {
    return this.trigger(event);
  };
});

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event Player#loadeddata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event Player#timeupdate
 * @type {EventTarget~Event}
 */

/**
 * Fired when the volume changes
 *
 * @event Player#volumechange
 * @type {EventTarget~Event}
 */

/**
 * Reports whether or not a player has a plugin available.
 *
 * This does not report whether or not the plugin has ever been initialized
 * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
 *
 * @method Player#hasPlugin
 * @param  {string}  name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player has the requested plugin available.
 */

/**
 * Reports whether or not a player is using a plugin by name.
 *
 * For basic plugins, this only reports whether the plugin has _ever_ been
 * initialized on this player.
 *
 * @method Player#usingPlugin
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player is using the requested plugin.
 */

Component.registerComponent('Player', Player);

/**
 * @file plugin.js
 */
var BASE_PLUGIN_NAME = 'plugin';

/**
 * The key on which a player's active plugins cache is stored.
 *
 * @private
 * @constant
 * @type     {string}
 */
var PLUGIN_CACHE_KEY = 'activePlugins_';

/**
 * Stores registered plugins in a private space.
 *
 * @private
 * @type    {Object}
 */
var pluginStorage = {};

/**
 * Reports whether or not a plugin has been registered.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {boolean}
 *          Whether or not the plugin has been registered.
 */
var pluginExists = function pluginExists(name) {
  return pluginStorage.hasOwnProperty(name);
};

/**
 * Get a single registered plugin by name.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {Function|undefined}
 *          The plugin (or undefined).
 */
var getPlugin = function getPlugin(name) {
  return pluginExists(name) ? pluginStorage[name] : undefined;
};

/**
 * Marks a plugin as "active" on a player.
 *
 * Also, ensures that the player has an object for tracking active plugins.
 *
 * @private
 * @param   {Player} player
 *          A Video.js player instance.
 *
 * @param   {string} name
 *          The name of a plugin.
 */
var markPluginAsActive = function markPluginAsActive(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};

/**
 * Triggers a pair of plugin setup events.
 *
 * @private
 * @param  {Player} player
 *         A Video.js player instance.
 *
 * @param  {Plugin~PluginEventHash} hash
 *         A plugin event hash.
 *
 * @param  {Boolean} [before]
 *         If true, prefixes the event name with "before". In other words,
 *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
 */
var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
  var eventName = (before ? 'before' : '') + 'pluginsetup';

  player.trigger(eventName, hash);
  player.trigger(eventName + ':' + hash.name, hash);
};

/**
 * Takes a basic plugin function and returns a wrapper function which marks
 * on the player that the plugin has been activated.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Function} plugin
 *          The basic plugin.
 *
 * @returns {Function}
 *          A wrapper function for the given plugin.
 */
var createBasicPlugin = function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the "pluginsetup" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
};

/**
 * Takes a plugin sub-class and returns a factory function for generating
 * instances of it.
 *
 * This factory function will replace itself with an instance of the requested
 * sub-class of Plugin.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Plugin} PluginSubClass
 *          The advanced plugin.
 *
 * @returns {Function}
 */
var createPluginFactory = function createPluginFactory(name, PluginSubClass) {

  // Add a `name` property to the plugin prototype so that each plugin can
  // refer to itself by name.
  PluginSubClass.prototype.name = name;

  return function () {
    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();

    // The plugin is replaced by a function that returns the current instance.
    this[name] = function () {
      return instance;
    };

    triggerSetupEvent(this, instance.getEventHash());

    return instance;
  };
};

/**
 * Parent class for all advanced plugins.
 *
 * @mixes   module:evented~EventedMixin
 * @mixes   module:stateful~StatefulMixin
 * @fires   Player#beforepluginsetup
 * @fires   Player#beforepluginsetup:$name
 * @fires   Player#pluginsetup
 * @fires   Player#pluginsetup:$name
 * @listens Player#dispose
 * @throws  {Error}
 *          If attempting to instantiate the base {@link Plugin} class
 *          directly instead of via a sub-class.
 */

var Plugin = function () {

  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  function Plugin(player) {
    classCallCheck(this, Plugin);

    if (this.constructor === Plugin) {
      throw new Error('Plugin must be sub-classed; not directly instantiated.');
    }

    this.player = player;

    // Make this object evented, but remove the added `trigger` method so we
    // use the prototype version instead.
    evented(this);
    delete this.trigger;

    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);

    // Auto-bind the dispose method so we can use it as a listener and unbind
    // it later easily.
    this.dispose = bind(this, this.dispose);

    // If the player is disposed, dispose the plugin.
    player.on('dispose', this.dispose);
  }

  /**
   * Get the version of the plugin that was set on <pluginName>.VERSION
   */


  Plugin.prototype.version = function version() {
    return this.constructor.VERSION;
  };

  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @returns {Plugin~PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */


  Plugin.prototype.getEventHash = function getEventHash() {
    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };

  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link Plugin~PluginEventHash|PluginEventHash}.
   *
   * @returns {boolean}
   *          Whether or not default was prevented.
   */


  Plugin.prototype.trigger = function trigger$$1(event) {
    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };

  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */


  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};

  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */


  Plugin.prototype.dispose = function dispose() {
    var name = this.name,
        player = this.player;

    /**
     * Signals that a advanced plugin is about to be disposed.
     *
     * @event Plugin#dispose
     * @type  {EventTarget~Event}
     */

    this.trigger('dispose');
    this.off();
    player.off('dispose', this.dispose);

    // Eliminate any possible sources of leaking memory by clearing up
    // references between the player and the plugin instance and nulling out
    // the plugin's state and replacing methods with a function that throws.
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;

    // Finally, replace the plugin name on the player with a new factory
    // function, so that the plugin is ready to be set up again.
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };

  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @returns {boolean}
   *          Whether or not a plugin is a basic plugin.
   */


  Plugin.isBasic = function isBasic(plugin) {
    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;

    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
  };

  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @returns {Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */


  Plugin.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== 'string') {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
    }

    if (pluginExists(name)) {
      log$2.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }

    if (typeof plugin !== 'function') {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
    }

    pluginStorage[name] = plugin;

    // Add a player prototype method for all sub-classed plugins (but not for
    // the base Plugin class).
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }

    return plugin;
  };

  /**
   * De-register a Video.js plugin.
   *
   * @param {string} name
   *        The name of the plugin to be deregistered.
   */


  Plugin.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error('Cannot de-register base plugin.');
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };

  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @returns {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */


  Plugin.getPlugins = function getPlugins() {
    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);

    var result = void 0;

    names.forEach(function (name) {
      var plugin = getPlugin(name);

      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });

    return result;
  };

  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @returns {string}
   *          The plugin's version or an empty string.
   */


  Plugin.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);

    return plugin && plugin.VERSION || '';
  };

  return Plugin;
}();

/**
 * Gets a plugin by name if it exists.
 *
 * @static
 * @method   getPlugin
 * @memberOf Plugin
 * @param    {string} name
 *           The name of a plugin.
 *
 * @returns  {Function|undefined}
 *           The plugin (or `undefined`).
 */


Plugin.getPlugin = getPlugin;

/**
 * The name of the base plugin class as it is registered.
 *
 * @type {string}
 */
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;

Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.usingPlugin = function (name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.hasPlugin = function (name) {
  return !!pluginExists(name);
};

/**
 * @file extend.js
 * @module extend
 */

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 *
 * @param {Object} subClass
 *        The class to inherit to
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @private
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * @static
 * @const
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @param {Object} [subClassMethods={}]
 *        The class to inherit to
 *
 * @return {Object}
 *         The new object with subClassMethods that inherited superClass.
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };

  var methods = {};

  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

/**
 * @file video.js
 * @module videojs
 */
if (typeof HTMLVideoElement === 'undefined' && isReal()) {
  document_1.createElement('video');
  document_1.createElement('audio');
  document_1.createElement('track');
  document_1.createElement('video-js');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
  *
 * @param {string|Element} id
 *        Video element or video element ID
 *
 * @param {Object} [options]
 *        Optional options object for config/settings
 *
 * @param {Component~ReadyCallback} [ready]
 *        Optional ready callback
 *
 * @return {Player}
 *         A player instance
 */
function videojs(id, options, ready) {
  var tag = void 0;

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {
    var players = videojs.getPlayers();

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (players[id]) {

      // If options or ready function are passed, warn
      if (options) {
        log$2.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        players[id].ready(ready);
      }

      return players[id];
    }

    // Otherwise get element for ID
    tag = $('#' + id);

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  // re: nodeName, could be a box div also
  if (!tag || !tag.nodeName) {
    throw new TypeError('The element or ID supplied is not valid. (videojs)');
  }

  // Element may have a player attr referring to an already created player instance.
  // If so return that otherwise set up a new player below
  if (tag.player || Player.players[tag.playerId]) {
    return tag.player || Player.players[tag.playerId];
  }

  // Check if element is included in the DOM
  if (isEl(tag) && !document_1.body.contains(tag)) {
    log$2.warn('The element supplied is not included in the DOM');
  }

  options = options || {};

  videojs.hooks('beforesetup').forEach(function (hookFunction) {
    var opts = hookFunction(tag, mergeOptions(options));

    if (!isObject$1(opts) || Array.isArray(opts)) {
      log$2.error('please return an object in beforesetup hooks');
      return;
    }

    options = mergeOptions(options, opts);
  });

  var PlayerComponent = Component.getComponent('Player');
  // If not, set up a new player
  var player = new PlayerComponent(tag, options, ready);

  videojs.hooks('setup').forEach(function (hookFunction) {
    return hookFunction(player);
  });

  return player;
}

/**
 * An Object that contains lifecycle hooks as keys which point to an array
 * of functions that are run when a lifecycle is triggered
 */
videojs.hooks_ = {};

/**
 * Get a list of hooks for a specific lifecycle
 * @function videojs.hooks
 *
 * @param {string} type
 *        the lifecyle to get hooks from
 *
 * @param {Function|Function[]} [fn]
 *        Optionally add a hook (or hooks) to the lifecycle that your are getting.
 *
 * @return {Array}
 *         an array of hooks, or an empty array if there are none.
 */
videojs.hooks = function (type, fn) {
  videojs.hooks_[type] = videojs.hooks_[type] || [];
  if (fn) {
    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
  }
  return videojs.hooks_[type];
};

/**
 * Add a function hook to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hook = function (type, fn) {
  videojs.hooks(type, fn);
};

/**
 * Add a function hook that will only run once to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hookOnce = function (type, fn) {
  videojs.hooks(type, [].concat(fn).map(function (original) {
    var wrapper = function wrapper() {
      videojs.removeHook(type, wrapper);
      return original.apply(undefined, arguments);
    };

    return wrapper;
  }));
};

/**
 * Remove a hook from a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle that the function hooked to
 *
 * @param {Function} fn
 *        The hooked function to remove
 *
 * @return {boolean}
 *         The function that was removed or undef
 */
videojs.removeHook = function (type, fn) {
  var index = videojs.hooks(type).indexOf(fn);

  if (index <= -1) {
    return false;
  }

  videojs.hooks_[type] = videojs.hooks_[type].slice();
  videojs.hooks_[type].splice(index, 1);

  return true;
};

// Add default styles
if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style = $('.vjs-styles-defaults');

  if (!style) {
    style = createStyleElement('vjs-styles-defaults');
    var head = $('head');

    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your
// video in the DOM (weird behavior only with minified version)
autoSetupTimeout(1, videojs);

/**
 * Current software version. Follows semver.
 *
 * @type {string}
 */
videojs.VERSION = version;

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * @type {Object}
 */
videojs.options = Player.prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object}
 *         The created players
 */
videojs.getPlayers = function () {
  return Player.players;
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = Player.players;

/**
 * Get a component class object by name
 *
 * @borrows Component.getComponent as videojs.getComponent
 */
videojs.getComponent = Component.getComponent;

/**
 * Register a component so it can referred to by name. Used when adding to other
 * components, either through addChild `component.addChild('myComponent')` or through
 * default children options  `{ children: ['myComponent'] }`.
 *
 * > NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {string} name
 *        The class name of the component
 *
 * @param {Component} comp
 *        The component class
 *
 * @return {Component}
 *         The newly registered component
 */
videojs.registerComponent = function (name$$1, comp) {
  if (Tech.isTech(comp)) {
    log$2.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  Component.registerComponent.call(Component, name$$1, comp);
};

/**
 * Get a Tech class object by name
 *
 * @borrows Tech.getTech as videojs.getTech
 */
videojs.getTech = Tech.getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * @borrows Tech.registerTech as videojs.registerTech
 */
videojs.registerTech = Tech.registerTech;

videojs.use = use;

/**
 * A suite of browser and device tests from {@link browser}.
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated since version 5.0
 * @type {boolean}
 */
videojs.TOUCH_ENABLED = TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 *
 * @borrows extend:extendFn as videojs.extend
 */
videojs.extend = extendFn;

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 *
 * @borrows merge-options:mergeOptions as videojs.mergeOptions
 */
videojs.mergeOptions = mergeOptions;

/**
 * Change the context (this) of a function
 *
 * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function() {}.bind(newContext);` instead of this.
 *
 * @borrows fn:bind as videojs.bind
 */
videojs.bind = bind;

/**
 * Register a Video.js plugin.
 *
 * @borrows plugin:registerPlugin as videojs.registerPlugin
 * @method registerPlugin
 *
 * @param  {string} name
 *         The name of the plugin to be registered. Must be a string and
 *         must not match an existing plugin or a method on the `Player`
 *         prototype.
 *
 * @param  {Function} plugin
 *         A sub-class of `Plugin` or a function for basic plugins.
 *
 * @return {Function}
 *         For advanced plugins, a factory function for that plugin. For
 *         basic plugins, a wrapper function that initializes the plugin.
 */
videojs.registerPlugin = Plugin.registerPlugin;

/**
 * Deprecated method to register a plugin with Video.js
 *
 * @deprecated
 *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead
 *
 * @param {string} name
 *        The plugin name
 *
 * @param {Plugin|Function} plugin
 *         The plugin sub-class or function
 */
videojs.plugin = function (name$$1, plugin) {
  log$2.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
  return Plugin.registerPlugin(name$$1, plugin);
};

/**
 * Gets an object containing multiple Video.js plugins.
 *
 * @param  {Array} [names]
 *         If provided, should be an array of plugin names. Defaults to _all_
 *         plugin names.
 *
 * @return {Object|undefined}
 *         An object containing plugin(s) associated with their name(s) or
 *         `undefined` if no matching plugins exist).
 */
videojs.getPlugins = Plugin.getPlugins;

/**
 * Gets a plugin by name if it exists.
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {Function|undefined}
 *         The plugin (or `undefined`).
 */
videojs.getPlugin = Plugin.getPlugin;

/**
 * Gets a plugin's version, if available
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {string}
 *         The plugin's version or an empty string.
 */
videojs.getPluginVersion = Plugin.getPluginVersion;

/**
 * Adding languages so that they're available to all players.
 * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
 *
 * @param {string} code
 *        The language code or dictionary property
 *
 * @param {Object} data
 *        The data values to be translated
 *
 * @return {Object}
 *         The resulting language dictionary object
 */
videojs.addLanguage = function (code, data) {
  var _mergeOptions;

  code = ('' + code).toLowerCase();

  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));

  return videojs.options.languages[code];
};

/**
 * Log messages
 *
 * @borrows log:log as videojs.log
 */
videojs.log = log$2;

/**
 * Creates an emulated TimeRange object.
 *
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRange
 */
/**
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges
 */
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @borrows format-time:formatTime as videojs.formatTime
 */
videojs.formatTime = formatTime;

/**
 * Resolve and parse the elements of a URL
 *
 * @borrows url:parseUrl as videojs.parseUrl
 */
videojs.parseUrl = parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @borrows url:isCrossOrigin as videojs.isCrossOrigin
 */
videojs.isCrossOrigin = isCrossOrigin;

/**
 * Event target class.
 *
 * @borrows EventTarget as videojs.EventTarget
 */
videojs.EventTarget = EventTarget;

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @borrows events:on as videojs.on
 */
videojs.on = on;

/**
 * Trigger a listener only once for an event
 *
 * @borrows events:one as videojs.one
 */
videojs.one = one;

/**
 * Removes event listeners from an element
 *
 * @borrows events:off as videojs.off
 */
videojs.off = off;

/**
 * Trigger an event for an element
 *
 * @borrows events:trigger as videojs.trigger
 */
videojs.trigger = trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 * @param {Object} options
 *        settings for the request.
 *
 * @return {XMLHttpRequest|XDomainRequest}
 *         The request object.
 *
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = xhr;

/**
 * TextTrack class
 *
 * @borrows TextTrack as videojs.TextTrack
 */
videojs.TextTrack = TextTrack;

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @borrows AudioTrack as videojs.AudioTrack
 */
videojs.AudioTrack = AudioTrack;

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @borrows VideoTrack as videojs.VideoTrack
 */
videojs.VideoTrack = VideoTrack;

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @borrows dom:isEl as videojs.isEl
 * @deprecated Use videojs.dom.isEl() instead
 */

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @borrows dom:isTextNode as videojs.isTextNode
 * @deprecated Use videojs.dom.isTextNode() instead
 */

/**
 * Creates an element and applies properties.
 *
 * @borrows dom:createEl as videojs.createEl
 * @deprecated Use videojs.dom.createEl() instead
 */

/**
 * Check if an element has a CSS class
 *
 * @borrows dom:hasElClass as videojs.hasClass
 * @deprecated Use videojs.dom.hasClass() instead
 */

/**
 * Add a CSS class name to an element
 *
 * @borrows dom:addElClass as videojs.addClass
 * @deprecated Use videojs.dom.addClass() instead
 */

/**
 * Remove a CSS class name from an element
 *
 * @borrows dom:removeElClass as videojs.removeClass
 * @deprecated Use videojs.dom.removeClass() instead
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @borrows dom:toggleElClass as videojs.toggleClass
 * @deprecated Use videojs.dom.toggleClass() instead
 */

/**
 * Apply attributes to an HTML element.
 *
 * @borrows dom:setElAttributes as videojs.setAttribute
 * @deprecated Use videojs.dom.setAttributes() instead
 */

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @borrows dom:getElAttributes as videojs.getAttributes
 * @deprecated Use videojs.dom.getAttributes() instead
 */

/**
 * Empties the contents of an element.
 *
 * @borrows dom:emptyEl as videojs.emptyEl
 * @deprecated Use videojs.dom.emptyEl() instead
 */

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:appendContents as videojs.appendContet
 * @deprecated Use videojs.dom.appendContent() instead
 */

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:insertContent as videojs.insertContent
 * @deprecated Use videojs.dom.insertContent() instead
 */
['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
  videojs[k] = function () {
    log$2.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');
    return Dom[k].apply(null, arguments);
  };
});

/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is because in Firefox, if the player is loaded in an iframe with `display:none`,
 * then `getComputedStyle` returns `null`, so, we do a null-check to make sure
 * that the player doesn't break in these cases.
 * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.
 *
 * @borrows computed-style:computedStyle as videojs.computedStyle
 */
videojs.computedStyle = computedStyle;

/**
 * Export the Dom utilities for use in external plugins
 * and Tech's
 */
videojs.dom = Dom;

/**
 * Export the Url utilities for use in external plugins
 * and Tech's
 */
videojs.url = Url;

var enc = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
        module.exports = factory();
    })(self, function () {
        return (/******/function () {
                // webpackBootstrap
                /******/var __webpack_modules__ = {

                    /***/"./node_modules/@tencent/js-armor-loader/dist/runtime.js":
                    /*!***************************************************************!*\
                      !*** ./node_modules/@tencent/js-armor-loader/dist/runtime.js ***!
                      \***************************************************************/
                    /***/function node_modulesTencentJsArmorLoaderDistRuntimeJs(module) {

                        function T(f, l, c, r, g, s, a, v) {
                            var n = !r;f = +f, l = l || [0], r = r || [[this], [{}]], g = g || {};var h,
                                t = [],
                                o = null;function p() {
                                return function (n, t, o) {
                                    return new (Function.bind.apply(n, t))();
                                }.apply(null, arguments);
                            }Function.prototype.bind || (h = [].slice, Function.prototype.bind = function (n) {
                                if ("function" != typeof this) throw new TypeError("bind101");var t = h.call(arguments, 1),
                                    o = t.length,
                                    p = this,
                                    e = function e() {},
                                    u = function u() {
                                    return t.length = o, t.push.apply(t, arguments), p.apply(e.prototype.isPrototypeOf(this) ? this : n, t);
                                };return this.prototype && (e.prototype = this.prototype), u.prototype = new e(), u;
                            });var e = [function () {
                                r[r.length - 1] += String.fromCharCode(l[f++]);
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] << r.pop();
                            }, function () {
                                r.push(null);
                            }, function () {
                                var n = l[f++];r[r.length - 1] && (f = n);
                            }, function () {
                                var n = r[r.length - 2];n[0][n[1]] = r[r.length - 1];
                            }, function () {
                                var n = r.pop(),
                                    t = r.pop();r.push([t[0][t[1]], n]);
                            }, function () {
                                var n = l[f++];r[n] = r[n] === undefined ? [] : r[n];
                            }, function () {
                                return !!o;
                            }, function () {
                                r.push([r.pop(), r.pop()].reverse());
                            }, function () {
                                r[r.length - 1].length ? r.push(r[r.length - 1].shift(), !0) : r.push(undefined, !1);
                            }, function () {
                                var n = l[f++],
                                    t = n ? r.slice(-n) : [];r.length -= n, t.unshift(null);n = r.pop();r.push(p(n[0][n[1]], t));
                            }, function () {
                                var n = r.pop();r.push(delete n[0][n[1]]);
                            }, function () {
                                var n = r[r.length - 2],
                                    t = Object.getOwnPropertyDescriptor(n[0], n[1]) || { configurable: !0, enumerable: !0 };t.get = r[r.length - 1], Object.defineProperty(n[0], n[1], t);
                            }, function () {
                                r[r[r.length - 2][0]][0] = r[r.length - 1];
                            }, function () {
                                r.push(r[l[f++]][0]);
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] == r.pop();
                            }, function () {
                                for (var n = r.pop(), o = l[f++], p = [], t = l[f++], e = l[f++], u = [], h = 0; h < t; h++) {
                                    p[l[f++]] = r[l[f++]];
                                }for (h = 0; h < e; h++) {
                                    u[h] = l[f++];
                                }var i = function i() {
                                    var n = p.slice(0);n[0] = [this], n[1] = [arguments], n[2] = [i];for (var t = 0; t < u.length && t < arguments.length; t++) {
                                        0 < u[t] && (n[u[t]] = [arguments[t]]);
                                    }return T(o, l, c, n, g, s, a, v);
                                };i.toString = function () {
                                    return n;
                                }, r.push(i);
                            }, function () {
                                r.push(~r.pop());
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] - r.pop();
                            }, function () {
                                r.push(!1);
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] >= r.pop();
                            }, function () {
                                r.push([c, r.pop()]);
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] in r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] & r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] | r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] % r.pop();
                            }, function () {
                                r.push("");
                            }, function () {
                                r[r.length - 1] = l[f++];
                            }, function () {
                                r.push(undefined);
                            }, function () {
                                var n = r.pop();r.push(n[0][n[1]]);
                            }, function () {
                                r.push(r[r.length - 1]);
                            }, function () {
                                var n = l[f++],
                                    t = n ? r.slice(-n) : [];r.length -= n, t.unshift(null), r.push(p(r.pop(), t));
                            }, function () {
                                r.push(!0);
                            }, function () {
                                r.push([l[f++]]);
                            }, function () {
                                var n = r.pop();g[n] || (c[n] = c[n](), g[n] = 1), r.push(c[n]);
                            }, function () {
                                o = null;
                            }, function () {
                                r.length = l[f++];
                            }, function () {
                                var n = r.pop();r.push([r[r.pop()][0], n]);
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] instanceof r.pop();
                            }, function () {
                                t.push([l[f++], r.length, l[f++]]);
                            }, function () {
                                var n = l[f++],
                                    t = n ? r.slice(-n) : [];r.length -= n, r.push(r.pop().apply(c, t));
                            }, function () {
                                r.push(_typeof(r.pop()));
                            }, function () {
                                var n = l[f++],
                                    t = r[r.length - 2 - n];r[r.length - 2 - n] = r.pop(), r.push(t);
                            }, function () {
                                r[r[r.length - 1][0]] = r[r[r.length - 1][0]] === undefined ? [] : r[r[r.length - 1][0]];
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] + r.pop();
                            }, function () {}, function () {
                                throw r[r.length - 1];
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] >> r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] / r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] * r.pop();
                            }, function () {
                                for (var o = l[f++], p = [], n = l[f++], t = l[f++], e = [], u = 0; u < n; u++) {
                                    p[l[f++]] = r[l[f++]];
                                }for (u = 0; u < t; u++) {
                                    e[u] = l[f++];
                                }r.push(function h() {
                                    var n = p.slice(0);n[0] = [this], n[1] = [arguments], n[2] = [h];for (var t = 0; t < e.length && t < arguments.length; t++) {
                                        0 < e[t] && (n[e[t]] = [arguments[t]]);
                                    }return T(o, l, c, n, g, s, a, v);
                                });
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] <= r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] < r.pop();
                            }, function () {
                                return !0;
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] === r.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] ^ r.pop();
                            }, function () {
                                r.pop();
                            }, function () {
                                r[r.length - 1] = c[r[r.length - 1]];
                            }, function () {
                                r.push(l[f++]);
                            }, function () {
                                var n,
                                    t = [];for (n in r.pop()) {
                                    t.push(n);
                                }r.push(t);
                            }, function () {
                                var n = l[f++],
                                    t = n ? r.slice(-n) : [];r.length -= n;n = r.pop();r.push(n[0][n[1]].apply(n[0], t));
                            }, function () {
                                t.pop();
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] >>> r.pop();
                            }, function () {
                                var n = r.pop();g[n] || (c[n] = c[n](), g[n] = 1), r.push([c, n]);
                            }, function () {
                                r.length -= l[f++];
                            }, function () {
                                r.push(!r.pop());
                            }, function () {
                                r[r.length - 2] = r[r.length - 2] > r.pop();
                            }, function () {
                                f = l[f++];
                            }, function () {
                                var n = r[r.length - 2],
                                    t = Object.getOwnPropertyDescriptor(n[0], n[1]) || { configurable: !0, enumerable: !0 };t.set = r[r.length - 1], Object.defineProperty(n[0], n[1], t);
                            }, function () {
                                r.push(r[r.pop()[0]][0]);
                            }];for (0;;) {
                                try {
                                    for (var u = !1; !u;) {
                                        u = e[l[f++]]();
                                    }if (0, o) throw o;return n ? (r.pop(), r.slice(3 + T.v)) : r.pop();
                                } catch (y) {
                                    0;var i = t.pop();if (i === undefined) throw y;o = y, f = i[0], r.length = i[1], i[2] && (r[i[2]][0] = o);
                                }
                            }
                        }T.v = 0;
                        "use strict";

                        /* eslint-disable */
                        function arrayIndexOf(arr, searchElement, fromIndex) {
                            if (typeof Array.prototype.indexOf === 'function') {
                                return Array.prototype.indexOf.call(arr, searchElement, fromIndex);
                            }

                            var k;
                            var len = o.length;

                            if (len === 0) {
                                return -1;
                            }

                            var n = fromIndex | 0;

                            if (n >= len) {
                                return -1;
                            }

                            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

                            for (; k < len; k++) {
                                if (k in o && o[k] === searchElement) return k;
                            }

                            return -1;
                        }

                        function base64Decode(t) {
                            var r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');
                            var o = String(t).replace(/[=]+$/, '');

                            for (var e, n, a = 0, i = 0, c = ''; n = o.charAt(i++); ~n && (e = a % 4 ? 64 * e + n : n, a++ % 4) ? c += String.fromCharCode(255 & e >> (-2 * a & 6)) : 0) {
                                n = arrayIndexOf(r, n);
                            }return c;
                        }
                        /** releaseSymbols, 识别导入的全局变量 */

                        module.exports.r = function (symbols) {
                            var result = [];

                            for (var i = 0; i < symbols.length; i++) {
                                try {
                                    result.push(eval(symbols[i]));
                                } catch (_) {
                                    result.push(undefined);
                                }
                            }

                            return result;
                        };
                        /** decompress, 解压字节码 */

                        module.exports.d = function (arr) {
                            if (typeof arr[1] !== 'object') {
                                return arr;
                            }

                            var compressed = arr[0];
                            var bigNumbers = arr[1];
                            var restored = [];
                            var bytes = base64Decode(compressed);
                            var pos = bigNumbers.shift();
                            var num = bigNumbers.shift();
                            var current = 0;

                            function insertBigNumber() {
                                while (current === pos) {
                                    restored.push(num);
                                    current++;
                                    pos = bigNumbers.shift();
                                    num = bigNumbers.shift();
                                }
                            }

                            for (var i = 0; i < bytes.length; i++) {
                                var charCode = bytes.charAt(i).charCodeAt(0);
                                insertBigNumber();
                                restored.push(charCode);
                                current++;
                            }

                            insertBigNumber();
                            return restored;
                        };
                        /** getResult 从 vm 执行结果中获取局部变量 */

                        module.exports.g = function (result) {
                            return result.shift()[0];
                        };
                        /** vm */

                        module.exports.v = T;

                        /***/
                    },

                    /***/"./aes.js":
                    /*!****************!*\
                      !*** ./aes.js ***!
                      \****************/
                    /***/function aesJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"default": function _default() {
                                return __WEBPACK_DEFAULT_EXPORT__;
                            }
                            /* harmony export */ });
                        /*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
                        // (function (root) {


                        function checkInt(value) {
                            return parseInt(value) === value;
                        }

                        function checkInts(arrayish) {
                            if (!checkInt(arrayish.length)) {
                                return false;
                            }

                            for (var i = 0; i < arrayish.length; i++) {
                                if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                                    return false;
                                }
                            }

                            return true;
                        }

                        function coerceArray(arg, copy) {
                            // ArrayBuffer view
                            if (arg.buffer && arg.name === 'Uint8Array') {
                                if (copy) {
                                    if (arg.slice) {
                                        arg = arg.slice();
                                    } else {
                                        arg = Array.prototype.slice.call(arg);
                                    }
                                }

                                return arg;
                            } // It's an array; check it is a valid representation of a byte


                            if (Array.isArray(arg)) {
                                if (!checkInts(arg)) {
                                    throw new Error('Array contains invalid value: ' + arg);
                                }

                                return new Uint8Array(arg);
                            } // Something else, but behaves like an array (maybe a Buffer? Arguments?)


                            if (checkInt(arg.length) && checkInts(arg)) {
                                return new Uint8Array(arg);
                            }

                            throw new Error('unsupported array-like object');
                        }

                        function createArray(length) {
                            return new Uint8Array(length);
                        }

                        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
                            if (sourceStart != null || sourceEnd != null) {
                                if (sourceArray.slice) {
                                    sourceArray = sourceArray.slice(sourceStart, sourceEnd);
                                } else {
                                    sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
                                }
                            }

                            targetArray.set(sourceArray, targetStart);
                        }

                        var convertUtf8 = function () {
                            function toBytes(text) {
                                var result = [];
                                var i = 0;
                                text = encodeURI(text);

                                while (i < text.length) {
                                    var c = text.charCodeAt(i++); // if it is a % sign, encode the following 2 bytes as a hex value

                                    if (c === 37) {
                                        result.push(parseInt(text.substr(i, 2), 16));
                                        i += 2; // otherwise, just the actual byte
                                    } else {
                                        result.push(c);
                                    }
                                }

                                return coerceArray(result);
                            }

                            function fromBytes(bytes) {
                                var result = [];
                                var i = 0;

                                while (i < bytes.length) {
                                    var c = bytes[i];

                                    if (c < 128) {
                                        result.push(String.fromCharCode(c));
                                        i++;
                                    } else if (c > 191 && c < 224) {
                                        result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
                                        i += 2;
                                    } else {
                                        result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
                                        i += 3;
                                    }
                                }

                                return result.join('');
                            }

                            return {
                                toBytes: toBytes,
                                fromBytes: fromBytes
                            };
                        }();

                        var convertHex = function () {
                            function toBytes(text) {
                                var result = [];

                                for (var i = 0; i < text.length; i += 2) {
                                    result.push(parseInt(text.substr(i, 2), 16));
                                }

                                return result;
                            } // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html


                            var Hex = '0123456789abcdef';

                            function fromBytes(bytes) {
                                var result = [];

                                for (var i = 0; i < bytes.length; i++) {
                                    var v = bytes[i];
                                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                                }

                                return result.join('');
                            }

                            return {
                                toBytes: toBytes,
                                fromBytes: fromBytes
                            };
                        }(); // Number of rounds by keysize


                        var numberOfRounds = {
                            16: 10,
                            24: 12,
                            32: 14
                        }; // Round constant words

                        var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91]; // S-box and Inverse S-box (S is for Substitution)

                        var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
                        var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]; // Transformations for encryption

                        var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
                        var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
                        var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
                        var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c]; // Transformations for decryption

                        var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
                        var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
                        var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
                        var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0]; // Transformations for decryption key expansion

                        var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
                        var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
                        var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
                        var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

                        function convertToInt32(bytes) {
                            var result = [];

                            for (var i = 0; i < bytes.length; i += 4) {
                                result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
                            }

                            return result;
                        }

                        var AES = function AES(key) {
                            if (!(this instanceof AES)) {
                                throw Error('AES must be instanitated with `new`');
                            }

                            Object.defineProperty(this, 'key', {
                                value: coerceArray(key, true)
                            });

                            this._prepare();
                        };

                        AES.prototype._prepare = function () {
                            var rounds = numberOfRounds[this.key.length];

                            if (rounds == null) {
                                throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
                            } // encryption round keys


                            this._Ke = []; // decryption round keys

                            this._Kd = [];

                            for (var i = 0; i <= rounds; i++) {
                                this._Ke.push([0, 0, 0, 0]);

                                this._Kd.push([0, 0, 0, 0]);
                            }

                            var roundKeyCount = (rounds + 1) * 4;
                            var KC = this.key.length / 4; // convert the key into ints

                            var tk = convertToInt32(this.key); // copy values into round key arrays

                            var index;

                            for (var i = 0; i < KC; i++) {
                                index = i >> 2;
                                this._Ke[index][i % 4] = tk[i];
                                this._Kd[rounds - index][i % 4] = tk[i];
                            } // key expansion (fips-197 section 5.2)


                            var rconpointer = 0;
                            var t = KC;
                            var tt;

                            while (t < roundKeyCount) {
                                tt = tk[KC - 1];
                                tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
                                rconpointer += 1; // key expansion (for non-256 bit)

                                if (KC != 8) {
                                    for (var i = 1; i < KC; i++) {
                                        tk[i] ^= tk[i - 1];
                                    } // key expansion for 256-bit keys is "slightly different" (fips-197)
                                } else {
                                    for (var i = 1; i < KC / 2; i++) {
                                        tk[i] ^= tk[i - 1];
                                    }

                                    tt = tk[KC / 2 - 1];
                                    tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;

                                    for (var i = KC / 2 + 1; i < KC; i++) {
                                        tk[i] ^= tk[i - 1];
                                    }
                                } // copy values into round key arrays


                                var i = 0;
                                var r;
                                var c;

                                while (i < KC && t < roundKeyCount) {
                                    r = t >> 2;
                                    c = t % 4;
                                    this._Ke[r][c] = tk[i];
                                    this._Kd[rounds - r][c] = tk[i++];
                                    t++;
                                }
                            } // inverse-cipher-ify the decryption round key (fips-197 section 5.3)


                            for (var r = 1; r < rounds; r++) {
                                for (var c = 0; c < 4; c++) {
                                    tt = this._Kd[r][c];
                                    this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
                                }
                            }
                        };

                        AES.prototype.encrypt = function (plaintext) {
                            if (plaintext.length != 16) {
                                throw new Error('invalid plaintext size (must be 16 bytes)');
                            }

                            var rounds = this._Ke.length - 1;
                            var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

                            var t = convertToInt32(plaintext);

                            for (var i = 0; i < 4; i++) {
                                t[i] ^= this._Ke[0][i];
                            } // apply round transforms


                            for (var r = 1; r < rounds; r++) {
                                for (var i = 0; i < 4; i++) {
                                    a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
                                }

                                t = a.slice();
                            } // the last round is special


                            var result = createArray(16);
                            var tt;

                            for (var i = 0; i < 4; i++) {
                                tt = this._Ke[rounds][i];
                                result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
                                result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
                                result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
                                result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
                            }

                            return result;
                        };

                        AES.prototype.decrypt = function (ciphertext) {
                            if (ciphertext.length != 16) {
                                throw new Error('invalid ciphertext size (must be 16 bytes)');
                            }

                            var rounds = this._Kd.length - 1;
                            var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

                            var t = convertToInt32(ciphertext);

                            for (var i = 0; i < 4; i++) {
                                t[i] ^= this._Kd[0][i];
                            } // apply round transforms


                            for (var r = 1; r < rounds; r++) {
                                for (var i = 0; i < 4; i++) {
                                    a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
                                }

                                t = a.slice();
                            } // the last round is special


                            var result = createArray(16);
                            var tt;

                            for (var i = 0; i < 4; i++) {
                                tt = this._Kd[rounds][i];
                                result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
                                result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
                                result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
                                result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
                            }

                            return result;
                        };
                        /**
                         *  Mode Of Operation - Cipher Block Chaining (CBC)
                         */

                        var ModeOfOperationCBC = function ModeOfOperationCBC(key, iv) {
                            if (!(this instanceof ModeOfOperationCBC)) {
                                throw Error('AES must be instanitated with `new`');
                            }

                            this.description = 'Cipher Block Chaining';
                            this.name = 'cbc';

                            if (!iv) {
                                iv = createArray(16);
                            } else if (iv.length != 16) {
                                throw new Error('invalid initialation vector size (must be 16 bytes)');
                            }

                            this._lastCipherblock = coerceArray(iv, true);
                            this._aes = new AES(key);
                        };

                        ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
                            plaintext = coerceArray(plaintext);

                            if (plaintext.length % 16 !== 0) {
                                throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
                            }

                            var ciphertext = createArray(plaintext.length);
                            var block = createArray(16);

                            for (var i = 0; i < plaintext.length; i += 16) {
                                copyArray(plaintext, block, 0, i, i + 16);

                                for (var j = 0; j < 16; j++) {
                                    block[j] ^= this._lastCipherblock[j];
                                }

                                this._lastCipherblock = this._aes.encrypt(block);
                                copyArray(this._lastCipherblock, ciphertext, i);
                            }

                            return ciphertext;
                        };

                        ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
                            ciphertext = coerceArray(ciphertext);

                            if (ciphertext.length % 16 !== 0) {
                                throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
                            }

                            var plaintext = createArray(ciphertext.length);
                            var block = createArray(16);

                            for (var i = 0; i < ciphertext.length; i += 16) {
                                copyArray(ciphertext, block, 0, i, i + 16);
                                block = this._aes.decrypt(block);

                                for (var j = 0; j < 16; j++) {
                                    plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
                                }

                                copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
                            }

                            return plaintext;
                        };
                        /**
                         *  Counter object for CTR common mode of operation
                         */

                        var Counter = function Counter(initialValue) {
                            if (!(this instanceof Counter)) {
                                throw Error('Counter must be instanitated with `new`');
                            } // We allow 0, but anything false-ish uses the default 1


                            if (initialValue !== 0 && !initialValue) {
                                initialValue = 1;
                            }

                            if (typeof initialValue === 'number') {
                                this._counter = createArray(16);
                                this.setValue(initialValue);
                            } else {
                                this.setBytes(initialValue);
                            }
                        };

                        Counter.prototype.setValue = function (value) {
                            if (typeof value !== 'number' || parseInt(value) != value) {
                                throw new Error('invalid counter value (must be an integer)');
                            } // We cannot safely handle numbers beyond the safe range for integers


                            if (value > Number.MAX_SAFE_INTEGER) {
                                throw new Error('integer value out of safe range');
                            }

                            for (var index = 15; index >= 0; --index) {
                                this._counter[index] = value % 256;
                                value = parseInt(value / 256);
                            }
                        };

                        Counter.prototype.setBytes = function (bytes) {
                            bytes = coerceArray(bytes, true);

                            if (bytes.length != 16) {
                                throw new Error('invalid counter bytes size (must be 16 bytes)');
                            }

                            this._counter = bytes;
                        };

                        Counter.prototype.increment = function () {
                            for (var i = 15; i >= 0; i--) {
                                if (this._counter[i] === 255) {
                                    this._counter[i] = 0;
                                } else {
                                    this._counter[i]++;
                                    break;
                                }
                            }
                        }; /// ////////////////////
                        // Padding
                        // See:https://tools.ietf.org/html/rfc2315


                        function pkcs7pad(data) {
                            data = coerceArray(data, true);
                            var padder = 16 - data.length % 16;
                            var result = createArray(data.length + padder);
                            copyArray(data, result);

                            for (var i = data.length; i < result.length; i++) {
                                result[i] = padder;
                            }

                            return result;
                        }

                        function pkcs7strip(data) {
                            data = coerceArray(data, true);

                            if (data.length < 16) {
                                throw new Error('PKCS#7 invalid length');
                            }

                            var padder = data[data.length - 1];

                            if (padder > 16) {
                                throw new Error('PKCS#7 padding byte out of range');
                            }

                            var length = data.length - padder;

                            for (var i = 0; i < padder; i++) {
                                if (data[length + i] !== padder) {
                                    throw new Error('PKCS#7 invalid padding byte');
                                }
                            }

                            var result = createArray(length);
                            copyArray(data, result, 0, 0, length);
                            return result;
                        } /// ////////////////////
                        // Exporting
                        // The block cipher


                        var aesjs = {
                            AES: AES,
                            Counter: Counter,
                            modeOfOperation: {
                                cbc: ModeOfOperationCBC
                            },
                            utils: {
                                hex: convertHex,
                                utf8: convertUtf8
                            },
                            padding: {
                                pkcs7: {
                                    pad: pkcs7pad,
                                    strip: pkcs7strip
                                }
                            },
                            _arrayTest: {
                                coerceArray: coerceArray,
                                createArray: createArray,
                                copyArray: copyArray
                            }
                        };
                        /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = aesjs; // node.js
                        //   if (typeof exports !== 'undefined') {
                        //     module.exports = aesjs;
                        //     // RequireJS/AMD
                        //     // http://www.requirejs.org/docs/api.html
                        //     // https://github.com/amdjs/amdjs-api/wiki/AMD
                        //     // eslint-disable-next-line no-undef
                        //   } else if (typeof (define) === 'function' && define.amd) {
                        //     // eslint-disable-next-line no-undef
                        //     define([], function () {
                        //  return aesjs;
                        // });
                        //     // Web Browsers
                        //   } else {
                        //     // If there was an existing library at "aesjs" make sure it's still available
                        //     if (root.aesjs) {
                        //       aesjs._aesjs = root.aesjs;
                        //     }
                        //     root.aesjs = aesjs;
                        //   }
                        // })(this);

                        /***/
                    },

                    /***/"./gen-overlay-property.js":
                    /*!*********************************!*\
                      !*** ./gen-overlay-property.js ***!
                      \*********************************/
                    /***/function genOverlayPropertyJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"default": function _default() {
                                return __WEBPACK_DEFAULT_EXPORT__;
                            }
                            /* harmony export */ });
                        function genOverlay() {
                            var key = '';
                            var array = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

                            for (var i = 0; i < 32; i++) {
                                var randomInt = getRandomInt(0, 15);
                                key += array[randomInt];
                            }

                            return key;
                        }

                        function getRandomInt(min, max) {
                            return Math.floor(Math.random() * (max - min + 1) + min);
                        }

                        /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = genOverlay;

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/JSEncrypt.js":
                    /*!*************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/JSEncrypt.js ***!
                      \*************************************************/
                    /***/function node_modulesJsencryptLibJSEncryptJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"JSEncrypt": function JSEncrypt() {
                                return (/* binding */_JSEncrypt
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./lib/jsbn/base64 */"./node_modules/jsencrypt/lib/lib/jsbn/base64.js");
                        /* harmony import */var _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./JSEncryptRSAKey */"./node_modules/jsencrypt/lib/JSEncryptRSAKey.js");
                        /* harmony import */var _version_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./version.json */"./node_modules/jsencrypt/lib/version.json");

                        /**
                         *
                         * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
                         * possible parameters are:
                         * - default_key_size        {number}  default: 1024 the key size in bit
                         * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
                         * - log                     {boolean} default: false whether log warn/error or not
                         * @constructor
                         */
                        var _JSEncrypt = /** @class */function () {
                            function JSEncrypt(options) {
                                options = options || {};
                                this.default_key_size = options.default_key_size ? parseInt(options.default_key_size, 10) : 1024;
                                this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
                                this.log = options.log || false;
                                // The private and public key.
                                this.key = null;
                            }
                            /**
                             * Method to set the rsa key parameter (one method is enough to set both the public
                             * and the private key, since the private key contains the public key paramenters)
                             * Log a warning if logs are enabled
                             * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
                             * @public
                             */
                            JSEncrypt.prototype.setKey = function (key) {
                                if (this.log && this.key) {
                                    console.warn("A key was already set, overriding existing.");
                                }
                                this.key = new _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__.JSEncryptRSAKey(key);
                            };
                            /**
                             * Proxy method for setKey, for api compatibility
                             * @see setKey
                             * @public
                             */
                            JSEncrypt.prototype.setPrivateKey = function (privkey) {
                                // Create the key.
                                this.setKey(privkey);
                            };
                            /**
                             * Proxy method for setKey, for api compatibility
                             * @see setKey
                             * @public
                             */
                            JSEncrypt.prototype.setPublicKey = function (pubkey) {
                                // Sets the public key.
                                this.setKey(pubkey);
                            };
                            /**
                             * Proxy method for RSAKey object's decrypt, decrypt the string using the private
                             * components of the rsa key object. Note that if the object was not set will be created
                             * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
                             * @param {string} str base64 encoded crypted string to decrypt
                             * @return {string} the decrypted string
                             * @public
                             */
                            JSEncrypt.prototype.decrypt = function (str) {
                                // Return the decrypted string.
                                try {
                                    return this.getKey().decrypt((0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.b64tohex)(str));
                                } catch (ex) {
                                    return false;
                                }
                            };
                            /**
                             * Proxy method for RSAKey object's encrypt, encrypt the string using the public
                             * components of the rsa key object. Note that if the object was not set will be created
                             * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
                             * @param {string} str the string to encrypt
                             * @return {string} the encrypted string encoded in base64
                             * @public
                             */
                            JSEncrypt.prototype.encrypt = function (str) {
                                // Return the encrypted string.
                                try {
                                    return (0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getKey().encrypt(str));
                                } catch (ex) {
                                    return false;
                                }
                            };
                            /**
                             * Proxy method for RSAKey object's sign.
                             * @param {string} str the string to sign
                             * @param {function} digestMethod hash method
                             * @param {string} digestName the name of the hash algorithm
                             * @return {string} the signature encoded in base64
                             * @public
                             */
                            JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
                                // return the RSA signature of 'str' in 'hex' format.
                                try {
                                    return (0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getKey().sign(str, digestMethod, digestName));
                                } catch (ex) {
                                    return false;
                                }
                            };
                            /**
                             * Proxy method for RSAKey object's verify.
                             * @param {string} str the string to verify
                             * @param {string} signature the signature encoded in base64 to compare the string to
                             * @param {function} digestMethod hash method
                             * @return {boolean} whether the data and signature match
                             * @public
                             */
                            JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
                                // Return the decrypted 'digest' of the signature.
                                try {
                                    return this.getKey().verify(str, (0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.b64tohex)(signature), digestMethod);
                                } catch (ex) {
                                    return false;
                                }
                            };
                            /**
                             * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
                             * will be created and returned
                             * @param {callback} [cb] the callback to be called if we want the key to be generated
                             * in an async fashion
                             * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
                             * @public
                             */
                            JSEncrypt.prototype.getKey = function (cb) {
                                // Only create new if it does not exist.
                                if (!this.key) {
                                    // Get a new private key.
                                    this.key = new _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__.JSEncryptRSAKey();
                                    if (cb && {}.toString.call(cb) === "[object Function]") {
                                        this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                                        return;
                                    }
                                    // Generate the key.
                                    this.key.generate(this.default_key_size, this.default_public_exponent);
                                }
                                return this.key;
                            };
                            /**
                             * Returns the pem encoded representation of the private key
                             * If the key doesn't exists a new key will be created
                             * @returns {string} pem encoded representation of the private key WITH header and footer
                             * @public
                             */
                            JSEncrypt.prototype.getPrivateKey = function () {
                                // Return the private representation of this key.
                                return this.getKey().getPrivateKey();
                            };
                            /**
                             * Returns the pem encoded representation of the private key
                             * If the key doesn't exists a new key will be created
                             * @returns {string} pem encoded representation of the private key WITHOUT header and footer
                             * @public
                             */
                            JSEncrypt.prototype.getPrivateKeyB64 = function () {
                                // Return the private representation of this key.
                                return this.getKey().getPrivateBaseKeyB64();
                            };
                            /**
                             * Returns the pem encoded representation of the public key
                             * If the key doesn't exists a new key will be created
                             * @returns {string} pem encoded representation of the public key WITH header and footer
                             * @public
                             */
                            JSEncrypt.prototype.getPublicKey = function () {
                                // Return the private representation of this key.
                                return this.getKey().getPublicKey();
                            };
                            /**
                             * Returns the pem encoded representation of the public key
                             * If the key doesn't exists a new key will be created
                             * @returns {string} pem encoded representation of the public key WITHOUT header and footer
                             * @public
                             */
                            JSEncrypt.prototype.getPublicKeyB64 = function () {
                                // Return the private representation of this key.
                                return this.getKey().getPublicBaseKeyB64();
                            };
                            JSEncrypt.version = _version_json__WEBPACK_IMPORTED_MODULE_2__.version;
                            return JSEncrypt;
                        }();

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/JSEncryptRSAKey.js":
                    /*!*******************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/JSEncryptRSAKey.js ***!
                      \*******************************************************/
                    /***/function node_modulesJsencryptLibJSEncryptRSAKeyJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"JSEncryptRSAKey": function JSEncryptRSAKey() {
                                return (/* binding */_JSEncryptRSAKey
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./lib/jsbn/base64 */"./node_modules/jsencrypt/lib/lib/jsbn/base64.js");
                        /* harmony import */var _lib_asn1js_hex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./lib/asn1js/hex */"./node_modules/jsencrypt/lib/lib/asn1js/hex.js");
                        /* harmony import */var _lib_asn1js_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./lib/asn1js/base64 */"./node_modules/jsencrypt/lib/lib/asn1js/base64.js");
                        /* harmony import */var _lib_asn1js_asn1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./lib/asn1js/asn1 */"./node_modules/jsencrypt/lib/lib/asn1js/asn1.js");
                        /* harmony import */var _lib_jsbn_rsa__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./lib/jsbn/rsa */"./node_modules/jsencrypt/lib/lib/jsbn/rsa.js");
                        /* harmony import */var _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./lib/jsbn/jsbn */"./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js");
                        /* harmony import */var _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./lib/jsrsasign/asn1-1.0 */"./node_modules/jsencrypt/lib/lib/jsrsasign/asn1-1.0.js");
                        var __extends = undefined && undefined.__extends || function () {
                            var _extendStatics = function extendStatics(d, b) {
                                _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                                    d.__proto__ = b;
                                } || function (d, b) {
                                    for (var p in b) {
                                        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                                    }
                                };
                                return _extendStatics(d, b);
                            };
                            return function (d, b) {
                                if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                                _extendStatics(d, b);
                                function __() {
                                    this.constructor = d;
                                }
                                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                            };
                        }();

                        /**
                         * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
                         * This object is just a decorator for parsing the key parameter
                         * @param {string|Object} key - The key in string format, or an object containing
                         * the parameters needed to build a RSAKey object.
                         * @constructor
                         */
                        var _JSEncryptRSAKey = /** @class */function (_super) {
                            __extends(JSEncryptRSAKey, _super);
                            function JSEncryptRSAKey(key) {
                                var _this = _super.call(this) || this;
                                // Call the super constructor.
                                //  RSAKey.call(this);
                                // If a key key was provided.
                                if (key) {
                                    // If this is a string...
                                    if (typeof key === "string") {
                                        _this.parseKey(key);
                                    } else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) || JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                                        // Set the values for the key.
                                        _this.parsePropertiesFrom(key);
                                    }
                                }
                                return _this;
                            }
                            /**
                             * Method to parse a pem encoded string containing both a public or private key.
                             * The method will translate the pem encoded string in a der encoded string and
                             * will parse private key and public key parameters. This method accepts public key
                             * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
                             *
                             * @todo Check how many rsa formats use the same format of pkcs #1.
                             *
                             * The format is defined as:
                             * PublicKeyInfo ::= SEQUENCE {
                             *   algorithm       AlgorithmIdentifier,
                             *   PublicKey       BIT STRING
                             * }
                             * Where AlgorithmIdentifier is:
                             * AlgorithmIdentifier ::= SEQUENCE {
                             *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
                             *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
                             * }
                             * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
                             * RSAPublicKey ::= SEQUENCE {
                             *   modulus           INTEGER,  -- n
                             *   publicExponent    INTEGER   -- e
                             * }
                             * it's possible to examine the structure of the keys obtained from openssl using
                             * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
                             * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
                             * @private
                             */
                            JSEncryptRSAKey.prototype.parseKey = function (pem) {
                                try {
                                    var modulus = 0;
                                    var public_exponent = 0;
                                    var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
                                    var der = reHex.test(pem) ? _lib_asn1js_hex__WEBPACK_IMPORTED_MODULE_1__.Hex.decode(pem) : _lib_asn1js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.unarmor(pem);
                                    var asn1 = _lib_asn1js_asn1__WEBPACK_IMPORTED_MODULE_3__.ASN1.decode(der);
                                    // Fixes a bug with OpenSSL 1.0+ private keys
                                    if (asn1.sub.length === 3) {
                                        asn1 = asn1.sub[2].sub[0];
                                    }
                                    if (asn1.sub.length === 9) {
                                        // Parse the private key.
                                        modulus = asn1.sub[1].getHexStringValue(); // bigint
                                        this.n = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(modulus, 16);
                                        public_exponent = asn1.sub[2].getHexStringValue(); // int
                                        this.e = parseInt(public_exponent, 16);
                                        var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                                        this.d = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(private_exponent, 16);
                                        var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                                        this.p = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(prime1, 16);
                                        var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                                        this.q = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(prime2, 16);
                                        var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                                        this.dmp1 = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(exponent1, 16);
                                        var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                                        this.dmq1 = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(exponent2, 16);
                                        var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                                        this.coeff = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(coefficient, 16);
                                    } else if (asn1.sub.length === 2) {
                                        // Parse the public key.
                                        var bit_string = asn1.sub[1];
                                        var sequence = bit_string.sub[0];
                                        modulus = sequence.sub[0].getHexStringValue();
                                        this.n = (0, _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(modulus, 16);
                                        public_exponent = sequence.sub[1].getHexStringValue();
                                        this.e = parseInt(public_exponent, 16);
                                    } else {
                                        return false;
                                    }
                                    return true;
                                } catch (ex) {
                                    return false;
                                }
                            };
                            /**
                             * Translate rsa parameters in a hex encoded string representing the rsa key.
                             *
                             * The translation follow the ASN.1 notation :
                             * RSAPrivateKey ::= SEQUENCE {
                             *   version           Version,
                             *   modulus           INTEGER,  -- n
                             *   publicExponent    INTEGER,  -- e
                             *   privateExponent   INTEGER,  -- d
                             *   prime1            INTEGER,  -- p
                             *   prime2            INTEGER,  -- q
                             *   exponent1         INTEGER,  -- d mod (p1)
                             *   exponent2         INTEGER,  -- d mod (q-1)
                             *   coefficient       INTEGER,  -- (inverse of q) mod p
                             * }
                             * @returns {string}  DER Encoded String representing the rsa private key
                             * @private
                             */
                            JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
                                var options = {
                                    array: [new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: 0 }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.n }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: this.e }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.d }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.p }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.q }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.dmp1 }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.dmq1 }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.coeff })]
                                };
                                var seq = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence(options);
                                return seq.getEncodedHex();
                            };
                            /**
                             * base64 (pem) encoded version of the DER encoded representation
                             * @returns {string} pem encoded representation without header and footer
                             * @public
                             */
                            JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
                                return (0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getPrivateBaseKey());
                            };
                            /**
                             * Translate rsa parameters in a hex encoded string representing the rsa public key.
                             * The representation follow the ASN.1 notation :
                             * PublicKeyInfo ::= SEQUENCE {
                             *   algorithm       AlgorithmIdentifier,
                             *   PublicKey       BIT STRING
                             * }
                             * Where AlgorithmIdentifier is:
                             * AlgorithmIdentifier ::= SEQUENCE {
                             *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
                             *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
                             * }
                             * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
                             * RSAPublicKey ::= SEQUENCE {
                             *   modulus           INTEGER,  -- n
                             *   publicExponent    INTEGER   -- e
                             * }
                             * @returns {string} DER Encoded String representing the rsa public key
                             * @private
                             */
                            JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
                                var first_sequence = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({
                                    array: [new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERNull()]
                                });
                                var second_sequence = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({
                                    array: [new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.n }), new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: this.e })]
                                });
                                var bit_string = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERBitString({
                                    hex: "00" + second_sequence.getEncodedHex()
                                });
                                var seq = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({
                                    array: [first_sequence, bit_string]
                                });
                                return seq.getEncodedHex();
                            };
                            /**
                             * base64 (pem) encoded version of the DER encoded representation
                             * @returns {string} pem encoded representation without header and footer
                             * @public
                             */
                            JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
                                return (0, _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getPublicBaseKey());
                            };
                            /**
                             * wrap the string in block of width chars. The default value for rsa keys is 64
                             * characters.
                             * @param {string} str the pem encoded string without header and footer
                             * @param {Number} [width=64] - the length the string has to be wrapped at
                             * @returns {string}
                             * @private
                             */
                            JSEncryptRSAKey.wordwrap = function (str, width) {
                                width = width || 64;
                                if (!str) {
                                    return str;
                                }
                                var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
                                return str.match(RegExp(regex, "g")).join("\n");
                            };
                            /**
                             * Retrieve the pem encoded private key
                             * @returns {string} the pem encoded private key with header/footer
                             * @public
                             */
                            JSEncryptRSAKey.prototype.getPrivateKey = function () {
                                var key = "-----BEGIN RSA PRIVATE KEY-----\n";
                                key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
                                key += "-----END RSA PRIVATE KEY-----";
                                return key;
                            };
                            /**
                             * Retrieve the pem encoded public key
                             * @returns {string} the pem encoded public key with header/footer
                             * @public
                             */
                            JSEncryptRSAKey.prototype.getPublicKey = function () {
                                var key = "-----BEGIN PUBLIC KEY-----\n";
                                key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
                                key += "-----END PUBLIC KEY-----";
                                return key;
                            };
                            /**
                             * Check if the object contains the necessary parameters to populate the rsa modulus
                             * and public exponent parameters.
                             * @param {Object} [obj={}] - An object that may contain the two public key
                             * parameters
                             * @returns {boolean} true if the object contains both the modulus and the public exponent
                             * properties (n and e)
                             * @todo check for types of n and e. N should be a parseable bigInt object, E should
                             * be a parseable integer number
                             * @private
                             */
                            JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
                                obj = obj || {};
                                return obj.hasOwnProperty("n") && obj.hasOwnProperty("e");
                            };
                            /**
                             * Check if the object contains ALL the parameters of an RSA key.
                             * @param {Object} [obj={}] - An object that may contain nine rsa key
                             * parameters
                             * @returns {boolean} true if the object contains all the parameters needed
                             * @todo check for types of the parameters all the parameters but the public exponent
                             * should be parseable bigint objects, the public exponent should be a parseable integer number
                             * @private
                             */
                            JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
                                obj = obj || {};
                                return obj.hasOwnProperty("n") && obj.hasOwnProperty("e") && obj.hasOwnProperty("d") && obj.hasOwnProperty("p") && obj.hasOwnProperty("q") && obj.hasOwnProperty("dmp1") && obj.hasOwnProperty("dmq1") && obj.hasOwnProperty("coeff");
                            };
                            /**
                             * Parse the properties of obj in the current rsa object. Obj should AT LEAST
                             * include the modulus and public exponent (n, e) parameters.
                             * @param {Object} obj - the object containing rsa parameters
                             * @private
                             */
                            JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
                                this.n = obj.n;
                                this.e = obj.e;
                                if (obj.hasOwnProperty("d")) {
                                    this.d = obj.d;
                                    this.p = obj.p;
                                    this.q = obj.q;
                                    this.dmp1 = obj.dmp1;
                                    this.dmq1 = obj.dmq1;
                                    this.coeff = obj.coeff;
                                }
                            };
                            return JSEncryptRSAKey;
                        }(_lib_jsbn_rsa__WEBPACK_IMPORTED_MODULE_4__.RSAKey);

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/index.js":
                    /*!*********************************************!*\
                      !*** ./node_modules/jsencrypt/lib/index.js ***!
                      \*********************************************/
                    /***/function node_modulesJsencryptLibIndexJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"JSEncrypt": function JSEncrypt() {
                                return (/* reexport safe */_JSEncrypt__WEBPACK_IMPORTED_MODULE_0__.JSEncrypt
                                );
                            },
                            /* harmony export */"default": function _default() {
                                return __WEBPACK_DEFAULT_EXPORT__;
                            }
                            /* harmony export */ });
                        /* harmony import */var _JSEncrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./JSEncrypt */"./node_modules/jsencrypt/lib/JSEncrypt.js");

                        /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = _JSEncrypt__WEBPACK_IMPORTED_MODULE_0__.JSEncrypt;

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/asn1js/asn1.js":
                    /*!*******************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/asn1js/asn1.js ***!
                      \*******************************************************/
                    /***/function node_modulesJsencryptLibLibAsn1jsAsn1Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"Stream": function Stream() {
                                return (/* binding */_Stream
                                );
                            },
                            /* harmony export */"ASN1": function ASN1() {
                                return (/* binding */_ASN
                                );
                            },
                            /* harmony export */"ASN1Tag": function ASN1Tag() {
                                return (/* binding */_ASN1Tag
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _int10__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./int10 */"./node_modules/jsencrypt/lib/lib/asn1js/int10.js");
                        // ASN.1 JavaScript decoder
                        // Copyright (c) 2008-2014 Lapo Luchini <lapo@lapo.it>
                        // Permission to use, copy, modify, and/or distribute this software for any
                        // purpose with or without fee is hereby granted, provided that the above
                        // copyright notice and this permission notice appear in all copies.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
                        // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
                        // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
                        // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
                        // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
                        // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
                        // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
                        /*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
                        /*global oids */

                        var ellipsis = '\u2026';
                        var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
                        var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
                        function stringCut(str, len) {
                            if (str.length > len) {
                                str = str.substring(0, len) + ellipsis;
                            }
                            return str;
                        }
                        var _Stream = /** @class */function () {
                            function Stream(enc, pos) {
                                this.hexDigits = "0123456789ABCDEF";
                                if (enc instanceof Stream) {
                                    this.enc = enc.enc;
                                    this.pos = enc.pos;
                                } else {
                                    // enc should be an array or a binary string
                                    this.enc = enc;
                                    this.pos = pos;
                                }
                            }
                            Stream.prototype.get = function (pos) {
                                if (pos === undefined) {
                                    pos = this.pos++;
                                }
                                if (pos >= this.enc.length) {
                                    throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
                                }
                                return "string" === typeof this.enc ? this.enc.charCodeAt(pos) : this.enc[pos];
                            };
                            Stream.prototype.hexByte = function (b) {
                                return this.hexDigits.charAt(b >> 4 & 0xF) + this.hexDigits.charAt(b & 0xF);
                            };
                            Stream.prototype.hexDump = function (start, end, raw) {
                                var s = "";
                                for (var i = start; i < end; ++i) {
                                    s += this.hexByte(this.get(i));
                                    if (raw !== true) {
                                        switch (i & 0xF) {
                                            case 0x7:
                                                s += "  ";
                                                break;
                                            case 0xF:
                                                s += "\n";
                                                break;
                                            default:
                                                s += " ";
                                        }
                                    }
                                }
                                return s;
                            };
                            Stream.prototype.isASCII = function (start, end) {
                                for (var i = start; i < end; ++i) {
                                    var c = this.get(i);
                                    if (c < 32 || c > 176) {
                                        return false;
                                    }
                                }
                                return true;
                            };
                            Stream.prototype.parseStringISO = function (start, end) {
                                var s = "";
                                for (var i = start; i < end; ++i) {
                                    s += String.fromCharCode(this.get(i));
                                }
                                return s;
                            };
                            Stream.prototype.parseStringUTF = function (start, end) {
                                var s = "";
                                for (var i = start; i < end;) {
                                    var c = this.get(i++);
                                    if (c < 128) {
                                        s += String.fromCharCode(c);
                                    } else if (c > 191 && c < 224) {
                                        s += String.fromCharCode((c & 0x1F) << 6 | this.get(i++) & 0x3F);
                                    } else {
                                        s += String.fromCharCode((c & 0x0F) << 12 | (this.get(i++) & 0x3F) << 6 | this.get(i++) & 0x3F);
                                    }
                                }
                                return s;
                            };
                            Stream.prototype.parseStringBMP = function (start, end) {
                                var str = "";
                                var hi;
                                var lo;
                                for (var i = start; i < end;) {
                                    hi = this.get(i++);
                                    lo = this.get(i++);
                                    str += String.fromCharCode(hi << 8 | lo);
                                }
                                return str;
                            };
                            Stream.prototype.parseTime = function (start, end, shortYear) {
                                var s = this.parseStringISO(start, end);
                                var m = (shortYear ? reTimeS : reTimeL).exec(s);
                                if (!m) {
                                    return "Unrecognized time: " + s;
                                }
                                if (shortYear) {
                                    // to avoid querying the timer, use the fixed range [1970, 2069]
                                    // it will conform with ITU X.400 [-10, +40] sliding window until 2030
                                    m[1] = +m[1];
                                    m[1] += +m[1] < 70 ? 2000 : 1900;
                                }
                                s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
                                if (m[5]) {
                                    s += ":" + m[5];
                                    if (m[6]) {
                                        s += ":" + m[6];
                                        if (m[7]) {
                                            s += "." + m[7];
                                        }
                                    }
                                }
                                if (m[8]) {
                                    s += " UTC";
                                    if (m[8] != "Z") {
                                        s += m[8];
                                        if (m[9]) {
                                            s += ":" + m[9];
                                        }
                                    }
                                }
                                return s;
                            };
                            Stream.prototype.parseInteger = function (start, end) {
                                var v = this.get(start);
                                var neg = v > 127;
                                var pad = neg ? 255 : 0;
                                var len;
                                var s = "";
                                // skip unuseful bits (not allowed in DER)
                                while (v == pad && ++start < end) {
                                    v = this.get(start);
                                }
                                len = end - start;
                                if (len === 0) {
                                    return neg ? -1 : 0;
                                }
                                // show bit length of huge integers
                                if (len > 4) {
                                    s = v;
                                    len <<= 3;
                                    while (((+s ^ pad) & 0x80) == 0) {
                                        s = +s << 1;
                                        --len;
                                    }
                                    s = "(" + len + " bit)\n";
                                }
                                // decode the integer
                                if (neg) {
                                    v = v - 256;
                                }
                                var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10(v);
                                for (var i = start + 1; i < end; ++i) {
                                    n.mulAdd(256, this.get(i));
                                }
                                return s + n.toString();
                            };
                            Stream.prototype.parseBitString = function (start, end, maxLength) {
                                var unusedBit = this.get(start);
                                var lenBit = (end - start - 1 << 3) - unusedBit;
                                var intro = "(" + lenBit + " bit)\n";
                                var s = "";
                                for (var i = start + 1; i < end; ++i) {
                                    var b = this.get(i);
                                    var skip = i == end - 1 ? unusedBit : 0;
                                    for (var j = 7; j >= skip; --j) {
                                        s += b >> j & 1 ? "1" : "0";
                                    }
                                    if (s.length > maxLength) {
                                        return intro + stringCut(s, maxLength);
                                    }
                                }
                                return intro + s;
                            };
                            Stream.prototype.parseOctetString = function (start, end, maxLength) {
                                if (this.isASCII(start, end)) {
                                    return stringCut(this.parseStringISO(start, end), maxLength);
                                }
                                var len = end - start;
                                var s = "(" + len + " byte)\n";
                                maxLength /= 2; // we work in bytes
                                if (len > maxLength) {
                                    end = start + maxLength;
                                }
                                for (var i = start; i < end; ++i) {
                                    s += this.hexByte(this.get(i));
                                }
                                if (len > maxLength) {
                                    s += ellipsis;
                                }
                                return s;
                            };
                            Stream.prototype.parseOID = function (start, end, maxLength) {
                                var s = "";
                                var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();
                                var bits = 0;
                                for (var i = start; i < end; ++i) {
                                    var v = this.get(i);
                                    n.mulAdd(128, v & 0x7F);
                                    bits += 7;
                                    if (!(v & 0x80)) {
                                        // finished
                                        if (s === "") {
                                            n = n.simplify();
                                            if (n instanceof _int10__WEBPACK_IMPORTED_MODULE_0__.Int10) {
                                                n.sub(80);
                                                s = "2." + n.toString();
                                            } else {
                                                var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                                                s = m + "." + (n - m * 40);
                                            }
                                        } else {
                                            s += "." + n.toString();
                                        }
                                        if (s.length > maxLength) {
                                            return stringCut(s, maxLength);
                                        }
                                        n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();
                                        bits = 0;
                                    }
                                }
                                if (bits > 0) {
                                    s += ".incomplete";
                                }
                                return s;
                            };
                            return Stream;
                        }();

                        var _ASN = /** @class */function () {
                            function ASN1(stream, header, length, tag, sub) {
                                if (!(tag instanceof _ASN1Tag)) {
                                    throw new Error("Invalid tag value.");
                                }
                                this.stream = stream;
                                this.header = header;
                                this.length = length;
                                this.tag = tag;
                                this.sub = sub;
                            }
                            ASN1.prototype.typeName = function () {
                                switch (this.tag.tagClass) {
                                    case 0:
                                        // universal
                                        switch (this.tag.tagNumber) {
                                            case 0x00:
                                                return "EOC";
                                            case 0x01:
                                                return "BOOLEAN";
                                            case 0x02:
                                                return "INTEGER";
                                            case 0x03:
                                                return "BIT_STRING";
                                            case 0x04:
                                                return "OCTET_STRING";
                                            case 0x05:
                                                return "NULL";
                                            case 0x06:
                                                return "OBJECT_IDENTIFIER";
                                            case 0x07:
                                                return "ObjectDescriptor";
                                            case 0x08:
                                                return "EXTERNAL";
                                            case 0x09:
                                                return "REAL";
                                            case 0x0A:
                                                return "ENUMERATED";
                                            case 0x0B:
                                                return "EMBEDDED_PDV";
                                            case 0x0C:
                                                return "UTF8String";
                                            case 0x10:
                                                return "SEQUENCE";
                                            case 0x11:
                                                return "SET";
                                            case 0x12:
                                                return "NumericString";
                                            case 0x13:
                                                return "PrintableString"; // ASCII subset
                                            case 0x14:
                                                return "TeletexString"; // aka T61String
                                            case 0x15:
                                                return "VideotexString";
                                            case 0x16:
                                                return "IA5String"; // ASCII
                                            case 0x17:
                                                return "UTCTime";
                                            case 0x18:
                                                return "GeneralizedTime";
                                            case 0x19:
                                                return "GraphicString";
                                            case 0x1A:
                                                return "VisibleString"; // ASCII subset
                                            case 0x1B:
                                                return "GeneralString";
                                            case 0x1C:
                                                return "UniversalString";
                                            case 0x1E:
                                                return "BMPString";
                                        }
                                        return "Universal_" + this.tag.tagNumber.toString();
                                    case 1:
                                        return "Application_" + this.tag.tagNumber.toString();
                                    case 2:
                                        return "[" + this.tag.tagNumber.toString() + "]"; // Context
                                    case 3:
                                        return "Private_" + this.tag.tagNumber.toString();
                                }
                            };
                            ASN1.prototype.content = function (maxLength) {
                                if (this.tag === undefined) {
                                    return null;
                                }
                                if (maxLength === undefined) {
                                    maxLength = Infinity;
                                }
                                var content = this.posContent();
                                var len = Math.abs(this.length);
                                if (!this.tag.isUniversal()) {
                                    if (this.sub !== null) {
                                        return "(" + this.sub.length + " elem)";
                                    }
                                    return this.stream.parseOctetString(content, content + len, maxLength);
                                }
                                switch (this.tag.tagNumber) {
                                    case 0x01:
                                        // BOOLEAN
                                        return this.stream.get(content) === 0 ? "false" : "true";
                                    case 0x02:
                                        // INTEGER
                                        return this.stream.parseInteger(content, content + len);
                                    case 0x03:
                                        // BIT_STRING
                                        return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(content, content + len, maxLength);
                                    case 0x04:
                                        // OCTET_STRING
                                        return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(content, content + len, maxLength);
                                    // case 0x05: // NULL
                                    case 0x06:
                                        // OBJECT_IDENTIFIER
                                        return this.stream.parseOID(content, content + len, maxLength);
                                    // case 0x07: // ObjectDescriptor
                                    // case 0x08: // EXTERNAL
                                    // case 0x09: // REAL
                                    // case 0x0A: // ENUMERATED
                                    // case 0x0B: // EMBEDDED_PDV
                                    case 0x10: // SEQUENCE
                                    case 0x11:
                                        // SET
                                        if (this.sub !== null) {
                                            return "(" + this.sub.length + " elem)";
                                        } else {
                                            return "(no elem)";
                                        }
                                    case 0x0C:
                                        // UTF8String
                                        return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
                                    case 0x12: // NumericString
                                    case 0x13: // PrintableString
                                    case 0x14: // TeletexString
                                    case 0x15: // VideotexString
                                    case 0x16: // IA5String
                                    // case 0x19: // GraphicString
                                    case 0x1A:
                                        // VisibleString
                                        // case 0x1B: // GeneralString
                                        // case 0x1C: // UniversalString
                                        return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
                                    case 0x1E:
                                        // BMPString
                                        return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
                                    case 0x17: // UTCTime
                                    case 0x18:
                                        // GeneralizedTime
                                        return this.stream.parseTime(content, content + len, this.tag.tagNumber == 0x17);
                                }
                                return null;
                            };
                            ASN1.prototype.toString = function () {
                                return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (this.sub === null ? "null" : this.sub.length) + "]";
                            };
                            ASN1.prototype.toPrettyString = function (indent) {
                                if (indent === undefined) {
                                    indent = "";
                                }
                                var s = indent + this.typeName() + " @" + this.stream.pos;
                                if (this.length >= 0) {
                                    s += "+";
                                }
                                s += this.length;
                                if (this.tag.tagConstructed) {
                                    s += " (constructed)";
                                } else if (this.tag.isUniversal() && (this.tag.tagNumber == 0x03 || this.tag.tagNumber == 0x04) && this.sub !== null) {
                                    s += " (encapsulates)";
                                }
                                s += "\n";
                                if (this.sub !== null) {
                                    indent += "  ";
                                    for (var i = 0, max = this.sub.length; i < max; ++i) {
                                        s += this.sub[i].toPrettyString(indent);
                                    }
                                }
                                return s;
                            };
                            ASN1.prototype.posStart = function () {
                                return this.stream.pos;
                            };
                            ASN1.prototype.posContent = function () {
                                return this.stream.pos + this.header;
                            };
                            ASN1.prototype.posEnd = function () {
                                return this.stream.pos + this.header + Math.abs(this.length);
                            };
                            ASN1.prototype.toHexString = function () {
                                return this.stream.hexDump(this.posStart(), this.posEnd(), true);
                            };
                            ASN1.decodeLength = function (stream) {
                                var buf = stream.get();
                                var len = buf & 0x7F;
                                if (len == buf) {
                                    return len;
                                }
                                // no reason to use Int10, as it would be a huge buffer anyways
                                if (len > 6) {
                                    throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
                                }
                                if (len === 0) {
                                    return null;
                                } // undefined
                                buf = 0;
                                for (var i = 0; i < len; ++i) {
                                    buf = buf * 256 + stream.get();
                                }
                                return buf;
                            };
                            /**
                             * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
                             * @returns {string}
                             * @public
                             */
                            ASN1.prototype.getHexStringValue = function () {
                                var hexString = this.toHexString();
                                var offset = this.header * 2;
                                var length = this.length * 2;
                                return hexString.substr(offset, length);
                            };
                            ASN1.decode = function (str) {
                                var stream;
                                if (!(str instanceof _Stream)) {
                                    stream = new _Stream(str, 0);
                                } else {
                                    stream = str;
                                }
                                var streamStart = new _Stream(stream);
                                var tag = new _ASN1Tag(stream);
                                var len = ASN1.decodeLength(stream);
                                var start = stream.pos;
                                var header = start - streamStart.pos;
                                var sub = null;
                                var getSub = function getSub() {
                                    var ret = [];
                                    if (len !== null) {
                                        // definite length
                                        var end = start + len;
                                        while (stream.pos < end) {
                                            ret[ret.length] = ASN1.decode(stream);
                                        }
                                        if (stream.pos != end) {
                                            throw new Error("Content size is not correct for container starting at offset " + start);
                                        }
                                    } else {
                                        // undefined length
                                        try {
                                            for (;;) {
                                                var s = ASN1.decode(stream);
                                                if (s.tag.isEOC()) {
                                                    break;
                                                }
                                                ret[ret.length] = s;
                                            }
                                            len = start - stream.pos; // undefined lengths are represented as negative values
                                        } catch (e) {
                                            throw new Error("Exception while decoding undefined length content: " + e);
                                        }
                                    }
                                    return ret;
                                };
                                if (tag.tagConstructed) {
                                    // must have valid content
                                    sub = getSub();
                                } else if (tag.isUniversal() && (tag.tagNumber == 0x03 || tag.tagNumber == 0x04)) {
                                    // sometimes BitString and OctetString are used to encapsulate ASN.1
                                    try {
                                        if (tag.tagNumber == 0x03) {
                                            if (stream.get() != 0) {
                                                throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                                            }
                                        }
                                        sub = getSub();
                                        for (var i = 0; i < sub.length; ++i) {
                                            if (sub[i].tag.isEOC()) {
                                                throw new Error("EOC is not supposed to be actual content.");
                                            }
                                        }
                                    } catch (e) {
                                        // but silently ignore when they don't
                                        sub = null;
                                    }
                                }
                                if (sub === null) {
                                    if (len === null) {
                                        throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
                                    }
                                    stream.pos = start + Math.abs(len);
                                }
                                return new ASN1(streamStart, header, len, tag, sub);
                            };
                            return ASN1;
                        }();

                        var _ASN1Tag = /** @class */function () {
                            function ASN1Tag(stream) {
                                var buf = stream.get();
                                this.tagClass = buf >> 6;
                                this.tagConstructed = (buf & 0x20) !== 0;
                                this.tagNumber = buf & 0x1F;
                                if (this.tagNumber == 0x1F) {
                                    // long tag
                                    var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();
                                    do {
                                        buf = stream.get();
                                        n.mulAdd(128, buf & 0x7F);
                                    } while (buf & 0x80);
                                    this.tagNumber = n.simplify();
                                }
                            }
                            ASN1Tag.prototype.isUniversal = function () {
                                return this.tagClass === 0x00;
                            };
                            ASN1Tag.prototype.isEOC = function () {
                                return this.tagClass === 0x00 && this.tagNumber === 0x00;
                            };
                            return ASN1Tag;
                        }();

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/asn1js/base64.js":
                    /*!*********************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/asn1js/base64.js ***!
                      \*********************************************************/
                    /***/function node_modulesJsencryptLibLibAsn1jsBase64Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"Base64": function Base64() {
                                return (/* binding */_Base
                                );
                            }
                            /* harmony export */ });
                        // Base64 JavaScript decoder
                        // Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
                        // Permission to use, copy, modify, and/or distribute this software for any
                        // purpose with or without fee is hereby granted, provided that the above
                        // copyright notice and this permission notice appear in all copies.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
                        // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
                        // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
                        // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
                        // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
                        // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
                        // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
                        /*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
                        var decoder;
                        var _Base = {
                            decode: function decode(a) {
                                var i;
                                if (decoder === undefined) {
                                    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                                    var ignore = '= \f\n\r\t\xA0\u2028\u2029';
                                    decoder = Object.create(null);
                                    for (i = 0; i < 64; ++i) {
                                        decoder[b64.charAt(i)] = i;
                                    }
                                    decoder['-'] = 62; //+
                                    decoder['_'] = 63; //-
                                    for (i = 0; i < ignore.length; ++i) {
                                        decoder[ignore.charAt(i)] = -1;
                                    }
                                }
                                var out = [];
                                var bits = 0;
                                var char_count = 0;
                                for (i = 0; i < a.length; ++i) {
                                    var c = a.charAt(i);
                                    if (c == "=") {
                                        break;
                                    }
                                    c = decoder[c];
                                    if (c == -1) {
                                        continue;
                                    }
                                    if (c === undefined) {
                                        throw new Error("Illegal character at offset " + i);
                                    }
                                    bits |= c;
                                    if (++char_count >= 4) {
                                        out[out.length] = bits >> 16;
                                        out[out.length] = bits >> 8 & 0xFF;
                                        out[out.length] = bits & 0xFF;
                                        bits = 0;
                                        char_count = 0;
                                    } else {
                                        bits <<= 6;
                                    }
                                }
                                switch (char_count) {
                                    case 1:
                                        throw new Error("Base64 encoding incomplete: at least 2 bits missing");
                                    case 2:
                                        out[out.length] = bits >> 10;
                                        break;
                                    case 3:
                                        out[out.length] = bits >> 16;
                                        out[out.length] = bits >> 8 & 0xFF;
                                        break;
                                }
                                return out;
                            },
                            re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
                            unarmor: function unarmor(a) {
                                var m = _Base.re.exec(a);
                                if (m) {
                                    if (m[1]) {
                                        a = m[1];
                                    } else if (m[2]) {
                                        a = m[2];
                                    } else {
                                        throw new Error("RegExp out of sync");
                                    }
                                }
                                return _Base.decode(a);
                            }
                        };

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/asn1js/hex.js":
                    /*!******************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/asn1js/hex.js ***!
                      \******************************************************/
                    /***/function node_modulesJsencryptLibLibAsn1jsHexJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"Hex": function Hex() {
                                return (/* binding */_Hex
                                );
                            }
                            /* harmony export */ });
                        // Hex JavaScript decoder
                        // Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
                        // Permission to use, copy, modify, and/or distribute this software for any
                        // purpose with or without fee is hereby granted, provided that the above
                        // copyright notice and this permission notice appear in all copies.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
                        // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
                        // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
                        // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
                        // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
                        // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
                        // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
                        /*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
                        var decoder;
                        var _Hex = {
                            decode: function decode(a) {
                                var i;
                                if (decoder === undefined) {
                                    var hex = "0123456789ABCDEF";
                                    var ignore = ' \f\n\r\t\xA0\u2028\u2029';
                                    decoder = {};
                                    for (i = 0; i < 16; ++i) {
                                        decoder[hex.charAt(i)] = i;
                                    }
                                    hex = hex.toLowerCase();
                                    for (i = 10; i < 16; ++i) {
                                        decoder[hex.charAt(i)] = i;
                                    }
                                    for (i = 0; i < ignore.length; ++i) {
                                        decoder[ignore.charAt(i)] = -1;
                                    }
                                }
                                var out = [];
                                var bits = 0;
                                var char_count = 0;
                                for (i = 0; i < a.length; ++i) {
                                    var c = a.charAt(i);
                                    if (c == "=") {
                                        break;
                                    }
                                    c = decoder[c];
                                    if (c == -1) {
                                        continue;
                                    }
                                    if (c === undefined) {
                                        throw new Error("Illegal character at offset " + i);
                                    }
                                    bits |= c;
                                    if (++char_count >= 2) {
                                        out[out.length] = bits;
                                        bits = 0;
                                        char_count = 0;
                                    } else {
                                        bits <<= 4;
                                    }
                                }
                                if (char_count) {
                                    throw new Error("Hex encoding incomplete: 4 bits missing");
                                }
                                return out;
                            }
                        };

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/asn1js/int10.js":
                    /*!********************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/asn1js/int10.js ***!
                      \********************************************************/
                    /***/function node_modulesJsencryptLibLibAsn1jsInt10Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"Int10": function Int10() {
                                return (/* binding */_Int
                                );
                            }
                            /* harmony export */ });
                        // Big integer base-10 printing library
                        // Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
                        // Permission to use, copy, modify, and/or distribute this software for any
                        // purpose with or without fee is hereby granted, provided that the above
                        // copyright notice and this permission notice appear in all copies.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
                        // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
                        // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
                        // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
                        // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
                        // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
                        // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
                        /*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
                        var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
                        var _Int = /** @class */function () {
                            function Int10(value) {
                                this.buf = [+value || 0];
                            }
                            Int10.prototype.mulAdd = function (m, c) {
                                // assert(m <= 256)
                                var b = this.buf;
                                var l = b.length;
                                var i;
                                var t;
                                for (i = 0; i < l; ++i) {
                                    t = b[i] * m + c;
                                    if (t < max) {
                                        c = 0;
                                    } else {
                                        c = 0 | t / max;
                                        t -= c * max;
                                    }
                                    b[i] = t;
                                }
                                if (c > 0) {
                                    b[i] = c;
                                }
                            };
                            Int10.prototype.sub = function (c) {
                                // assert(m <= 256)
                                var b = this.buf;
                                var l = b.length;
                                var i;
                                var t;
                                for (i = 0; i < l; ++i) {
                                    t = b[i] - c;
                                    if (t < 0) {
                                        t += max;
                                        c = 1;
                                    } else {
                                        c = 0;
                                    }
                                    b[i] = t;
                                }
                                while (b[b.length - 1] === 0) {
                                    b.pop();
                                }
                            };
                            Int10.prototype.toString = function (base) {
                                if ((base || 10) != 10) {
                                    throw new Error("only base 10 is supported");
                                }
                                var b = this.buf;
                                var s = b[b.length - 1].toString();
                                for (var i = b.length - 2; i >= 0; --i) {
                                    s += (max + b[i]).toString().substring(1);
                                }
                                return s;
                            };
                            Int10.prototype.valueOf = function () {
                                var b = this.buf;
                                var v = 0;
                                for (var i = b.length - 1; i >= 0; --i) {
                                    v = v * max + b[i];
                                }
                                return v;
                            };
                            Int10.prototype.simplify = function () {
                                var b = this.buf;
                                return b.length == 1 ? b[0] : this;
                            };
                            return Int10;
                        }();

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/base64.js":
                    /*!*******************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/base64.js ***!
                      \*******************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnBase64Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"hex2b64": function hex2b64() {
                                return (/* binding */_hex2b
                                );
                            },
                            /* harmony export */"b64tohex": function b64tohex() {
                                return (/* binding */_b64tohex
                                );
                            },
                            /* harmony export */"b64toBA": function b64toBA() {
                                return (/* binding */_b64toBA
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./util */"./node_modules/jsencrypt/lib/lib/jsbn/util.js");

                        var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                        var b64pad = "=";
                        function _hex2b(h) {
                            var i;
                            var c;
                            var ret = "";
                            for (i = 0; i + 3 <= h.length; i += 3) {
                                c = parseInt(h.substring(i, i + 3), 16);
                                ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
                            }
                            if (i + 1 == h.length) {
                                c = parseInt(h.substring(i, i + 1), 16);
                                ret += b64map.charAt(c << 2);
                            } else if (i + 2 == h.length) {
                                c = parseInt(h.substring(i, i + 2), 16);
                                ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
                            }
                            while ((ret.length & 3) > 0) {
                                ret += b64pad;
                            }
                            return ret;
                        }
                        // convert a base64 string to hex
                        function _b64tohex(s) {
                            var ret = "";
                            var i;
                            var k = 0; // b64 state, 0-3
                            var slop = 0;
                            for (i = 0; i < s.length; ++i) {
                                if (s.charAt(i) == b64pad) {
                                    break;
                                }
                                var v = b64map.indexOf(s.charAt(i));
                                if (v < 0) {
                                    continue;
                                }
                                if (k == 0) {
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v >> 2);
                                    slop = v & 3;
                                    k = 1;
                                } else if (k == 1) {
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop << 2 | v >> 4);
                                    slop = v & 0xf;
                                    k = 2;
                                } else if (k == 2) {
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop);
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v >> 2);
                                    slop = v & 3;
                                    k = 3;
                                } else {
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop << 2 | v >> 4);
                                    ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v & 0xf);
                                    k = 0;
                                }
                            }
                            if (k == 1) {
                                ret += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop << 2);
                            }
                            return ret;
                        }
                        // convert a base64 string to a byte/number array
                        function _b64toBA(s) {
                            // piggyback on b64tohex for now, optimize later
                            var h = _b64tohex(s);
                            var i;
                            var a = [];
                            for (i = 0; 2 * i < h.length; ++i) {
                                a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);
                            }
                            return a;
                        }

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js":
                    /*!*****************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js ***!
                      \*****************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnJsbnJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"BigInteger": function BigInteger() {
                                return (/* binding */_BigInteger
                                );
                            },
                            /* harmony export */"nbi": function nbi() {
                                return (/* binding */_nbi
                                );
                            },
                            /* harmony export */"parseBigInt": function parseBigInt() {
                                return (/* binding */_parseBigInt
                                );
                            },
                            /* harmony export */"intAt": function intAt() {
                                return (/* binding */_intAt
                                );
                            },
                            /* harmony export */"nbv": function nbv() {
                                return (/* binding */_nbv
                                );
                            },
                            /* harmony export */"nbits": function nbits() {
                                return (/* binding */_nbits
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./util */"./node_modules/jsencrypt/lib/lib/jsbn/util.js");
                        // Copyright (c) 2005  Tom Wu
                        // All Rights Reserved.
                        // See "LICENSE" for details.
                        // Basic JavaScript BN library - subset useful for RSA encryption.

                        // Bits per digit
                        var dbits;
                        // JavaScript engine analysis
                        var canary = 0xdeadbeefcafe;
                        var j_lm = (canary & 0xffffff) == 0xefcafe;
                        //#region
                        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
                        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
                        //#endregion
                        // (public) Constructor
                        var _BigInteger = /** @class */function () {
                            function BigInteger(a, b, c) {
                                if (a != null) {
                                    if ("number" == typeof a) {
                                        this.fromNumber(a, b, c);
                                    } else if (b == null && "string" != typeof a) {
                                        this.fromString(a, 256);
                                    } else {
                                        this.fromString(a, b);
                                    }
                                }
                            }
                            //#region PUBLIC
                            // BigInteger.prototype.toString = bnToString;
                            // (public) return string representation in given radix
                            BigInteger.prototype.toString = function (b) {
                                if (this.s < 0) {
                                    return "-" + this.negate().toString(b);
                                }
                                var k;
                                if (b == 16) {
                                    k = 4;
                                } else if (b == 8) {
                                    k = 3;
                                } else if (b == 2) {
                                    k = 1;
                                } else if (b == 32) {
                                    k = 5;
                                } else if (b == 4) {
                                    k = 2;
                                } else {
                                    return this.toRadix(b);
                                }
                                var km = (1 << k) - 1;
                                var d;
                                var m = false;
                                var r = "";
                                var i = this.t;
                                var p = this.DB - i * this.DB % k;
                                if (i-- > 0) {
                                    if (p < this.DB && (d = this[i] >> p) > 0) {
                                        m = true;
                                        r = (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(d);
                                    }
                                    while (i >= 0) {
                                        if (p < k) {
                                            d = (this[i] & (1 << p) - 1) << k - p;
                                            d |= this[--i] >> (p += this.DB - k);
                                        } else {
                                            d = this[i] >> (p -= k) & km;
                                            if (p <= 0) {
                                                p += this.DB;
                                                --i;
                                            }
                                        }
                                        if (d > 0) {
                                            m = true;
                                        }
                                        if (m) {
                                            r += (0, _util__WEBPACK_IMPORTED_MODULE_0__.int2char)(d);
                                        }
                                    }
                                }
                                return m ? r : "0";
                            };
                            // BigInteger.prototype.negate = bnNegate;
                            // (public) -this
                            BigInteger.prototype.negate = function () {
                                var r = _nbi();
                                BigInteger.ZERO.subTo(this, r);
                                return r;
                            };
                            // BigInteger.prototype.abs = bnAbs;
                            // (public) |this|
                            BigInteger.prototype.abs = function () {
                                return this.s < 0 ? this.negate() : this;
                            };
                            // BigInteger.prototype.compareTo = bnCompareTo;
                            // (public) return + if this > a, - if this < a, 0 if equal
                            BigInteger.prototype.compareTo = function (a) {
                                var r = this.s - a.s;
                                if (r != 0) {
                                    return r;
                                }
                                var i = this.t;
                                r = i - a.t;
                                if (r != 0) {
                                    return this.s < 0 ? -r : r;
                                }
                                while (--i >= 0) {
                                    if ((r = this[i] - a[i]) != 0) {
                                        return r;
                                    }
                                }
                                return 0;
                            };
                            // BigInteger.prototype.bitLength = bnBitLength;
                            // (public) return the number of bits in "this"
                            BigInteger.prototype.bitLength = function () {
                                if (this.t <= 0) {
                                    return 0;
                                }
                                return this.DB * (this.t - 1) + _nbits(this[this.t - 1] ^ this.s & this.DM);
                            };
                            // BigInteger.prototype.mod = bnMod;
                            // (public) this mod a
                            BigInteger.prototype.mod = function (a) {
                                var r = _nbi();
                                this.abs().divRemTo(a, null, r);
                                if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
                                    a.subTo(r, r);
                                }
                                return r;
                            };
                            // BigInteger.prototype.modPowInt = bnModPowInt;
                            // (public) this^e % m, 0 <= e < 2^32
                            BigInteger.prototype.modPowInt = function (e, m) {
                                var z;
                                if (e < 256 || m.isEven()) {
                                    z = new Classic(m);
                                } else {
                                    z = new Montgomery(m);
                                }
                                return this.exp(e, z);
                            };
                            // BigInteger.prototype.clone = bnClone;
                            // (public)
                            BigInteger.prototype.clone = function () {
                                var r = _nbi();
                                this.copyTo(r);
                                return r;
                            };
                            // BigInteger.prototype.intValue = bnIntValue;
                            // (public) return value as integer
                            BigInteger.prototype.intValue = function () {
                                if (this.s < 0) {
                                    if (this.t == 1) {
                                        return this[0] - this.DV;
                                    } else if (this.t == 0) {
                                        return -1;
                                    }
                                } else if (this.t == 1) {
                                    return this[0];
                                } else if (this.t == 0) {
                                    return 0;
                                }
                                // assumes 16 < DB < 32
                                return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
                            };
                            // BigInteger.prototype.byteValue = bnByteValue;
                            // (public) return value as byte
                            BigInteger.prototype.byteValue = function () {
                                return this.t == 0 ? this.s : this[0] << 24 >> 24;
                            };
                            // BigInteger.prototype.shortValue = bnShortValue;
                            // (public) return value as short (assumes DB>=16)
                            BigInteger.prototype.shortValue = function () {
                                return this.t == 0 ? this.s : this[0] << 16 >> 16;
                            };
                            // BigInteger.prototype.signum = bnSigNum;
                            // (public) 0 if this == 0, 1 if this > 0
                            BigInteger.prototype.signum = function () {
                                if (this.s < 0) {
                                    return -1;
                                } else if (this.t <= 0 || this.t == 1 && this[0] <= 0) {
                                    return 0;
                                } else {
                                    return 1;
                                }
                            };
                            // BigInteger.prototype.toByteArray = bnToByteArray;
                            // (public) convert to bigendian byte array
                            BigInteger.prototype.toByteArray = function () {
                                var i = this.t;
                                var r = [];
                                r[0] = this.s;
                                var p = this.DB - i * this.DB % 8;
                                var d;
                                var k = 0;
                                if (i-- > 0) {
                                    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                                        r[k++] = d | this.s << this.DB - p;
                                    }
                                    while (i >= 0) {
                                        if (p < 8) {
                                            d = (this[i] & (1 << p) - 1) << 8 - p;
                                            d |= this[--i] >> (p += this.DB - 8);
                                        } else {
                                            d = this[i] >> (p -= 8) & 0xff;
                                            if (p <= 0) {
                                                p += this.DB;
                                                --i;
                                            }
                                        }
                                        if ((d & 0x80) != 0) {
                                            d |= -256;
                                        }
                                        if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                                            ++k;
                                        }
                                        if (k > 0 || d != this.s) {
                                            r[k++] = d;
                                        }
                                    }
                                }
                                return r;
                            };
                            // BigInteger.prototype.equals = bnEquals;
                            BigInteger.prototype.equals = function (a) {
                                return this.compareTo(a) == 0;
                            };
                            // BigInteger.prototype.min = bnMin;
                            BigInteger.prototype.min = function (a) {
                                return this.compareTo(a) < 0 ? this : a;
                            };
                            // BigInteger.prototype.max = bnMax;
                            BigInteger.prototype.max = function (a) {
                                return this.compareTo(a) > 0 ? this : a;
                            };
                            // BigInteger.prototype.and = bnAnd;
                            BigInteger.prototype.and = function (a) {
                                var r = _nbi();
                                this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_and, r);
                                return r;
                            };
                            // BigInteger.prototype.or = bnOr;
                            BigInteger.prototype.or = function (a) {
                                var r = _nbi();
                                this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_or, r);
                                return r;
                            };
                            // BigInteger.prototype.xor = bnXor;
                            BigInteger.prototype.xor = function (a) {
                                var r = _nbi();
                                this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_xor, r);
                                return r;
                            };
                            // BigInteger.prototype.andNot = bnAndNot;
                            BigInteger.prototype.andNot = function (a) {
                                var r = _nbi();
                                this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_andnot, r);
                                return r;
                            };
                            // BigInteger.prototype.not = bnNot;
                            // (public) ~this
                            BigInteger.prototype.not = function () {
                                var r = _nbi();
                                for (var i = 0; i < this.t; ++i) {
                                    r[i] = this.DM & ~this[i];
                                }
                                r.t = this.t;
                                r.s = ~this.s;
                                return r;
                            };
                            // BigInteger.prototype.shiftLeft = bnShiftLeft;
                            // (public) this << n
                            BigInteger.prototype.shiftLeft = function (n) {
                                var r = _nbi();
                                if (n < 0) {
                                    this.rShiftTo(-n, r);
                                } else {
                                    this.lShiftTo(n, r);
                                }
                                return r;
                            };
                            // BigInteger.prototype.shiftRight = bnShiftRight;
                            // (public) this >> n
                            BigInteger.prototype.shiftRight = function (n) {
                                var r = _nbi();
                                if (n < 0) {
                                    this.lShiftTo(-n, r);
                                } else {
                                    this.rShiftTo(n, r);
                                }
                                return r;
                            };
                            // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
                            // (public) returns index of lowest 1-bit (or -1 if none)
                            BigInteger.prototype.getLowestSetBit = function () {
                                for (var i = 0; i < this.t; ++i) {
                                    if (this[i] != 0) {
                                        return i * this.DB + (0, _util__WEBPACK_IMPORTED_MODULE_0__.lbit)(this[i]);
                                    }
                                }
                                if (this.s < 0) {
                                    return this.t * this.DB;
                                }
                                return -1;
                            };
                            // BigInteger.prototype.bitCount = bnBitCount;
                            // (public) return number of set bits
                            BigInteger.prototype.bitCount = function () {
                                var r = 0;
                                var x = this.s & this.DM;
                                for (var i = 0; i < this.t; ++i) {
                                    r += (0, _util__WEBPACK_IMPORTED_MODULE_0__.cbit)(this[i] ^ x);
                                }
                                return r;
                            };
                            // BigInteger.prototype.testBit = bnTestBit;
                            // (public) true iff nth bit is set
                            BigInteger.prototype.testBit = function (n) {
                                var j = Math.floor(n / this.DB);
                                if (j >= this.t) {
                                    return this.s != 0;
                                }
                                return (this[j] & 1 << n % this.DB) != 0;
                            };
                            // BigInteger.prototype.setBit = bnSetBit;
                            // (public) this | (1<<n)
                            BigInteger.prototype.setBit = function (n) {
                                return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_or);
                            };
                            // BigInteger.prototype.clearBit = bnClearBit;
                            // (public) this & ~(1<<n)
                            BigInteger.prototype.clearBit = function (n) {
                                return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_andnot);
                            };
                            // BigInteger.prototype.flipBit = bnFlipBit;
                            // (public) this ^ (1<<n)
                            BigInteger.prototype.flipBit = function (n) {
                                return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_xor);
                            };
                            // BigInteger.prototype.add = bnAdd;
                            // (public) this + a
                            BigInteger.prototype.add = function (a) {
                                var r = _nbi();
                                this.addTo(a, r);
                                return r;
                            };
                            // BigInteger.prototype.subtract = bnSubtract;
                            // (public) this - a
                            BigInteger.prototype.subtract = function (a) {
                                var r = _nbi();
                                this.subTo(a, r);
                                return r;
                            };
                            // BigInteger.prototype.multiply = bnMultiply;
                            // (public) this * a
                            BigInteger.prototype.multiply = function (a) {
                                var r = _nbi();
                                this.multiplyTo(a, r);
                                return r;
                            };
                            // BigInteger.prototype.divide = bnDivide;
                            // (public) this / a
                            BigInteger.prototype.divide = function (a) {
                                var r = _nbi();
                                this.divRemTo(a, r, null);
                                return r;
                            };
                            // BigInteger.prototype.remainder = bnRemainder;
                            // (public) this % a
                            BigInteger.prototype.remainder = function (a) {
                                var r = _nbi();
                                this.divRemTo(a, null, r);
                                return r;
                            };
                            // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
                            // (public) [this/a,this%a]
                            BigInteger.prototype.divideAndRemainder = function (a) {
                                var q = _nbi();
                                var r = _nbi();
                                this.divRemTo(a, q, r);
                                return [q, r];
                            };
                            // BigInteger.prototype.modPow = bnModPow;
                            // (public) this^e % m (HAC 14.85)
                            BigInteger.prototype.modPow = function (e, m) {
                                var i = e.bitLength();
                                var k;
                                var r = _nbv(1);
                                var z;
                                if (i <= 0) {
                                    return r;
                                } else if (i < 18) {
                                    k = 1;
                                } else if (i < 48) {
                                    k = 3;
                                } else if (i < 144) {
                                    k = 4;
                                } else if (i < 768) {
                                    k = 5;
                                } else {
                                    k = 6;
                                }
                                if (i < 8) {
                                    z = new Classic(m);
                                } else if (m.isEven()) {
                                    z = new Barrett(m);
                                } else {
                                    z = new Montgomery(m);
                                }
                                // precomputation
                                var g = [];
                                var n = 3;
                                var k1 = k - 1;
                                var km = (1 << k) - 1;
                                g[1] = z.convert(this);
                                if (k > 1) {
                                    var g2 = _nbi();
                                    z.sqrTo(g[1], g2);
                                    while (n <= km) {
                                        g[n] = _nbi();
                                        z.mulTo(g2, g[n - 2], g[n]);
                                        n += 2;
                                    }
                                }
                                var j = e.t - 1;
                                var w;
                                var is1 = true;
                                var r2 = _nbi();
                                var t;
                                i = _nbits(e[j]) - 1;
                                while (j >= 0) {
                                    if (i >= k1) {
                                        w = e[j] >> i - k1 & km;
                                    } else {
                                        w = (e[j] & (1 << i + 1) - 1) << k1 - i;
                                        if (j > 0) {
                                            w |= e[j - 1] >> this.DB + i - k1;
                                        }
                                    }
                                    n = k;
                                    while ((w & 1) == 0) {
                                        w >>= 1;
                                        --n;
                                    }
                                    if ((i -= n) < 0) {
                                        i += this.DB;
                                        --j;
                                    }
                                    if (is1) {
                                        // ret == 1, don't bother squaring or multiplying it
                                        g[w].copyTo(r);
                                        is1 = false;
                                    } else {
                                        while (n > 1) {
                                            z.sqrTo(r, r2);
                                            z.sqrTo(r2, r);
                                            n -= 2;
                                        }
                                        if (n > 0) {
                                            z.sqrTo(r, r2);
                                        } else {
                                            t = r;
                                            r = r2;
                                            r2 = t;
                                        }
                                        z.mulTo(r2, g[w], r);
                                    }
                                    while (j >= 0 && (e[j] & 1 << i) == 0) {
                                        z.sqrTo(r, r2);
                                        t = r;
                                        r = r2;
                                        r2 = t;
                                        if (--i < 0) {
                                            i = this.DB - 1;
                                            --j;
                                        }
                                    }
                                }
                                return z.revert(r);
                            };
                            // BigInteger.prototype.modInverse = bnModInverse;
                            // (public) 1/this % m (HAC 14.61)
                            BigInteger.prototype.modInverse = function (m) {
                                var ac = m.isEven();
                                if (this.isEven() && ac || m.signum() == 0) {
                                    return BigInteger.ZERO;
                                }
                                var u = m.clone();
                                var v = this.clone();
                                var a = _nbv(1);
                                var b = _nbv(0);
                                var c = _nbv(0);
                                var d = _nbv(1);
                                while (u.signum() != 0) {
                                    while (u.isEven()) {
                                        u.rShiftTo(1, u);
                                        if (ac) {
                                            if (!a.isEven() || !b.isEven()) {
                                                a.addTo(this, a);
                                                b.subTo(m, b);
                                            }
                                            a.rShiftTo(1, a);
                                        } else if (!b.isEven()) {
                                            b.subTo(m, b);
                                        }
                                        b.rShiftTo(1, b);
                                    }
                                    while (v.isEven()) {
                                        v.rShiftTo(1, v);
                                        if (ac) {
                                            if (!c.isEven() || !d.isEven()) {
                                                c.addTo(this, c);
                                                d.subTo(m, d);
                                            }
                                            c.rShiftTo(1, c);
                                        } else if (!d.isEven()) {
                                            d.subTo(m, d);
                                        }
                                        d.rShiftTo(1, d);
                                    }
                                    if (u.compareTo(v) >= 0) {
                                        u.subTo(v, u);
                                        if (ac) {
                                            a.subTo(c, a);
                                        }
                                        b.subTo(d, b);
                                    } else {
                                        v.subTo(u, v);
                                        if (ac) {
                                            c.subTo(a, c);
                                        }
                                        d.subTo(b, d);
                                    }
                                }
                                if (v.compareTo(BigInteger.ONE) != 0) {
                                    return BigInteger.ZERO;
                                }
                                if (d.compareTo(m) >= 0) {
                                    return d.subtract(m);
                                }
                                if (d.signum() < 0) {
                                    d.addTo(m, d);
                                } else {
                                    return d;
                                }
                                if (d.signum() < 0) {
                                    return d.add(m);
                                } else {
                                    return d;
                                }
                            };
                            // BigInteger.prototype.pow = bnPow;
                            // (public) this^e
                            BigInteger.prototype.pow = function (e) {
                                return this.exp(e, new NullExp());
                            };
                            // BigInteger.prototype.gcd = bnGCD;
                            // (public) gcd(this,a) (HAC 14.54)
                            BigInteger.prototype.gcd = function (a) {
                                var x = this.s < 0 ? this.negate() : this.clone();
                                var y = a.s < 0 ? a.negate() : a.clone();
                                if (x.compareTo(y) < 0) {
                                    var t = x;
                                    x = y;
                                    y = t;
                                }
                                var i = x.getLowestSetBit();
                                var g = y.getLowestSetBit();
                                if (g < 0) {
                                    return x;
                                }
                                if (i < g) {
                                    g = i;
                                }
                                if (g > 0) {
                                    x.rShiftTo(g, x);
                                    y.rShiftTo(g, y);
                                }
                                while (x.signum() > 0) {
                                    if ((i = x.getLowestSetBit()) > 0) {
                                        x.rShiftTo(i, x);
                                    }
                                    if ((i = y.getLowestSetBit()) > 0) {
                                        y.rShiftTo(i, y);
                                    }
                                    if (x.compareTo(y) >= 0) {
                                        x.subTo(y, x);
                                        x.rShiftTo(1, x);
                                    } else {
                                        y.subTo(x, y);
                                        y.rShiftTo(1, y);
                                    }
                                }
                                if (g > 0) {
                                    y.lShiftTo(g, y);
                                }
                                return y;
                            };
                            // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
                            // (public) test primality with certainty >= 1-.5^t
                            BigInteger.prototype.isProbablePrime = function (t) {
                                var i;
                                var x = this.abs();
                                if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
                                    for (i = 0; i < lowprimes.length; ++i) {
                                        if (x[0] == lowprimes[i]) {
                                            return true;
                                        }
                                    }
                                    return false;
                                }
                                if (x.isEven()) {
                                    return false;
                                }
                                i = 1;
                                while (i < lowprimes.length) {
                                    var m = lowprimes[i];
                                    var j = i + 1;
                                    while (j < lowprimes.length && m < lplim) {
                                        m *= lowprimes[j++];
                                    }
                                    m = x.modInt(m);
                                    while (i < j) {
                                        if (m % lowprimes[i++] == 0) {
                                            return false;
                                        }
                                    }
                                }
                                return x.millerRabin(t);
                            };
                            //#endregion PUBLIC
                            //#region PROTECTED
                            // BigInteger.prototype.copyTo = bnpCopyTo;
                            // (protected) copy this to r
                            BigInteger.prototype.copyTo = function (r) {
                                for (var i = this.t - 1; i >= 0; --i) {
                                    r[i] = this[i];
                                }
                                r.t = this.t;
                                r.s = this.s;
                            };
                            // BigInteger.prototype.fromInt = bnpFromInt;
                            // (protected) set from integer value x, -DV <= x < DV
                            BigInteger.prototype.fromInt = function (x) {
                                this.t = 1;
                                this.s = x < 0 ? -1 : 0;
                                if (x > 0) {
                                    this[0] = x;
                                } else if (x < -1) {
                                    this[0] = x + this.DV;
                                } else {
                                    this.t = 0;
                                }
                            };
                            // BigInteger.prototype.fromString = bnpFromString;
                            // (protected) set from string and radix
                            BigInteger.prototype.fromString = function (s, b) {
                                var k;
                                if (b == 16) {
                                    k = 4;
                                } else if (b == 8) {
                                    k = 3;
                                } else if (b == 256) {
                                    k = 8;
                                    /* byte array */
                                } else if (b == 2) {
                                    k = 1;
                                } else if (b == 32) {
                                    k = 5;
                                } else if (b == 4) {
                                    k = 2;
                                } else {
                                    this.fromRadix(s, b);
                                    return;
                                }
                                this.t = 0;
                                this.s = 0;
                                var i = s.length;
                                var mi = false;
                                var sh = 0;
                                while (--i >= 0) {
                                    var x = k == 8 ? +s[i] & 0xff : _intAt(s, i);
                                    if (x < 0) {
                                        if (s.charAt(i) == "-") {
                                            mi = true;
                                        }
                                        continue;
                                    }
                                    mi = false;
                                    if (sh == 0) {
                                        this[this.t++] = x;
                                    } else if (sh + k > this.DB) {
                                        this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
                                        this[this.t++] = x >> this.DB - sh;
                                    } else {
                                        this[this.t - 1] |= x << sh;
                                    }
                                    sh += k;
                                    if (sh >= this.DB) {
                                        sh -= this.DB;
                                    }
                                }
                                if (k == 8 && (+s[0] & 0x80) != 0) {
                                    this.s = -1;
                                    if (sh > 0) {
                                        this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
                                    }
                                }
                                this.clamp();
                                if (mi) {
                                    BigInteger.ZERO.subTo(this, this);
                                }
                            };
                            // BigInteger.prototype.clamp = bnpClamp;
                            // (protected) clamp off excess high words
                            BigInteger.prototype.clamp = function () {
                                var c = this.s & this.DM;
                                while (this.t > 0 && this[this.t - 1] == c) {
                                    --this.t;
                                }
                            };
                            // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
                            // (protected) r = this << n*DB
                            BigInteger.prototype.dlShiftTo = function (n, r) {
                                var i;
                                for (i = this.t - 1; i >= 0; --i) {
                                    r[i + n] = this[i];
                                }
                                for (i = n - 1; i >= 0; --i) {
                                    r[i] = 0;
                                }
                                r.t = this.t + n;
                                r.s = this.s;
                            };
                            // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
                            // (protected) r = this >> n*DB
                            BigInteger.prototype.drShiftTo = function (n, r) {
                                for (var i = n; i < this.t; ++i) {
                                    r[i - n] = this[i];
                                }
                                r.t = Math.max(this.t - n, 0);
                                r.s = this.s;
                            };
                            // BigInteger.prototype.lShiftTo = bnpLShiftTo;
                            // (protected) r = this << n
                            BigInteger.prototype.lShiftTo = function (n, r) {
                                var bs = n % this.DB;
                                var cbs = this.DB - bs;
                                var bm = (1 << cbs) - 1;
                                var ds = Math.floor(n / this.DB);
                                var c = this.s << bs & this.DM;
                                for (var i = this.t - 1; i >= 0; --i) {
                                    r[i + ds + 1] = this[i] >> cbs | c;
                                    c = (this[i] & bm) << bs;
                                }
                                for (var i = ds - 1; i >= 0; --i) {
                                    r[i] = 0;
                                }
                                r[ds] = c;
                                r.t = this.t + ds + 1;
                                r.s = this.s;
                                r.clamp();
                            };
                            // BigInteger.prototype.rShiftTo = bnpRShiftTo;
                            // (protected) r = this >> n
                            BigInteger.prototype.rShiftTo = function (n, r) {
                                r.s = this.s;
                                var ds = Math.floor(n / this.DB);
                                if (ds >= this.t) {
                                    r.t = 0;
                                    return;
                                }
                                var bs = n % this.DB;
                                var cbs = this.DB - bs;
                                var bm = (1 << bs) - 1;
                                r[0] = this[ds] >> bs;
                                for (var i = ds + 1; i < this.t; ++i) {
                                    r[i - ds - 1] |= (this[i] & bm) << cbs;
                                    r[i - ds] = this[i] >> bs;
                                }
                                if (bs > 0) {
                                    r[this.t - ds - 1] |= (this.s & bm) << cbs;
                                }
                                r.t = this.t - ds;
                                r.clamp();
                            };
                            // BigInteger.prototype.subTo = bnpSubTo;
                            // (protected) r = this - a
                            BigInteger.prototype.subTo = function (a, r) {
                                var i = 0;
                                var c = 0;
                                var m = Math.min(a.t, this.t);
                                while (i < m) {
                                    c += this[i] - a[i];
                                    r[i++] = c & this.DM;
                                    c >>= this.DB;
                                }
                                if (a.t < this.t) {
                                    c -= a.s;
                                    while (i < this.t) {
                                        c += this[i];
                                        r[i++] = c & this.DM;
                                        c >>= this.DB;
                                    }
                                    c += this.s;
                                } else {
                                    c += this.s;
                                    while (i < a.t) {
                                        c -= a[i];
                                        r[i++] = c & this.DM;
                                        c >>= this.DB;
                                    }
                                    c -= a.s;
                                }
                                r.s = c < 0 ? -1 : 0;
                                if (c < -1) {
                                    r[i++] = this.DV + c;
                                } else if (c > 0) {
                                    r[i++] = c;
                                }
                                r.t = i;
                                r.clamp();
                            };
                            // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
                            // (protected) r = this * a, r != this,a (HAC 14.12)
                            // "this" should be the larger one if appropriate.
                            BigInteger.prototype.multiplyTo = function (a, r) {
                                var x = this.abs();
                                var y = a.abs();
                                var i = x.t;
                                r.t = i + y.t;
                                while (--i >= 0) {
                                    r[i] = 0;
                                }
                                for (i = 0; i < y.t; ++i) {
                                    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
                                }
                                r.s = 0;
                                r.clamp();
                                if (this.s != a.s) {
                                    BigInteger.ZERO.subTo(r, r);
                                }
                            };
                            // BigInteger.prototype.squareTo = bnpSquareTo;
                            // (protected) r = this^2, r != this (HAC 14.16)
                            BigInteger.prototype.squareTo = function (r) {
                                var x = this.abs();
                                var i = r.t = 2 * x.t;
                                while (--i >= 0) {
                                    r[i] = 0;
                                }
                                for (i = 0; i < x.t - 1; ++i) {
                                    var c = x.am(i, x[i], r, 2 * i, 0, 1);
                                    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                                        r[i + x.t] -= x.DV;
                                        r[i + x.t + 1] = 1;
                                    }
                                }
                                if (r.t > 0) {
                                    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
                                }
                                r.s = 0;
                                r.clamp();
                            };
                            // BigInteger.prototype.divRemTo = bnpDivRemTo;
                            // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
                            // r != q, this != m.  q or r may be null.
                            BigInteger.prototype.divRemTo = function (m, q, r) {
                                var pm = m.abs();
                                if (pm.t <= 0) {
                                    return;
                                }
                                var pt = this.abs();
                                if (pt.t < pm.t) {
                                    if (q != null) {
                                        q.fromInt(0);
                                    }
                                    if (r != null) {
                                        this.copyTo(r);
                                    }
                                    return;
                                }
                                if (r == null) {
                                    r = _nbi();
                                }
                                var y = _nbi();
                                var ts = this.s;
                                var ms = m.s;
                                var nsh = this.DB - _nbits(pm[pm.t - 1]); // normalize modulus
                                if (nsh > 0) {
                                    pm.lShiftTo(nsh, y);
                                    pt.lShiftTo(nsh, r);
                                } else {
                                    pm.copyTo(y);
                                    pt.copyTo(r);
                                }
                                var ys = y.t;
                                var y0 = y[ys - 1];
                                if (y0 == 0) {
                                    return;
                                }
                                var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
                                var d1 = this.FV / yt;
                                var d2 = (1 << this.F1) / yt;
                                var e = 1 << this.F2;
                                var i = r.t;
                                var j = i - ys;
                                var t = q == null ? _nbi() : q;
                                y.dlShiftTo(j, t);
                                if (r.compareTo(t) >= 0) {
                                    r[r.t++] = 1;
                                    r.subTo(t, r);
                                }
                                BigInteger.ONE.dlShiftTo(ys, t);
                                t.subTo(y, y); // "negative" y so we can replace sub with am later
                                while (y.t < ys) {
                                    y[y.t++] = 0;
                                }
                                while (--j >= 0) {
                                    // Estimate quotient digit
                                    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
                                    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                                        // Try it out
                                        y.dlShiftTo(j, t);
                                        r.subTo(t, r);
                                        while (r[i] < --qd) {
                                            r.subTo(t, r);
                                        }
                                    }
                                }
                                if (q != null) {
                                    r.drShiftTo(ys, q);
                                    if (ts != ms) {
                                        BigInteger.ZERO.subTo(q, q);
                                    }
                                }
                                r.t = ys;
                                r.clamp();
                                if (nsh > 0) {
                                    r.rShiftTo(nsh, r);
                                } // Denormalize remainder
                                if (ts < 0) {
                                    BigInteger.ZERO.subTo(r, r);
                                }
                            };
                            // BigInteger.prototype.invDigit = bnpInvDigit;
                            // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
                            // justification:
                            //         xy == 1 (mod m)
                            //         xy =  1+km
                            //   xy(2-xy) = (1+km)(1-km)
                            // x[y(2-xy)] = 1-k^2m^2
                            // x[y(2-xy)] == 1 (mod m^2)
                            // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
                            // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
                            // JS multiply "overflows" differently from C/C++, so care is needed here.
                            BigInteger.prototype.invDigit = function () {
                                if (this.t < 1) {
                                    return 0;
                                }
                                var x = this[0];
                                if ((x & 1) == 0) {
                                    return 0;
                                }
                                var y = x & 3; // y == 1/x mod 2^2
                                y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4
                                y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8
                                y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16
                                // last step - calculate inverse mod DV directly;
                                // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
                                y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits
                                // we really want the negative inverse, and -DV < y < DV
                                return y > 0 ? this.DV - y : -y;
                            };
                            // BigInteger.prototype.isEven = bnpIsEven;
                            // (protected) true iff this is even
                            BigInteger.prototype.isEven = function () {
                                return (this.t > 0 ? this[0] & 1 : this.s) == 0;
                            };
                            // BigInteger.prototype.exp = bnpExp;
                            // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
                            BigInteger.prototype.exp = function (e, z) {
                                if (e > 0xffffffff || e < 1) {
                                    return BigInteger.ONE;
                                }
                                var r = _nbi();
                                var r2 = _nbi();
                                var g = z.convert(this);
                                var i = _nbits(e) - 1;
                                g.copyTo(r);
                                while (--i >= 0) {
                                    z.sqrTo(r, r2);
                                    if ((e & 1 << i) > 0) {
                                        z.mulTo(r2, g, r);
                                    } else {
                                        var t = r;
                                        r = r2;
                                        r2 = t;
                                    }
                                }
                                return z.revert(r);
                            };
                            // BigInteger.prototype.chunkSize = bnpChunkSize;
                            // (protected) return x s.t. r^x < DV
                            BigInteger.prototype.chunkSize = function (r) {
                                return Math.floor(Math.LN2 * this.DB / Math.log(r));
                            };
                            // BigInteger.prototype.toRadix = bnpToRadix;
                            // (protected) convert to radix string
                            BigInteger.prototype.toRadix = function (b) {
                                if (b == null) {
                                    b = 10;
                                }
                                if (this.signum() == 0 || b < 2 || b > 36) {
                                    return "0";
                                }
                                var cs = this.chunkSize(b);
                                var a = Math.pow(b, cs);
                                var d = _nbv(a);
                                var y = _nbi();
                                var z = _nbi();
                                var r = "";
                                this.divRemTo(d, y, z);
                                while (y.signum() > 0) {
                                    r = (a + z.intValue()).toString(b).substr(1) + r;
                                    y.divRemTo(d, y, z);
                                }
                                return z.intValue().toString(b) + r;
                            };
                            // BigInteger.prototype.fromRadix = bnpFromRadix;
                            // (protected) convert from radix string
                            BigInteger.prototype.fromRadix = function (s, b) {
                                this.fromInt(0);
                                if (b == null) {
                                    b = 10;
                                }
                                var cs = this.chunkSize(b);
                                var d = Math.pow(b, cs);
                                var mi = false;
                                var j = 0;
                                var w = 0;
                                for (var i = 0; i < s.length; ++i) {
                                    var x = _intAt(s, i);
                                    if (x < 0) {
                                        if (s.charAt(i) == "-" && this.signum() == 0) {
                                            mi = true;
                                        }
                                        continue;
                                    }
                                    w = b * w + x;
                                    if (++j >= cs) {
                                        this.dMultiply(d);
                                        this.dAddOffset(w, 0);
                                        j = 0;
                                        w = 0;
                                    }
                                }
                                if (j > 0) {
                                    this.dMultiply(Math.pow(b, j));
                                    this.dAddOffset(w, 0);
                                }
                                if (mi) {
                                    BigInteger.ZERO.subTo(this, this);
                                }
                            };
                            // BigInteger.prototype.fromNumber = bnpFromNumber;
                            // (protected) alternate constructor
                            BigInteger.prototype.fromNumber = function (a, b, c) {
                                if ("number" == typeof b) {
                                    // new BigInteger(int,int,RNG)
                                    if (a < 2) {
                                        this.fromInt(1);
                                    } else {
                                        this.fromNumber(a, c);
                                        if (!this.testBit(a - 1)) {
                                            // force MSB set
                                            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), _util__WEBPACK_IMPORTED_MODULE_0__.op_or, this);
                                        }
                                        if (this.isEven()) {
                                            this.dAddOffset(1, 0);
                                        } // force odd
                                        while (!this.isProbablePrime(b)) {
                                            this.dAddOffset(2, 0);
                                            if (this.bitLength() > a) {
                                                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                                            }
                                        }
                                    }
                                } else {
                                    // new BigInteger(int,RNG)
                                    var x = [];
                                    var t = a & 7;
                                    x.length = (a >> 3) + 1;
                                    b.nextBytes(x);
                                    if (t > 0) {
                                        x[0] &= (1 << t) - 1;
                                    } else {
                                        x[0] = 0;
                                    }
                                    this.fromString(x, 256);
                                }
                            };
                            // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
                            // (protected) r = this op a (bitwise)
                            BigInteger.prototype.bitwiseTo = function (a, op, r) {
                                var i;
                                var f;
                                var m = Math.min(a.t, this.t);
                                for (i = 0; i < m; ++i) {
                                    r[i] = op(this[i], a[i]);
                                }
                                if (a.t < this.t) {
                                    f = a.s & this.DM;
                                    for (i = m; i < this.t; ++i) {
                                        r[i] = op(this[i], f);
                                    }
                                    r.t = this.t;
                                } else {
                                    f = this.s & this.DM;
                                    for (i = m; i < a.t; ++i) {
                                        r[i] = op(f, a[i]);
                                    }
                                    r.t = a.t;
                                }
                                r.s = op(this.s, a.s);
                                r.clamp();
                            };
                            // BigInteger.prototype.changeBit = bnpChangeBit;
                            // (protected) this op (1<<n)
                            BigInteger.prototype.changeBit = function (n, op) {
                                var r = BigInteger.ONE.shiftLeft(n);
                                this.bitwiseTo(r, op, r);
                                return r;
                            };
                            // BigInteger.prototype.addTo = bnpAddTo;
                            // (protected) r = this + a
                            BigInteger.prototype.addTo = function (a, r) {
                                var i = 0;
                                var c = 0;
                                var m = Math.min(a.t, this.t);
                                while (i < m) {
                                    c += this[i] + a[i];
                                    r[i++] = c & this.DM;
                                    c >>= this.DB;
                                }
                                if (a.t < this.t) {
                                    c += a.s;
                                    while (i < this.t) {
                                        c += this[i];
                                        r[i++] = c & this.DM;
                                        c >>= this.DB;
                                    }
                                    c += this.s;
                                } else {
                                    c += this.s;
                                    while (i < a.t) {
                                        c += a[i];
                                        r[i++] = c & this.DM;
                                        c >>= this.DB;
                                    }
                                    c += a.s;
                                }
                                r.s = c < 0 ? -1 : 0;
                                if (c > 0) {
                                    r[i++] = c;
                                } else if (c < -1) {
                                    r[i++] = this.DV + c;
                                }
                                r.t = i;
                                r.clamp();
                            };
                            // BigInteger.prototype.dMultiply = bnpDMultiply;
                            // (protected) this *= n, this >= 0, 1 < n < DV
                            BigInteger.prototype.dMultiply = function (n) {
                                this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
                                ++this.t;
                                this.clamp();
                            };
                            // BigInteger.prototype.dAddOffset = bnpDAddOffset;
                            // (protected) this += n << w words, this >= 0
                            BigInteger.prototype.dAddOffset = function (n, w) {
                                if (n == 0) {
                                    return;
                                }
                                while (this.t <= w) {
                                    this[this.t++] = 0;
                                }
                                this[w] += n;
                                while (this[w] >= this.DV) {
                                    this[w] -= this.DV;
                                    if (++w >= this.t) {
                                        this[this.t++] = 0;
                                    }
                                    ++this[w];
                                }
                            };
                            // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
                            // (protected) r = lower n words of "this * a", a.t <= n
                            // "this" should be the larger one if appropriate.
                            BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
                                var i = Math.min(this.t + a.t, n);
                                r.s = 0; // assumes a,this >= 0
                                r.t = i;
                                while (i > 0) {
                                    r[--i] = 0;
                                }
                                for (var j = r.t - this.t; i < j; ++i) {
                                    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
                                }
                                for (var j = Math.min(a.t, n); i < j; ++i) {
                                    this.am(0, a[i], r, i, 0, n - i);
                                }
                                r.clamp();
                            };
                            // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
                            // (protected) r = "this * a" without lower n words, n > 0
                            // "this" should be the larger one if appropriate.
                            BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
                                --n;
                                var i = r.t = this.t + a.t - n;
                                r.s = 0; // assumes a,this >= 0
                                while (--i >= 0) {
                                    r[i] = 0;
                                }
                                for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
                                    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
                                }
                                r.clamp();
                                r.drShiftTo(1, r);
                            };
                            // BigInteger.prototype.modInt = bnpModInt;
                            // (protected) this % n, n < 2^26
                            BigInteger.prototype.modInt = function (n) {
                                if (n <= 0) {
                                    return 0;
                                }
                                var d = this.DV % n;
                                var r = this.s < 0 ? n - 1 : 0;
                                if (this.t > 0) {
                                    if (d == 0) {
                                        r = this[0] % n;
                                    } else {
                                        for (var i = this.t - 1; i >= 0; --i) {
                                            r = (d * r + this[i]) % n;
                                        }
                                    }
                                }
                                return r;
                            };
                            // BigInteger.prototype.millerRabin = bnpMillerRabin;
                            // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
                            BigInteger.prototype.millerRabin = function (t) {
                                var n1 = this.subtract(BigInteger.ONE);
                                var k = n1.getLowestSetBit();
                                if (k <= 0) {
                                    return false;
                                }
                                var r = n1.shiftRight(k);
                                t = t + 1 >> 1;
                                if (t > lowprimes.length) {
                                    t = lowprimes.length;
                                }
                                var a = _nbi();
                                for (var i = 0; i < t; ++i) {
                                    // Pick bases at random, instead of starting at 2
                                    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
                                    var y = a.modPow(r, this);
                                    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                                        var j = 1;
                                        while (j++ < k && y.compareTo(n1) != 0) {
                                            y = y.modPowInt(2, this);
                                            if (y.compareTo(BigInteger.ONE) == 0) {
                                                return false;
                                            }
                                        }
                                        if (y.compareTo(n1) != 0) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            };
                            // BigInteger.prototype.square = bnSquare;
                            // (public) this^2
                            BigInteger.prototype.square = function () {
                                var r = _nbi();
                                this.squareTo(r);
                                return r;
                            };
                            //#region ASYNC
                            // Public API method
                            BigInteger.prototype.gcda = function (a, callback) {
                                var x = this.s < 0 ? this.negate() : this.clone();
                                var y = a.s < 0 ? a.negate() : a.clone();
                                if (x.compareTo(y) < 0) {
                                    var t = x;
                                    x = y;
                                    y = t;
                                }
                                var i = x.getLowestSetBit();
                                var g = y.getLowestSetBit();
                                if (g < 0) {
                                    callback(x);
                                    return;
                                }
                                if (i < g) {
                                    g = i;
                                }
                                if (g > 0) {
                                    x.rShiftTo(g, x);
                                    y.rShiftTo(g, y);
                                }
                                // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
                                var gcda1 = function gcda1() {
                                    if ((i = x.getLowestSetBit()) > 0) {
                                        x.rShiftTo(i, x);
                                    }
                                    if ((i = y.getLowestSetBit()) > 0) {
                                        y.rShiftTo(i, y);
                                    }
                                    if (x.compareTo(y) >= 0) {
                                        x.subTo(y, x);
                                        x.rShiftTo(1, x);
                                    } else {
                                        y.subTo(x, y);
                                        y.rShiftTo(1, y);
                                    }
                                    if (!(x.signum() > 0)) {
                                        if (g > 0) {
                                            y.lShiftTo(g, y);
                                        }
                                        setTimeout(function () {
                                            callback(y);
                                        }, 0); // escape
                                    } else {
                                        setTimeout(gcda1, 0);
                                    }
                                };
                                setTimeout(gcda1, 10);
                            };
                            // (protected) alternate constructor
                            BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
                                if ("number" == typeof b) {
                                    if (a < 2) {
                                        this.fromInt(1);
                                    } else {
                                        this.fromNumber(a, c);
                                        if (!this.testBit(a - 1)) {
                                            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), _util__WEBPACK_IMPORTED_MODULE_0__.op_or, this);
                                        }
                                        if (this.isEven()) {
                                            this.dAddOffset(1, 0);
                                        }
                                        var bnp_1 = this;
                                        var bnpfn1_1 = function bnpfn1_1() {
                                            bnp_1.dAddOffset(2, 0);
                                            if (bnp_1.bitLength() > a) {
                                                bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                                            }
                                            if (bnp_1.isProbablePrime(b)) {
                                                setTimeout(function () {
                                                    callback();
                                                }, 0); // escape
                                            } else {
                                                setTimeout(bnpfn1_1, 0);
                                            }
                                        };
                                        setTimeout(bnpfn1_1, 0);
                                    }
                                } else {
                                    var x = [];
                                    var t = a & 7;
                                    x.length = (a >> 3) + 1;
                                    b.nextBytes(x);
                                    if (t > 0) {
                                        x[0] &= (1 << t) - 1;
                                    } else {
                                        x[0] = 0;
                                    }
                                    this.fromString(x, 256);
                                }
                            };
                            return BigInteger;
                        }();

                        //#region REDUCERS
                        //#region NullExp
                        var NullExp = /** @class */function () {
                            function NullExp() {}
                            // NullExp.prototype.convert = nNop;
                            NullExp.prototype.convert = function (x) {
                                return x;
                            };
                            // NullExp.prototype.revert = nNop;
                            NullExp.prototype.revert = function (x) {
                                return x;
                            };
                            // NullExp.prototype.mulTo = nMulTo;
                            NullExp.prototype.mulTo = function (x, y, r) {
                                x.multiplyTo(y, r);
                            };
                            // NullExp.prototype.sqrTo = nSqrTo;
                            NullExp.prototype.sqrTo = function (x, r) {
                                x.squareTo(r);
                            };
                            return NullExp;
                        }();
                        // Modular reduction using "classic" algorithm
                        var Classic = /** @class */function () {
                            function Classic(m) {
                                this.m = m;
                            }
                            // Classic.prototype.convert = cConvert;
                            Classic.prototype.convert = function (x) {
                                if (x.s < 0 || x.compareTo(this.m) >= 0) {
                                    return x.mod(this.m);
                                } else {
                                    return x;
                                }
                            };
                            // Classic.prototype.revert = cRevert;
                            Classic.prototype.revert = function (x) {
                                return x;
                            };
                            // Classic.prototype.reduce = cReduce;
                            Classic.prototype.reduce = function (x) {
                                x.divRemTo(this.m, null, x);
                            };
                            // Classic.prototype.mulTo = cMulTo;
                            Classic.prototype.mulTo = function (x, y, r) {
                                x.multiplyTo(y, r);
                                this.reduce(r);
                            };
                            // Classic.prototype.sqrTo = cSqrTo;
                            Classic.prototype.sqrTo = function (x, r) {
                                x.squareTo(r);
                                this.reduce(r);
                            };
                            return Classic;
                        }();
                        //#endregion
                        //#region Montgomery
                        // Montgomery reduction
                        var Montgomery = /** @class */function () {
                            function Montgomery(m) {
                                this.m = m;
                                this.mp = m.invDigit();
                                this.mpl = this.mp & 0x7fff;
                                this.mph = this.mp >> 15;
                                this.um = (1 << m.DB - 15) - 1;
                                this.mt2 = 2 * m.t;
                            }
                            // Montgomery.prototype.convert = montConvert;
                            // xR mod m
                            Montgomery.prototype.convert = function (x) {
                                var r = _nbi();
                                x.abs().dlShiftTo(this.m.t, r);
                                r.divRemTo(this.m, null, r);
                                if (x.s < 0 && r.compareTo(_BigInteger.ZERO) > 0) {
                                    this.m.subTo(r, r);
                                }
                                return r;
                            };
                            // Montgomery.prototype.revert = montRevert;
                            // x/R mod m
                            Montgomery.prototype.revert = function (x) {
                                var r = _nbi();
                                x.copyTo(r);
                                this.reduce(r);
                                return r;
                            };
                            // Montgomery.prototype.reduce = montReduce;
                            // x = x/R mod m (HAC 14.32)
                            Montgomery.prototype.reduce = function (x) {
                                while (x.t <= this.mt2) {
                                    // pad x so am has enough room later
                                    x[x.t++] = 0;
                                }
                                for (var i = 0; i < this.m.t; ++i) {
                                    // faster way of calculating u0 = x[i]*mp mod DV
                                    var j = x[i] & 0x7fff;
                                    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
                                    // use am to combine the multiply-shift-add into one call
                                    j = i + this.m.t;
                                    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                                    // propagate carry
                                    while (x[j] >= x.DV) {
                                        x[j] -= x.DV;
                                        x[++j]++;
                                    }
                                }
                                x.clamp();
                                x.drShiftTo(this.m.t, x);
                                if (x.compareTo(this.m) >= 0) {
                                    x.subTo(this.m, x);
                                }
                            };
                            // Montgomery.prototype.mulTo = montMulTo;
                            // r = "xy/R mod m"; x,y != r
                            Montgomery.prototype.mulTo = function (x, y, r) {
                                x.multiplyTo(y, r);
                                this.reduce(r);
                            };
                            // Montgomery.prototype.sqrTo = montSqrTo;
                            // r = "x^2/R mod m"; x != r
                            Montgomery.prototype.sqrTo = function (x, r) {
                                x.squareTo(r);
                                this.reduce(r);
                            };
                            return Montgomery;
                        }();
                        //#endregion Montgomery
                        //#region Barrett
                        // Barrett modular reduction
                        var Barrett = /** @class */function () {
                            function Barrett(m) {
                                this.m = m;
                                // setup Barrett
                                this.r2 = _nbi();
                                this.q3 = _nbi();
                                _BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
                                this.mu = this.r2.divide(m);
                            }
                            // Barrett.prototype.convert = barrettConvert;
                            Barrett.prototype.convert = function (x) {
                                if (x.s < 0 || x.t > 2 * this.m.t) {
                                    return x.mod(this.m);
                                } else if (x.compareTo(this.m) < 0) {
                                    return x;
                                } else {
                                    var r = _nbi();
                                    x.copyTo(r);
                                    this.reduce(r);
                                    return r;
                                }
                            };
                            // Barrett.prototype.revert = barrettRevert;
                            Barrett.prototype.revert = function (x) {
                                return x;
                            };
                            // Barrett.prototype.reduce = barrettReduce;
                            // x = x mod m (HAC 14.42)
                            Barrett.prototype.reduce = function (x) {
                                x.drShiftTo(this.m.t - 1, this.r2);
                                if (x.t > this.m.t + 1) {
                                    x.t = this.m.t + 1;
                                    x.clamp();
                                }
                                this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
                                this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                                while (x.compareTo(this.r2) < 0) {
                                    x.dAddOffset(1, this.m.t + 1);
                                }
                                x.subTo(this.r2, x);
                                while (x.compareTo(this.m) >= 0) {
                                    x.subTo(this.m, x);
                                }
                            };
                            // Barrett.prototype.mulTo = barrettMulTo;
                            // r = x*y mod m; x,y != r
                            Barrett.prototype.mulTo = function (x, y, r) {
                                x.multiplyTo(y, r);
                                this.reduce(r);
                            };
                            // Barrett.prototype.sqrTo = barrettSqrTo;
                            // r = x^2 mod m; x != r
                            Barrett.prototype.sqrTo = function (x, r) {
                                x.squareTo(r);
                                this.reduce(r);
                            };
                            return Barrett;
                        }();
                        //#endregion
                        //#endregion REDUCERS
                        // return new, unset BigInteger
                        function _nbi() {
                            return new _BigInteger(null);
                        }
                        function _parseBigInt(str, r) {
                            return new _BigInteger(str, r);
                        }
                        // am: Compute w_j += (x*this_i), propagate carries,
                        // c is initial carry, returns final carry.
                        // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
                        // We need to select the fastest one that works in this environment.
                        var inBrowser = typeof navigator !== "undefined";
                        if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
                            // am2 avoids a big mult-and-extract completely.
                            // Max digit bits should be <= 30 because we do bitwise ops
                            // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
                            _BigInteger.prototype.am = function am2(i, x, w, j, c, n) {
                                var xl = x & 0x7fff;
                                var xh = x >> 15;
                                while (--n >= 0) {
                                    var l = this[i] & 0x7fff;
                                    var h = this[i++] >> 15;
                                    var m = xh * l + h * xl;
                                    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
                                    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
                                    w[j++] = l & 0x3fffffff;
                                }
                                return c;
                            };
                            dbits = 30;
                        } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
                            // am1: use a single mult and divide to get the high bits,
                            // max digit bits should be 26 because
                            // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
                            _BigInteger.prototype.am = function am1(i, x, w, j, c, n) {
                                while (--n >= 0) {
                                    var v = x * this[i++] + w[j] + c;
                                    c = Math.floor(v / 0x4000000);
                                    w[j++] = v & 0x3ffffff;
                                }
                                return c;
                            };
                            dbits = 26;
                        } else {
                            // Mozilla/Netscape seems to prefer am3
                            // Alternately, set max digit bits to 28 since some
                            // browsers slow down when dealing with 32-bit numbers.
                            _BigInteger.prototype.am = function am3(i, x, w, j, c, n) {
                                var xl = x & 0x3fff;
                                var xh = x >> 14;
                                while (--n >= 0) {
                                    var l = this[i] & 0x3fff;
                                    var h = this[i++] >> 14;
                                    var m = xh * l + h * xl;
                                    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
                                    c = (l >> 28) + (m >> 14) + xh * h;
                                    w[j++] = l & 0xfffffff;
                                }
                                return c;
                            };
                            dbits = 28;
                        }
                        _BigInteger.prototype.DB = dbits;
                        _BigInteger.prototype.DM = (1 << dbits) - 1;
                        _BigInteger.prototype.DV = 1 << dbits;
                        var BI_FP = 52;
                        _BigInteger.prototype.FV = Math.pow(2, BI_FP);
                        _BigInteger.prototype.F1 = BI_FP - dbits;
                        _BigInteger.prototype.F2 = 2 * dbits - BI_FP;
                        // Digit conversions
                        var BI_RC = [];
                        var rr;
                        var vv;
                        rr = "0".charCodeAt(0);
                        for (vv = 0; vv <= 9; ++vv) {
                            BI_RC[rr++] = vv;
                        }
                        rr = "a".charCodeAt(0);
                        for (vv = 10; vv < 36; ++vv) {
                            BI_RC[rr++] = vv;
                        }
                        rr = "A".charCodeAt(0);
                        for (vv = 10; vv < 36; ++vv) {
                            BI_RC[rr++] = vv;
                        }
                        function _intAt(s, i) {
                            var c = BI_RC[s.charCodeAt(i)];
                            return c == null ? -1 : c;
                        }
                        // return bigint initialized to value
                        function _nbv(i) {
                            var r = _nbi();
                            r.fromInt(i);
                            return r;
                        }
                        // returns bit length of the integer x
                        function _nbits(x) {
                            var r = 1;
                            var t;
                            if ((t = x >>> 16) != 0) {
                                x = t;
                                r += 16;
                            }
                            if ((t = x >> 8) != 0) {
                                x = t;
                                r += 8;
                            }
                            if ((t = x >> 4) != 0) {
                                x = t;
                                r += 4;
                            }
                            if ((t = x >> 2) != 0) {
                                x = t;
                                r += 2;
                            }
                            if ((t = x >> 1) != 0) {
                                x = t;
                                r += 1;
                            }
                            return r;
                        }
                        // "constants"
                        _BigInteger.ZERO = _nbv(0);
                        _BigInteger.ONE = _nbv(1);

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/prng4.js":
                    /*!******************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/prng4.js ***!
                      \******************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnPrng4Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"Arcfour": function Arcfour() {
                                return (/* binding */_Arcfour
                                );
                            },
                            /* harmony export */"prng_newstate": function prng_newstate() {
                                return (/* binding */_prng_newstate
                                );
                            },
                            /* harmony export */"rng_psize": function rng_psize() {
                                return (/* binding */_rng_psize
                                );
                            }
                            /* harmony export */ });
                        // prng4.js - uses Arcfour as a PRNG
                        var _Arcfour = /** @class */function () {
                            function Arcfour() {
                                this.i = 0;
                                this.j = 0;
                                this.S = [];
                            }
                            // Arcfour.prototype.init = ARC4init;
                            // Initialize arcfour context from key, an array of ints, each from [0..255]
                            Arcfour.prototype.init = function (key) {
                                var i;
                                var j;
                                var t;
                                for (i = 0; i < 256; ++i) {
                                    this.S[i] = i;
                                }
                                j = 0;
                                for (i = 0; i < 256; ++i) {
                                    j = j + this.S[i] + key[i % key.length] & 255;
                                    t = this.S[i];
                                    this.S[i] = this.S[j];
                                    this.S[j] = t;
                                }
                                this.i = 0;
                                this.j = 0;
                            };
                            // Arcfour.prototype.next = ARC4next;
                            Arcfour.prototype.next = function () {
                                var t;
                                this.i = this.i + 1 & 255;
                                this.j = this.j + this.S[this.i] & 255;
                                t = this.S[this.i];
                                this.S[this.i] = this.S[this.j];
                                this.S[this.j] = t;
                                return this.S[t + this.S[this.i] & 255];
                            };
                            return Arcfour;
                        }();

                        // Plug in your RNG constructor here
                        function _prng_newstate() {
                            return new _Arcfour();
                        }
                        // Pool size must be a multiple of 4 and greater than 32.
                        // An array of bytes the size of the pool will be passed to init()
                        var _rng_psize = 256;

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/rng.js":
                    /*!****************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/rng.js ***!
                      \****************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnRngJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"SecureRandom": function SecureRandom() {
                                return (/* binding */_SecureRandom
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _prng4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./prng4 */"./node_modules/jsencrypt/lib/lib/jsbn/prng4.js");
                        // Random number generator - requires a PRNG backend, e.g. prng4.js

                        var rng_state;
                        var rng_pool = null;
                        var rng_pptr;
                        // Initialize the pool with junk if needed.
                        if (rng_pool == null) {
                            rng_pool = [];
                            rng_pptr = 0;
                            var t = void 0;
                            if (window.crypto && window.crypto.getRandomValues) {
                                // Extract entropy (2048 bits) from RNG if available
                                var z = new Uint32Array(256);
                                window.crypto.getRandomValues(z);
                                for (t = 0; t < z.length; ++t) {
                                    rng_pool[rng_pptr++] = z[t] & 255;
                                }
                            }
                            // Use mouse events for entropy, if we do not have enough entropy by the time
                            // we need it, entropy will be generated by Math.random.
                            var count = 0;
                            var onMouseMoveListener_1 = function onMouseMoveListener_1(ev) {
                                count = count || 0;
                                if (count >= 256 || rng_pptr >= _prng4__WEBPACK_IMPORTED_MODULE_0__.rng_psize) {
                                    if (window.removeEventListener) {
                                        window.removeEventListener("mousemove", onMouseMoveListener_1, false);
                                    } else if (window.detachEvent) {
                                        window.detachEvent("onmousemove", onMouseMoveListener_1);
                                    }
                                    return;
                                }
                                try {
                                    var mouseCoordinates = ev.x + ev.y;
                                    rng_pool[rng_pptr++] = mouseCoordinates & 255;
                                    count += 1;
                                } catch (e) {
                                    // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
                                }
                            };
                            if (window.addEventListener) {
                                window.addEventListener("mousemove", onMouseMoveListener_1, false);
                            } else if (window.attachEvent) {
                                window.attachEvent("onmousemove", onMouseMoveListener_1);
                            }
                        }
                        function rng_get_byte() {
                            if (rng_state == null) {
                                rng_state = (0, _prng4__WEBPACK_IMPORTED_MODULE_0__.prng_newstate)();
                                // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
                                while (rng_pptr < _prng4__WEBPACK_IMPORTED_MODULE_0__.rng_psize) {
                                    var random = Math.floor(65536 * Math.random());
                                    rng_pool[rng_pptr++] = random & 255;
                                }
                                rng_state.init(rng_pool);
                                for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
                                    rng_pool[rng_pptr] = 0;
                                }
                                rng_pptr = 0;
                            }
                            // TODO: allow reseeding after first request
                            return rng_state.next();
                        }
                        var _SecureRandom = /** @class */function () {
                            function SecureRandom() {}
                            SecureRandom.prototype.nextBytes = function (ba) {
                                for (var i = 0; i < ba.length; ++i) {
                                    ba[i] = rng_get_byte();
                                }
                            };
                            return SecureRandom;
                        }();

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/rsa.js":
                    /*!****************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/rsa.js ***!
                      \****************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnRsaJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"RSAKey": function RSAKey() {
                                return (/* binding */_RSAKey
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _jsbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./jsbn */"./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js");
                        /* harmony import */var _rng__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./rng */"./node_modules/jsencrypt/lib/lib/jsbn/rng.js");
                        // Depends on jsbn.js and rng.js
                        // Version 1.1: support utf-8 encoding in pkcs1pad2
                        // convert a (hex) string to a bignum object


                        // function linebrk(s,n) {
                        //   var ret = "";
                        //   var i = 0;
                        //   while(i + n < s.length) {
                        //     ret += s.substring(i,i+n) + "\n";
                        //     i += n;
                        //   }
                        //   return ret + s.substring(i,s.length);
                        // }
                        // function byte2Hex(b) {
                        //   if(b < 0x10)
                        //     return "0" + b.toString(16);
                        //   else
                        //     return b.toString(16);
                        // }
                        function pkcs1pad1(s, n) {
                            if (n < s.length + 22) {
                                console.error("Message too long for RSA");
                                return null;
                            }
                            var len = n - s.length - 6;
                            var filler = "";
                            for (var f = 0; f < len; f += 2) {
                                filler += "ff";
                            }
                            var m = "0001" + filler + "00" + s;
                            return (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(m, 16);
                        }
                        // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
                        function pkcs1pad2(s, n) {
                            if (n < s.length + 11) {
                                // TODO: fix for utf-8
                                console.error("Message too long for RSA");
                                return null;
                            }
                            var ba = [];
                            var i = s.length - 1;
                            while (i >= 0 && n > 0) {
                                var c = s.charCodeAt(i--);
                                if (c < 128) {
                                    // encode using utf-8
                                    ba[--n] = c;
                                } else if (c > 127 && c < 2048) {
                                    ba[--n] = c & 63 | 128;
                                    ba[--n] = c >> 6 | 192;
                                } else {
                                    ba[--n] = c & 63 | 128;
                                    ba[--n] = c >> 6 & 63 | 128;
                                    ba[--n] = c >> 12 | 224;
                                }
                            }
                            ba[--n] = 0;
                            var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();
                            var x = [];
                            while (n > 2) {
                                // random non-zero pad
                                x[0] = 0;
                                while (x[0] == 0) {
                                    rng.nextBytes(x);
                                }
                                ba[--n] = x[0];
                            }
                            ba[--n] = 2;
                            ba[--n] = 0;
                            return new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(ba);
                        }
                        // "empty" RSA key constructor
                        var _RSAKey = /** @class */function () {
                            function RSAKey() {
                                this.n = null;
                                this.e = 0;
                                this.d = null;
                                this.p = null;
                                this.q = null;
                                this.dmp1 = null;
                                this.dmq1 = null;
                                this.coeff = null;
                            }
                            //#region PROTECTED
                            // protected
                            // RSAKey.prototype.doPublic = RSADoPublic;
                            // Perform raw public operation on "x": return x^e (mod n)
                            RSAKey.prototype.doPublic = function (x) {
                                return x.modPowInt(this.e, this.n);
                            };
                            // RSAKey.prototype.doPrivate = RSADoPrivate;
                            // Perform raw private operation on "x": return x^d (mod n)
                            RSAKey.prototype.doPrivate = function (x) {
                                if (this.p == null || this.q == null) {
                                    return x.modPow(this.d, this.n);
                                }
                                // TODO: re-calculate any missing CRT params
                                var xp = x.mod(this.p).modPow(this.dmp1, this.p);
                                var xq = x.mod(this.q).modPow(this.dmq1, this.q);
                                while (xp.compareTo(xq) < 0) {
                                    xp = xp.add(this.p);
                                }
                                return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
                            };
                            //#endregion PROTECTED
                            //#region PUBLIC
                            // RSAKey.prototype.setPublic = RSASetPublic;
                            // Set the public key fields N and e from hex strings
                            RSAKey.prototype.setPublic = function (N, E) {
                                if (N != null && E != null && N.length > 0 && E.length > 0) {
                                    this.n = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);
                                    this.e = parseInt(E, 16);
                                } else {
                                    console.error("Invalid RSA public key");
                                }
                            };
                            // RSAKey.prototype.encrypt = RSAEncrypt;
                            // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
                            RSAKey.prototype.encrypt = function (text) {
                                var maxLength = this.n.bitLength() + 7 >> 3;
                                var m = pkcs1pad2(text, maxLength);
                                if (m == null) {
                                    return null;
                                }
                                var c = this.doPublic(m);
                                if (c == null) {
                                    return null;
                                }
                                var h = c.toString(16);
                                var length = h.length;
                                // fix zero before result
                                for (var i = 0; i < maxLength * 2 - length; i++) {
                                    h = "0" + h;
                                }
                                return h;
                            };
                            // RSAKey.prototype.setPrivate = RSASetPrivate;
                            // Set the private key fields N, e, and d from hex strings
                            RSAKey.prototype.setPrivate = function (N, E, D) {
                                if (N != null && E != null && N.length > 0 && E.length > 0) {
                                    this.n = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);
                                    this.e = parseInt(E, 16);
                                    this.d = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(D, 16);
                                } else {
                                    console.error("Invalid RSA private key");
                                }
                            };
                            // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
                            // Set the private key fields N, e, d and CRT params from hex strings
                            RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
                                if (N != null && E != null && N.length > 0 && E.length > 0) {
                                    this.n = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);
                                    this.e = parseInt(E, 16);
                                    this.d = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(D, 16);
                                    this.p = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(P, 16);
                                    this.q = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(Q, 16);
                                    this.dmp1 = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(DP, 16);
                                    this.dmq1 = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(DQ, 16);
                                    this.coeff = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(C, 16);
                                } else {
                                    console.error("Invalid RSA private key");
                                }
                            };
                            // RSAKey.prototype.generate = RSAGenerate;
                            // Generate a new random private key B bits long, using public expt E
                            RSAKey.prototype.generate = function (B, E) {
                                var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();
                                var qs = B >> 1;
                                this.e = parseInt(E, 16);
                                var ee = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(E, 16);
                                for (;;) {
                                    for (;;) {
                                        this.p = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(B - qs, 1, rng);
                                        if (this.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                                            break;
                                        }
                                    }
                                    for (;;) {
                                        this.q = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(qs, 1, rng);
                                        if (this.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                                            break;
                                        }
                                    }
                                    if (this.p.compareTo(this.q) <= 0) {
                                        var t = this.p;
                                        this.p = this.q;
                                        this.q = t;
                                    }
                                    var p1 = this.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);
                                    var q1 = this.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);
                                    var phi = p1.multiply(q1);
                                    if (phi.gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0) {
                                        this.n = this.p.multiply(this.q);
                                        this.d = ee.modInverse(phi);
                                        this.dmp1 = this.d.mod(p1);
                                        this.dmq1 = this.d.mod(q1);
                                        this.coeff = this.q.modInverse(this.p);
                                        break;
                                    }
                                }
                            };
                            // RSAKey.prototype.decrypt = RSADecrypt;
                            // Return the PKCS#1 RSA decryption of "ctext".
                            // "ctext" is an even-length hex string and the output is a plain string.
                            RSAKey.prototype.decrypt = function (ctext) {
                                var c = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(ctext, 16);
                                var m = this.doPrivate(c);
                                if (m == null) {
                                    return null;
                                }
                                return pkcs1unpad2(m, this.n.bitLength() + 7 >> 3);
                            };
                            // Generate a new random private key B bits long, using public expt E
                            RSAKey.prototype.generateAsync = function (B, E, callback) {
                                var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();
                                var qs = B >> 1;
                                this.e = parseInt(E, 16);
                                var ee = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(E, 16);
                                var rsa = this;
                                // These functions have non-descript names because they were originally for(;;) loops.
                                // I don't know about cryptography to give them better names than loop1-4.
                                var loop1 = function loop1() {
                                    var loop4 = function loop4() {
                                        if (rsa.p.compareTo(rsa.q) <= 0) {
                                            var t = rsa.p;
                                            rsa.p = rsa.q;
                                            rsa.q = t;
                                        }
                                        var p1 = rsa.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);
                                        var q1 = rsa.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);
                                        var phi = p1.multiply(q1);
                                        if (phi.gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0) {
                                            rsa.n = rsa.p.multiply(rsa.q);
                                            rsa.d = ee.modInverse(phi);
                                            rsa.dmp1 = rsa.d.mod(p1);
                                            rsa.dmq1 = rsa.d.mod(q1);
                                            rsa.coeff = rsa.q.modInverse(rsa.p);
                                            setTimeout(function () {
                                                callback();
                                            }, 0); // escape
                                        } else {
                                            setTimeout(loop1, 0);
                                        }
                                    };
                                    var loop3 = function loop3() {
                                        rsa.q = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.nbi)();
                                        rsa.q.fromNumberAsync(qs, 1, rng, function () {
                                            rsa.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcda(ee, function (r) {
                                                if (r.compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                                                    setTimeout(loop4, 0);
                                                } else {
                                                    setTimeout(loop3, 0);
                                                }
                                            });
                                        });
                                    };
                                    var loop2 = function loop2() {
                                        rsa.p = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.nbi)();
                                        rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                                            rsa.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcda(ee, function (r) {
                                                if (r.compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                                                    setTimeout(loop3, 0);
                                                } else {
                                                    setTimeout(loop2, 0);
                                                }
                                            });
                                        });
                                    };
                                    setTimeout(loop2, 0);
                                };
                                setTimeout(loop1, 0);
                            };
                            RSAKey.prototype.sign = function (text, digestMethod, digestName) {
                                var header = getDigestHeader(digestName);
                                var digest = header + digestMethod(text).toString();
                                var m = pkcs1pad1(digest, this.n.bitLength() / 4);
                                if (m == null) {
                                    return null;
                                }
                                var c = this.doPrivate(m);
                                if (c == null) {
                                    return null;
                                }
                                var h = c.toString(16);
                                if ((h.length & 1) == 0) {
                                    return h;
                                } else {
                                    return "0" + h;
                                }
                            };
                            RSAKey.prototype.verify = function (text, signature, digestMethod) {
                                var c = (0, _jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(signature, 16);
                                var m = this.doPublic(c);
                                if (m == null) {
                                    return null;
                                }
                                var unpadded = m.toString(16).replace(/^1f+00/, "");
                                var digest = removeDigestHeader(unpadded);
                                return digest == digestMethod(text).toString();
                            };
                            return RSAKey;
                        }();

                        // Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
                        function pkcs1unpad2(d, n) {
                            var b = d.toByteArray();
                            var i = 0;
                            while (i < b.length && b[i] == 0) {
                                ++i;
                            }
                            if (b.length - i != n - 1 || b[i] != 2) {
                                return null;
                            }
                            ++i;
                            while (b[i] != 0) {
                                if (++i >= b.length) {
                                    return null;
                                }
                            }
                            var ret = "";
                            while (++i < b.length) {
                                var c = b[i] & 255;
                                if (c < 128) {
                                    // utf-8 decode
                                    ret += String.fromCharCode(c);
                                } else if (c > 191 && c < 224) {
                                    ret += String.fromCharCode((c & 31) << 6 | b[i + 1] & 63);
                                    ++i;
                                } else {
                                    ret += String.fromCharCode((c & 15) << 12 | (b[i + 1] & 63) << 6 | b[i + 2] & 63);
                                    i += 2;
                                }
                            }
                            return ret;
                        }
                        // https://tools.ietf.org/html/rfc3447#page-43
                        var DIGEST_HEADERS = {
                            md2: "3020300c06082a864886f70d020205000410",
                            md5: "3020300c06082a864886f70d020505000410",
                            sha1: "3021300906052b0e03021a05000414",
                            sha224: "302d300d06096086480165030402040500041c",
                            sha256: "3031300d060960864801650304020105000420",
                            sha384: "3041300d060960864801650304020205000430",
                            sha512: "3051300d060960864801650304020305000440",
                            ripemd160: "3021300906052b2403020105000414"
                        };
                        function getDigestHeader(name) {
                            return DIGEST_HEADERS[name] || "";
                        }
                        function removeDigestHeader(str) {
                            for (var name_1 in DIGEST_HEADERS) {
                                if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
                                    var header = DIGEST_HEADERS[name_1];
                                    var len = header.length;
                                    if (str.substr(0, len) == header) {
                                        return str.substr(len);
                                    }
                                }
                            }
                            return str;
                        }
                        // Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
                        // function RSAEncryptB64(text) {
                        //  var h = this.encrypt(text);
                        //  if(h) return hex2b64(h); else return null;
                        // }
                        // public
                        // RSAKey.prototype.encrypt_b64 = RSAEncryptB64;


                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsbn/util.js":
                    /*!*****************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsbn/util.js ***!
                      \*****************************************************/
                    /***/function node_modulesJsencryptLibLibJsbnUtilJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"int2char": function int2char() {
                                return (/* binding */_int2char
                                );
                            },
                            /* harmony export */"op_and": function op_and() {
                                return (/* binding */_op_and
                                );
                            },
                            /* harmony export */"op_or": function op_or() {
                                return (/* binding */_op_or
                                );
                            },
                            /* harmony export */"op_xor": function op_xor() {
                                return (/* binding */_op_xor
                                );
                            },
                            /* harmony export */"op_andnot": function op_andnot() {
                                return (/* binding */_op_andnot
                                );
                            },
                            /* harmony export */"lbit": function lbit() {
                                return (/* binding */_lbit
                                );
                            },
                            /* harmony export */"cbit": function cbit() {
                                return (/* binding */_cbit
                                );
                            }
                            /* harmony export */ });
                        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
                        function _int2char(n) {
                            return BI_RM.charAt(n);
                        }
                        //#region BIT_OPERATIONS
                        // (public) this & a
                        function _op_and(x, y) {
                            return x & y;
                        }
                        // (public) this | a
                        function _op_or(x, y) {
                            return x | y;
                        }
                        // (public) this ^ a
                        function _op_xor(x, y) {
                            return x ^ y;
                        }
                        // (public) this & ~a
                        function _op_andnot(x, y) {
                            return x & ~y;
                        }
                        // return index of lowest 1-bit in x, x < 2^31
                        function _lbit(x) {
                            if (x == 0) {
                                return -1;
                            }
                            var r = 0;
                            if ((x & 0xffff) == 0) {
                                x >>= 16;
                                r += 16;
                            }
                            if ((x & 0xff) == 0) {
                                x >>= 8;
                                r += 8;
                            }
                            if ((x & 0xf) == 0) {
                                x >>= 4;
                                r += 4;
                            }
                            if ((x & 3) == 0) {
                                x >>= 2;
                                r += 2;
                            }
                            if ((x & 1) == 0) {
                                ++r;
                            }
                            return r;
                        }
                        // return number of 1 bits in x
                        function _cbit(x) {
                            var r = 0;
                            while (x != 0) {
                                x &= x - 1;
                                ++r;
                            }
                            return r;
                        }
                        //#endregion BIT_OPERATIONS


                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsrsasign/asn1-1.0.js":
                    /*!**************************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsrsasign/asn1-1.0.js ***!
                      \**************************************************************/
                    /***/function node_modulesJsencryptLibLibJsrsasignAsn110Js(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"KJUR": function KJUR() {
                                return (/* binding */_KJUR2
                                );
                            }
                            /* harmony export */ });
                        /* harmony import */var _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../jsbn/jsbn */"./node_modules/jsencrypt/lib/lib/jsbn/jsbn.js");
                        /* harmony import */var _yahoo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./yahoo */"./node_modules/jsencrypt/lib/lib/jsrsasign/yahoo.js");
                        /* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
                         */
                        /*
                         * asn1.js - ASN.1 DER encoder classes
                         *
                         * Copyright (c) 2013-2017 Kenji Urushima (kenji.urushima@gmail.com)
                         *
                         * This software is licensed under the terms of the MIT License.
                         * https://kjur.github.io/jsrsasign/license
                         *
                         * The above copyright and license notice shall be
                         * included in all copies or substantial portions of the Software.
                         */

                        /**
                         * @fileOverview
                         * @name asn1-1.0.js
                         * @author Kenji Urushima kenji.urushima@gmail.com
                         * @version asn1 1.0.13 (2017-Jun-02)
                         * @since jsrsasign 2.1
                         * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
                         */
                        /**
                         * kjur's class library name space
                         * <p>
                         * This name space provides following name spaces:
                         * <ul>
                         * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
                         * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
                         * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
                         * class and utilities</li>
                         * </ul>
                         * </p>
                         * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
                         * @name KJUR
                         * @namespace kjur's class library name space
                         */
                        var _KJUR2 = {};
                        /**
                         * kjur's ASN.1 class library name space
                         * <p>
                         * This is ITU-T X.690 ASN.1 DER encoder class library and
                         * class structure and methods is very similar to
                         * org.bouncycastle.asn1 package of
                         * well known BouncyCaslte Cryptography Library.
                         * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
                         * Here are ASN.1 DER primitive classes.
                         * <ul>
                         * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
                         * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
                         * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
                         * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
                         * <li>0x05 {@link KJUR.asn1.DERNull}</li>
                         * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
                         * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
                         * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
                         * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
                         * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
                         * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
                         * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
                         * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
                         * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
                         * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
                         * <li>0x31 {@link KJUR.asn1.DERSet}</li>
                         * </ul>
                         * <h4>OTHER ASN.1 CLASSES</h4>
                         * <ul>
                         * <li>{@link KJUR.asn1.ASN1Object}</li>
                         * <li>{@link KJUR.asn1.DERAbstractString}</li>
                         * <li>{@link KJUR.asn1.DERAbstractTime}</li>
                         * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
                         * <li>{@link KJUR.asn1.DERTaggedObject}</li>
                         * </ul>
                         * <h4>SUB NAME SPACES</h4>
                         * <ul>
                         * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
                         * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
                         * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
                         * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
                         * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
                         * </ul>
                         * </p>
                         * NOTE: Please ignore method summary and document of this namespace.
                         * This caused by a bug of jsdoc2.
                         * @name KJUR.asn1
                         * @namespace
                         */
                        if (typeof _KJUR2.asn1 == "undefined" || !_KJUR2.asn1) _KJUR2.asn1 = {};
                        /**
                         * ASN1 utilities class
                         * @name KJUR.asn1.ASN1Util
                         * @class ASN1 utilities class
                         * @since asn1 1.0.2
                         */
                        _KJUR2.asn1.ASN1Util = new function () {
                            this.integerToByteHex = function (i) {
                                var h = i.toString(16);
                                if (h.length % 2 == 1) h = '0' + h;
                                return h;
                            };
                            this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {
                                var h = bigIntegerValue.toString(16);
                                if (h.substr(0, 1) != '-') {
                                    if (h.length % 2 == 1) {
                                        h = '0' + h;
                                    } else {
                                        if (!h.match(/^[0-7]/)) {
                                            h = '00' + h;
                                        }
                                    }
                                } else {
                                    var hPos = h.substr(1);
                                    var xorLen = hPos.length;
                                    if (xorLen % 2 == 1) {
                                        xorLen += 1;
                                    } else {
                                        if (!h.match(/^[0-7]/)) {
                                            xorLen += 2;
                                        }
                                    }
                                    var hMask = '';
                                    for (var i = 0; i < xorLen; i++) {
                                        hMask += 'f';
                                    }
                                    var biMask = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(hMask, 16);
                                    var biNeg = biMask.xor(bigIntegerValue).add(_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);
                                    h = biNeg.toString(16).replace(/^-/, '');
                                }
                                return h;
                            };
                            /**
                             * get PEM string from hexadecimal data and header string
                             * @name getPEMStringFromHex
                             * @memberOf KJUR.asn1.ASN1Util
                             * @function
                             * @param {String} dataHex hexadecimal string of PEM body
                             * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
                             * @return {String} PEM formatted string of input data
                             * @description
                             * This method converts a hexadecimal string to a PEM string with
                             * a specified header. Its line break will be CRLF("\r\n").
                             * @example
                             * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
                             * // value of pem will be:
                             * -----BEGIN PRIVATE KEY-----
                             * YWFh
                             * -----END PRIVATE KEY-----
                             */
                            this.getPEMStringFromHex = function (dataHex, pemHeader) {
                                return hextopem(dataHex, pemHeader);
                            };
                            /**
                             * generate ASN1Object specifed by JSON parameters
                             * @name newObject
                             * @memberOf KJUR.asn1.ASN1Util
                             * @function
                             * @param {Array} param JSON parameter to generate ASN1Object
                             * @return {KJUR.asn1.ASN1Object} generated object
                             * @since asn1 1.0.3
                             * @description
                             * generate any ASN1Object specified by JSON param
                             * including ASN.1 primitive or structured.
                             * Generally 'param' can be described as follows:
                             * <blockquote>
                             * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
                             * </blockquote>
                             * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
                             * <ul>
                             * <li>'bool' - DERBoolean</li>
                             * <li>'int' - DERInteger</li>
                             * <li>'bitstr' - DERBitString</li>
                             * <li>'octstr' - DEROctetString</li>
                             * <li>'null' - DERNull</li>
                             * <li>'oid' - DERObjectIdentifier</li>
                             * <li>'enum' - DEREnumerated</li>
                             * <li>'utf8str' - DERUTF8String</li>
                             * <li>'numstr' - DERNumericString</li>
                             * <li>'prnstr' - DERPrintableString</li>
                             * <li>'telstr' - DERTeletexString</li>
                             * <li>'ia5str' - DERIA5String</li>
                             * <li>'utctime' - DERUTCTime</li>
                             * <li>'gentime' - DERGeneralizedTime</li>
                             * <li>'seq' - DERSequence</li>
                             * <li>'set' - DERSet</li>
                             * <li>'tag' - DERTaggedObject</li>
                             * </ul>
                             * @example
                             * newObject({'prnstr': 'aaa'});
                             * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
                             * // ASN.1 Tagged Object
                             * newObject({'tag': {'tag': 'a1',
                             *                    'explicit': true,
                             *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
                             * // more simple representation of ASN.1 Tagged Object
                             * newObject({'tag': ['a1',
                             *                    true,
                             *                    {'seq': [
                             *                      {'int': 3},
                             *                      {'prnstr': 'aaa'}]}
                             *                   ]});
                             */
                            this.newObject = function (param) {
                                var _KJUR = _KJUR2,
                                    _KJUR_asn1 = _KJUR.asn1,
                                    _DERBoolean = _KJUR_asn1.DERBoolean,
                                    _DERInteger = _KJUR_asn1.DERInteger,
                                    _DERBitString = _KJUR_asn1.DERBitString,
                                    _DEROctetString = _KJUR_asn1.DEROctetString,
                                    _DERNull = _KJUR_asn1.DERNull,
                                    _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
                                    _DEREnumerated = _KJUR_asn1.DEREnumerated,
                                    _DERUTF8String = _KJUR_asn1.DERUTF8String,
                                    _DERNumericString = _KJUR_asn1.DERNumericString,
                                    _DERPrintableString = _KJUR_asn1.DERPrintableString,
                                    _DERTeletexString = _KJUR_asn1.DERTeletexString,
                                    _DERIA5String = _KJUR_asn1.DERIA5String,
                                    _DERUTCTime = _KJUR_asn1.DERUTCTime,
                                    _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
                                    _DERSequence = _KJUR_asn1.DERSequence,
                                    _DERSet = _KJUR_asn1.DERSet,
                                    _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
                                    _newObject = _KJUR_asn1.ASN1Util.newObject;
                                var keys = Object.keys(param);
                                if (keys.length != 1) throw "key of param shall be only one.";
                                var key = keys[0];
                                if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1) throw "undefined key: " + key;
                                if (key == "bool") return new _DERBoolean(param[key]);
                                if (key == "int") return new _DERInteger(param[key]);
                                if (key == "bitstr") return new _DERBitString(param[key]);
                                if (key == "octstr") return new _DEROctetString(param[key]);
                                if (key == "null") return new _DERNull(param[key]);
                                if (key == "oid") return new _DERObjectIdentifier(param[key]);
                                if (key == "enum") return new _DEREnumerated(param[key]);
                                if (key == "utf8str") return new _DERUTF8String(param[key]);
                                if (key == "numstr") return new _DERNumericString(param[key]);
                                if (key == "prnstr") return new _DERPrintableString(param[key]);
                                if (key == "telstr") return new _DERTeletexString(param[key]);
                                if (key == "ia5str") return new _DERIA5String(param[key]);
                                if (key == "utctime") return new _DERUTCTime(param[key]);
                                if (key == "gentime") return new _DERGeneralizedTime(param[key]);
                                if (key == "seq") {
                                    var paramList = param[key];
                                    var a = [];
                                    for (var i = 0; i < paramList.length; i++) {
                                        var asn1Obj = _newObject(paramList[i]);
                                        a.push(asn1Obj);
                                    }
                                    return new _DERSequence({ 'array': a });
                                }
                                if (key == "set") {
                                    var paramList = param[key];
                                    var a = [];
                                    for (var i = 0; i < paramList.length; i++) {
                                        var asn1Obj = _newObject(paramList[i]);
                                        a.push(asn1Obj);
                                    }
                                    return new _DERSet({ 'array': a });
                                }
                                if (key == "tag") {
                                    var tagParam = param[key];
                                    if (Object.prototype.toString.call(tagParam) === '[object Array]' && tagParam.length == 3) {
                                        var obj = _newObject(tagParam[2]);
                                        return new _DERTaggedObject({ tag: tagParam[0],
                                            explicit: tagParam[1],
                                            obj: obj });
                                    } else {
                                        var newParam = {};
                                        if (tagParam.explicit !== undefined) newParam.explicit = tagParam.explicit;
                                        if (tagParam.tag !== undefined) newParam.tag = tagParam.tag;
                                        if (tagParam.obj === undefined) throw "obj shall be specified for 'tag'.";
                                        newParam.obj = _newObject(tagParam.obj);
                                        return new _DERTaggedObject(newParam);
                                    }
                                }
                            };
                            /**
                             * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
                             * @name jsonToASN1HEX
                             * @memberOf KJUR.asn1.ASN1Util
                             * @function
                             * @param {Array} param JSON parameter to generate ASN1Object
                             * @return hexadecimal string of ASN1Object
                             * @since asn1 1.0.4
                             * @description
                             * As for ASN.1 object representation of JSON object,
                             * please see {@link newObject}.
                             * @example
                             * jsonToASN1HEX({'prnstr': 'aaa'});
                             */
                            this.jsonToASN1HEX = function (param) {
                                var asn1Obj = this.newObject(param);
                                return asn1Obj.getEncodedHex();
                            };
                        }();
                        /**
                         * get dot noted oid number string from hexadecimal value of OID
                         * @name oidHexToInt
                         * @memberOf KJUR.asn1.ASN1Util
                         * @function
                         * @param {String} hex hexadecimal value of object identifier
                         * @return {String} dot noted string of object identifier
                         * @since jsrsasign 4.8.3 asn1 1.0.7
                         * @description
                         * This static method converts from hexadecimal string representation of
                         * ASN.1 value of object identifier to oid number string.
                         * @example
                         * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
                         */
                        _KJUR2.asn1.ASN1Util.oidHexToInt = function (hex) {
                            var s = "";
                            var i01 = parseInt(hex.substr(0, 2), 16);
                            var i0 = Math.floor(i01 / 40);
                            var i1 = i01 % 40;
                            var s = i0 + "." + i1;
                            var binbuf = "";
                            for (var i = 2; i < hex.length; i += 2) {
                                var value = parseInt(hex.substr(i, 2), 16);
                                var bin = ("00000000" + value.toString(2)).slice(-8);
                                binbuf = binbuf + bin.substr(1, 7);
                                if (bin.substr(0, 1) == "0") {
                                    var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(binbuf, 2);
                                    s = s + "." + bi.toString(10);
                                    binbuf = "";
                                }
                            }
                            
                            return s;
                        };
                        /**
                         * get hexadecimal value of object identifier from dot noted oid value
                         * @name oidIntToHex
                         * @memberOf KJUR.asn1.ASN1Util
                         * @function
                         * @param {String} oidString dot noted string of object identifier
                         * @return {String} hexadecimal value of object identifier
                         * @since jsrsasign 4.8.3 asn1 1.0.7
                         * @description
                         * This static method converts from object identifier value string.
                         * to hexadecimal string representation of it.
                         * @example
                         * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
                         */
                        _KJUR2.asn1.ASN1Util.oidIntToHex = function (oidString) {
                            var itox = function itox(i) {
                                var h = i.toString(16);
                                if (h.length == 1) h = '0' + h;
                                return h;
                            };
                            var roidtox = function roidtox(roid) {
                                var h = '';
                                var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(roid, 10);
                                var b = bi.toString(2);
                                var padLen = 7 - b.length % 7;
                                if (padLen == 7) padLen = 0;
                                var bPad = '';
                                for (var i = 0; i < padLen; i++) {
                                    bPad += '0';
                                }b = bPad + b;
                                for (var i = 0; i < b.length - 1; i += 7) {
                                    var b8 = b.substr(i, 7);
                                    if (i != b.length - 7) b8 = '1' + b8;
                                    h += itox(parseInt(b8, 2));
                                }
                                return h;
                            };
                            if (!oidString.match(/^[0-9.]+$/)) {
                                throw "malformed oid string: " + oidString;
                            }
                            var h = '';
                            var a = oidString.split('.');
                            var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
                            h += itox(i0);
                            a.splice(0, 2);
                            for (var i = 0; i < a.length; i++) {
                                h += roidtox(a[i]);
                            }
                            return h;
                        };
                        // ********************************************************************
                        //  Abstract ASN.1 Classes
                        // ********************************************************************
                        // ********************************************************************
                        /**
                         * base class for ASN.1 DER encoder object
                         * @name KJUR.asn1.ASN1Object
                         * @class base class for ASN.1 DER encoder object
                         * @property {Boolean} isModified flag whether internal data was changed
                         * @property {String} hTLV hexadecimal string of ASN.1 TLV
                         * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
                         * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
                         * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
                         * @description
                         */
                        _KJUR2.asn1.ASN1Object = function () {
                            var isModified = true;
                            var hTLV = null;
                            var hT = '00';
                            var hL = '00';
                            var hV = '';
                            /**
                             * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
                             * @name getLengthHexFromValue
                             * @memberOf KJUR.asn1.ASN1Object#
                             * @function
                             * @return {String} hexadecimal string of ASN.1 TLV length(L)
                             */
                            this.getLengthHexFromValue = function () {
                                if (typeof this.hV == "undefined" || this.hV == null) {
                                    throw "this.hV is null or undefined.";
                                }
                                if (this.hV.length % 2 == 1) {
                                    throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
                                }
                                var n = this.hV.length / 2;
                                var hN = n.toString(16);
                                if (hN.length % 2 == 1) {
                                    hN = "0" + hN;
                                }
                                if (n < 128) {
                                    return hN;
                                } else {
                                    var hNlen = hN.length / 2;
                                    if (hNlen > 15) {
                                        throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
                                    }
                                    var head = 128 + hNlen;
                                    return head.toString(16) + hN;
                                }
                            };
                            /**
                             * get hexadecimal string of ASN.1 TLV bytes
                             * @name getEncodedHex
                             * @memberOf KJUR.asn1.ASN1Object#
                             * @function
                             * @return {String} hexadecimal string of ASN.1 TLV
                             */
                            this.getEncodedHex = function () {
                                if (this.hTLV == null || this.isModified) {
                                    this.hV = this.getFreshValueHex();
                                    this.hL = this.getLengthHexFromValue();
                                    this.hTLV = this.hT + this.hL + this.hV;
                                    this.isModified = false;
                                    //alert("first time: " + this.hTLV);
                                }
                                return this.hTLV;
                            };
                            /**
                             * get hexadecimal string of ASN.1 TLV value(V) bytes
                             * @name getValueHex
                             * @memberOf KJUR.asn1.ASN1Object#
                             * @function
                             * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
                             */
                            this.getValueHex = function () {
                                this.getEncodedHex();
                                return this.hV;
                            };
                            this.getFreshValueHex = function () {
                                return '';
                            };
                        };
                        // == BEGIN DERAbstractString ================================================
                        /**
                         * base class for ASN.1 DER string classes
                         * @name KJUR.asn1.DERAbstractString
                         * @class base class for ASN.1 DER string classes
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @property {String} s internal string of value
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>str - specify initial ASN.1 value(V) by a string</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         */
                        _KJUR2.asn1.DERAbstractString = function (params) {
                            _KJUR2.asn1.DERAbstractString.superclass.constructor.call(this);
                            var s = null;
                            var hV = null;
                            /**
                             * get string value of this string object
                             * @name getString
                             * @memberOf KJUR.asn1.DERAbstractString#
                             * @function
                             * @return {String} string value of this string object
                             */
                            this.getString = function () {
                                return this.s;
                            };
                            /**
                             * set value by a string
                             * @name setString
                             * @memberOf KJUR.asn1.DERAbstractString#
                             * @function
                             * @param {String} newS value by a string to set
                             */
                            this.setString = function (newS) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.s = newS;
                                this.hV = stohex(this.s);
                            };
                            /**
                             * set value by a hexadecimal string
                             * @name setStringHex
                             * @memberOf KJUR.asn1.DERAbstractString#
                             * @function
                             * @param {String} newHexString value by a hexadecimal string to set
                             */
                            this.setStringHex = function (newHexString) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.s = null;
                                this.hV = newHexString;
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params == "string") {
                                    this.setString(params);
                                } else if (typeof params['str'] != "undefined") {
                                    this.setString(params['str']);
                                } else if (typeof params['hex'] != "undefined") {
                                    this.setStringHex(params['hex']);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERAbstractString, _KJUR2.asn1.ASN1Object);
                        // == END   DERAbstractString ================================================
                        // == BEGIN DERAbstractTime ==================================================
                        /**
                         * base class for ASN.1 DER Generalized/UTCTime class
                         * @name KJUR.asn1.DERAbstractTime
                         * @class base class for ASN.1 DER Generalized/UTCTime class
                         * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * @see KJUR.asn1.ASN1Object - superclass
                         */
                        _KJUR2.asn1.DERAbstractTime = function (params) {
                            _KJUR2.asn1.DERAbstractTime.superclass.constructor.call(this);
                            var s = null;
                            var date = null;
                            // --- PRIVATE METHODS --------------------
                            this.localDateToUTC = function (d) {
                                utc = d.getTime() + d.getTimezoneOffset() * 60000;
                                var utcDate = new Date(utc);
                                return utcDate;
                            };
                            /*
                             * format date string by Data object
                             * @name formatDate
                             * @memberOf KJUR.asn1.AbstractTime;
                             * @param {Date} dateObject
                             * @param {string} type 'utc' or 'gen'
                             * @param {boolean} withMillis flag for with millisections or not
                             * @description
                             * 'withMillis' flag is supported from asn1 1.0.6.
                             */
                            this.formatDate = function (dateObject, type, withMillis) {
                                var pad = this.zeroPadding;
                                var d = this.localDateToUTC(dateObject);
                                var year = String(d.getFullYear());
                                if (type == 'utc') year = year.substr(2, 2);
                                var month = pad(String(d.getMonth() + 1), 2);
                                var day = pad(String(d.getDate()), 2);
                                var hour = pad(String(d.getHours()), 2);
                                var min = pad(String(d.getMinutes()), 2);
                                var sec = pad(String(d.getSeconds()), 2);
                                var s = year + month + day + hour + min + sec;
                                if (withMillis === true) {
                                    var millis = d.getMilliseconds();
                                    if (millis != 0) {
                                        var sMillis = pad(String(millis), 3);
                                        sMillis = sMillis.replace(/[0]+$/, "");
                                        s = s + "." + sMillis;
                                    }
                                }
                                return s + "Z";
                            };
                            this.zeroPadding = function (s, len) {
                                if (s.length >= len) return s;
                                return new Array(len - s.length + 1).join('0') + s;
                            };
                            // --- PUBLIC METHODS --------------------
                            /**
                             * get string value of this string object
                             * @name getString
                             * @memberOf KJUR.asn1.DERAbstractTime#
                             * @function
                             * @return {String} string value of this time object
                             */
                            this.getString = function () {
                                return this.s;
                            };
                            /**
                             * set value by a string
                             * @name setString
                             * @memberOf KJUR.asn1.DERAbstractTime#
                             * @function
                             * @param {String} newS value by a string to set such like "130430235959Z"
                             */
                            this.setString = function (newS) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.s = newS;
                                this.hV = stohex(newS);
                            };
                            /**
                             * set value by a Date object
                             * @name setByDateValue
                             * @memberOf KJUR.asn1.DERAbstractTime#
                             * @function
                             * @param {Integer} year year of date (ex. 2013)
                             * @param {Integer} month month of date between 1 and 12 (ex. 12)
                             * @param {Integer} day day of month
                             * @param {Integer} hour hours of date
                             * @param {Integer} min minutes of date
                             * @param {Integer} sec seconds of date
                             */
                            this.setByDateValue = function (year, month, day, hour, min, sec) {
                                var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
                                this.setByDate(dateObject);
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERAbstractTime, _KJUR2.asn1.ASN1Object);
                        // == END   DERAbstractTime ==================================================
                        // == BEGIN DERAbstractStructured ============================================
                        /**
                         * base class for ASN.1 DER structured class
                         * @name KJUR.asn1.DERAbstractStructured
                         * @class base class for ASN.1 DER structured class
                         * @property {Array} asn1Array internal array of ASN1Object
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * @see KJUR.asn1.ASN1Object - superclass
                         */
                        _KJUR2.asn1.DERAbstractStructured = function (params) {
                            _KJUR2.asn1.DERAbstractString.superclass.constructor.call(this);
                            var asn1Array = null;
                            /**
                             * set value by array of ASN1Object
                             * @name setByASN1ObjectArray
                             * @memberOf KJUR.asn1.DERAbstractStructured#
                             * @function
                             * @param {array} asn1ObjectArray array of ASN1Object to set
                             */
                            this.setByASN1ObjectArray = function (asn1ObjectArray) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.asn1Array = asn1ObjectArray;
                            };
                            /**
                             * append an ASN1Object to internal array
                             * @name appendASN1Object
                             * @memberOf KJUR.asn1.DERAbstractStructured#
                             * @function
                             * @param {ASN1Object} asn1Object to add
                             */
                            this.appendASN1Object = function (asn1Object) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.asn1Array.push(asn1Object);
                            };
                            this.asn1Array = new Array();
                            if (typeof params != "undefined") {
                                if (typeof params['array'] != "undefined") {
                                    this.asn1Array = params['array'];
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERAbstractStructured, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        //  ASN.1 Object Classes
                        // ********************************************************************
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Boolean
                         * @name KJUR.asn1.DERBoolean
                         * @class class for ASN.1 DER Boolean
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * @see KJUR.asn1.ASN1Object - superclass
                         */
                        _KJUR2.asn1.DERBoolean = function () {
                            _KJUR2.asn1.DERBoolean.superclass.constructor.call(this);
                            this.hT = "01";
                            this.hTLV = "0101ff";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERBoolean, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Integer
                         * @name KJUR.asn1.DERInteger
                         * @class class for ASN.1 DER Integer
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>int - specify initial ASN.1 value(V) by integer value</li>
                         * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         */
                        _KJUR2.asn1.DERInteger = function (params) {
                            _KJUR2.asn1.DERInteger.superclass.constructor.call(this);
                            this.hT = "02";
                            /**
                             * set value by Tom Wu's BigInteger object
                             * @name setByBigInteger
                             * @memberOf KJUR.asn1.DERInteger#
                             * @function
                             * @param {BigInteger} bigIntegerValue to set
                             */
                            this.setByBigInteger = function (bigIntegerValue) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.hV = _KJUR2.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
                            };
                            /**
                             * set value by integer value
                             * @name setByInteger
                             * @memberOf KJUR.asn1.DERInteger
                             * @function
                             * @param {Integer} integer value to set
                             */
                            this.setByInteger = function (intValue) {
                                var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(String(intValue), 10);
                                this.setByBigInteger(bi);
                            };
                            /**
                             * set value by integer value
                             * @name setValueHex
                             * @memberOf KJUR.asn1.DERInteger#
                             * @function
                             * @param {String} hexadecimal string of integer value
                             * @description
                             * <br/>
                             * NOTE: Value shall be represented by minimum octet length of
                             * two's complement representation.
                             * @example
                             * new KJUR.asn1.DERInteger(123);
                             * new KJUR.asn1.DERInteger({'int': 123});
                             * new KJUR.asn1.DERInteger({'hex': '1fad'});
                             */
                            this.setValueHex = function (newHexString) {
                                this.hV = newHexString;
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params['bigint'] != "undefined") {
                                    this.setByBigInteger(params['bigint']);
                                } else if (typeof params['int'] != "undefined") {
                                    this.setByInteger(params['int']);
                                } else if (typeof params == "number") {
                                    this.setByInteger(params);
                                } else if (typeof params['hex'] != "undefined") {
                                    this.setValueHex(params['hex']);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERInteger, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER encoded BitString primitive
                         * @name KJUR.asn1.DERBitString
                         * @class class for ASN.1 DER encoded BitString primitive
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>bin - specify binary string (ex. '10111')</li>
                         * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
                         * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
                         * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
                         * argument for "BitString encapsulates" structure.</li>
                         * </ul>
                         * NOTE1: 'params' can be omitted.<br/>
                         * NOTE2: 'obj' parameter have been supported since
                         * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
                         * @example
                         * // default constructor
                         * o = new KJUR.asn1.DERBitString();
                         * // initialize with binary string
                         * o = new KJUR.asn1.DERBitString({bin: "1011"});
                         * // initialize with boolean array
                         * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
                         * // initialize with hexadecimal string (04 is unused bits)
                         * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
                         * // initialize with ASN1Util.newObject argument for encapsulated
                         * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
                         * // above generates a ASN.1 data like this:
                         * // BIT STRING, encapsulates {
                         * //   SEQUENCE {
                         * //     INTEGER 3
                         * //     PrintableString 'aaa'
                         * //     }
                         * //   }
                         */
                        _KJUR2.asn1.DERBitString = function (params) {
                            if (params !== undefined && typeof params.obj !== "undefined") {
                                var o = _KJUR2.asn1.ASN1Util.newObject(params.obj);
                                params.hex = "00" + o.getEncodedHex();
                            }
                            _KJUR2.asn1.DERBitString.superclass.constructor.call(this);
                            this.hT = "03";
                            /**
                             * set ASN.1 value(V) by a hexadecimal string including unused bits
                             * @name setHexValueIncludingUnusedBits
                             * @memberOf KJUR.asn1.DERBitString#
                             * @function
                             * @param {String} newHexStringIncludingUnusedBits
                             */
                            this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.hV = newHexStringIncludingUnusedBits;
                            };
                            /**
                             * set ASN.1 value(V) by unused bit and hexadecimal string of value
                             * @name setUnusedBitsAndHexValue
                             * @memberOf KJUR.asn1.DERBitString#
                             * @function
                             * @param {Integer} unusedBits
                             * @param {String} hValue
                             */
                            this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {
                                if (unusedBits < 0 || 7 < unusedBits) {
                                    throw "unused bits shall be from 0 to 7: u = " + unusedBits;
                                }
                                var hUnusedBits = "0" + unusedBits;
                                this.hTLV = null;
                                this.isModified = true;
                                this.hV = hUnusedBits + hValue;
                            };
                            /**
                             * set ASN.1 DER BitString by binary string<br/>
                             * @name setByBinaryString
                             * @memberOf KJUR.asn1.DERBitString#
                             * @function
                             * @param {String} binaryString binary value string (i.e. '10111')
                             * @description
                             * Its unused bits will be calculated automatically by length of
                             * 'binaryValue'. <br/>
                             * NOTE: Trailing zeros '0' will be ignored.
                             * @example
                             * o = new KJUR.asn1.DERBitString();
                             * o.setByBooleanArray("01011");
                             */
                            this.setByBinaryString = function (binaryString) {
                                binaryString = binaryString.replace(/0+$/, '');
                                var unusedBits = 8 - binaryString.length % 8;
                                if (unusedBits == 8) unusedBits = 0;
                                for (var i = 0; i <= unusedBits; i++) {
                                    binaryString += '0';
                                }
                                var h = '';
                                for (var i = 0; i < binaryString.length - 1; i += 8) {
                                    var b = binaryString.substr(i, 8);
                                    var x = parseInt(b, 2).toString(16);
                                    if (x.length == 1) x = '0' + x;
                                    h += x;
                                }
                                this.hTLV = null;
                                this.isModified = true;
                                this.hV = '0' + unusedBits + h;
                            };
                            /**
                             * set ASN.1 TLV value(V) by an array of boolean<br/>
                             * @name setByBooleanArray
                             * @memberOf KJUR.asn1.DERBitString#
                             * @function
                             * @param {array} booleanArray array of boolean (ex. [true, false, true])
                             * @description
                             * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
                             * @example
                             * o = new KJUR.asn1.DERBitString();
                             * o.setByBooleanArray([false, true, false, true, true]);
                             */
                            this.setByBooleanArray = function (booleanArray) {
                                var s = '';
                                for (var i = 0; i < booleanArray.length; i++) {
                                    if (booleanArray[i] == true) {
                                        s += '1';
                                    } else {
                                        s += '0';
                                    }
                                }
                                this.setByBinaryString(s);
                            };
                            /**
                             * generate an array of falses with specified length<br/>
                             * @name newFalseArray
                             * @memberOf KJUR.asn1.DERBitString
                             * @function
                             * @param {Integer} nLength length of array to generate
                             * @return {array} array of boolean falses
                             * @description
                             * This static method may be useful to initialize boolean array.
                             * @example
                             * o = new KJUR.asn1.DERBitString();
                             * o.newFalseArray(3) &rarr; [false, false, false]
                             */
                            this.newFalseArray = function (nLength) {
                                var a = new Array(nLength);
                                for (var i = 0; i < nLength; i++) {
                                    a[i] = false;
                                }
                                return a;
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
                                    this.setHexValueIncludingUnusedBits(params);
                                } else if (typeof params['hex'] != "undefined") {
                                    this.setHexValueIncludingUnusedBits(params['hex']);
                                } else if (typeof params['bin'] != "undefined") {
                                    this.setByBinaryString(params['bin']);
                                } else if (typeof params['array'] != "undefined") {
                                    this.setByBooleanArray(params['array']);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERBitString, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER OctetString<br/>
                         * @name KJUR.asn1.DEROctetString
                         * @class class for ASN.1 DER OctetString
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * This class provides ASN.1 OctetString simple type.<br/>
                         * Supported "params" attributes are:
                         * <ul>
                         * <li>str - to set a string as a value</li>
                         * <li>hex - to set a hexadecimal string as a value</li>
                         * <li>obj - to set a encapsulated ASN.1 value by JSON object
                         * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
                         * </ul>
                         * NOTE: A parameter 'obj' have been supported
                         * for "OCTET STRING, encapsulates" structure.
                         * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
                         * @see KJUR.asn1.DERAbstractString - superclass
                         * @example
                         * // default constructor
                         * o = new KJUR.asn1.DEROctetString();
                         * // initialize with string
                         * o = new KJUR.asn1.DEROctetString({str: "aaa"});
                         * // initialize with hexadecimal string
                         * o = new KJUR.asn1.DEROctetString({hex: "616161"});
                         * // initialize with ASN1Util.newObject argument
                         * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
                         * // above generates a ASN.1 data like this:
                         * // OCTET STRING, encapsulates {
                         * //   SEQUENCE {
                         * //     INTEGER 3
                         * //     PrintableString 'aaa'
                         * //     }
                         * //   }
                         */
                        _KJUR2.asn1.DEROctetString = function (params) {
                            if (params !== undefined && typeof params.obj !== "undefined") {
                                var o = _KJUR2.asn1.ASN1Util.newObject(params.obj);
                                params.hex = o.getEncodedHex();
                            }
                            _KJUR2.asn1.DEROctetString.superclass.constructor.call(this, params);
                            this.hT = "04";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DEROctetString, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Null
                         * @name KJUR.asn1.DERNull
                         * @class class for ASN.1 DER Null
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * @see KJUR.asn1.ASN1Object - superclass
                         */
                        _KJUR2.asn1.DERNull = function () {
                            _KJUR2.asn1.DERNull.superclass.constructor.call(this);
                            this.hT = "05";
                            this.hTLV = "0500";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERNull, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER ObjectIdentifier
                         * @name KJUR.asn1.DERObjectIdentifier
                         * @class class for ASN.1 DER ObjectIdentifier
                         * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         */
                        _KJUR2.asn1.DERObjectIdentifier = function (params) {
                            var itox = function itox(i) {
                                var h = i.toString(16);
                                if (h.length == 1) h = '0' + h;
                                return h;
                            };
                            var roidtox = function roidtox(roid) {
                                var h = '';
                                var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(roid, 10);
                                var b = bi.toString(2);
                                var padLen = 7 - b.length % 7;
                                if (padLen == 7) padLen = 0;
                                var bPad = '';
                                for (var i = 0; i < padLen; i++) {
                                    bPad += '0';
                                }b = bPad + b;
                                for (var i = 0; i < b.length - 1; i += 7) {
                                    var b8 = b.substr(i, 7);
                                    if (i != b.length - 7) b8 = '1' + b8;
                                    h += itox(parseInt(b8, 2));
                                }
                                return h;
                            };
                            _KJUR2.asn1.DERObjectIdentifier.superclass.constructor.call(this);
                            this.hT = "06";
                            /**
                             * set value by a hexadecimal string
                             * @name setValueHex
                             * @memberOf KJUR.asn1.DERObjectIdentifier#
                             * @function
                             * @param {String} newHexString hexadecimal value of OID bytes
                             */
                            this.setValueHex = function (newHexString) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.s = null;
                                this.hV = newHexString;
                            };
                            /**
                             * set value by a OID string<br/>
                             * @name setValueOidString
                             * @memberOf KJUR.asn1.DERObjectIdentifier#
                             * @function
                             * @param {String} oidString OID string (ex. 2.5.4.13)
                             * @example
                             * o = new KJUR.asn1.DERObjectIdentifier();
                             * o.setValueOidString("2.5.4.13");
                             */
                            this.setValueOidString = function (oidString) {
                                if (!oidString.match(/^[0-9.]+$/)) {
                                    throw "malformed oid string: " + oidString;
                                }
                                var h = '';
                                var a = oidString.split('.');
                                var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
                                h += itox(i0);
                                a.splice(0, 2);
                                for (var i = 0; i < a.length; i++) {
                                    h += roidtox(a[i]);
                                }
                                this.hTLV = null;
                                this.isModified = true;
                                this.s = null;
                                this.hV = h;
                            };
                            /**
                             * set value by a OID name
                             * @name setValueName
                             * @memberOf KJUR.asn1.DERObjectIdentifier#
                             * @function
                             * @param {String} oidName OID name (ex. 'serverAuth')
                             * @since 1.0.1
                             * @description
                             * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
                             * Otherwise raise error.
                             * @example
                             * o = new KJUR.asn1.DERObjectIdentifier();
                             * o.setValueName("serverAuth");
                             */
                            this.setValueName = function (oidName) {
                                var oid = _KJUR2.asn1.x509.OID.name2oid(oidName);
                                if (oid !== '') {
                                    this.setValueOidString(oid);
                                } else {
                                    throw "DERObjectIdentifier oidName undefined: " + oidName;
                                }
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (params !== undefined) {
                                if (typeof params === "string") {
                                    if (params.match(/^[0-2].[0-9.]+$/)) {
                                        this.setValueOidString(params);
                                    } else {
                                        this.setValueName(params);
                                    }
                                } else if (params.oid !== undefined) {
                                    this.setValueOidString(params.oid);
                                } else if (params.hex !== undefined) {
                                    this.setValueHex(params.hex);
                                } else if (params.name !== undefined) {
                                    this.setValueName(params.name);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERObjectIdentifier, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Enumerated
                         * @name KJUR.asn1.DEREnumerated
                         * @class class for ASN.1 DER Enumerated
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>int - specify initial ASN.1 value(V) by integer value</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         * @example
                         * new KJUR.asn1.DEREnumerated(123);
                         * new KJUR.asn1.DEREnumerated({int: 123});
                         * new KJUR.asn1.DEREnumerated({hex: '1fad'});
                         */
                        _KJUR2.asn1.DEREnumerated = function (params) {
                            _KJUR2.asn1.DEREnumerated.superclass.constructor.call(this);
                            this.hT = "0a";
                            /**
                             * set value by Tom Wu's BigInteger object
                             * @name setByBigInteger
                             * @memberOf KJUR.asn1.DEREnumerated#
                             * @function
                             * @param {BigInteger} bigIntegerValue to set
                             */
                            this.setByBigInteger = function (bigIntegerValue) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.hV = _KJUR2.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
                            };
                            /**
                             * set value by integer value
                             * @name setByInteger
                             * @memberOf KJUR.asn1.DEREnumerated#
                             * @function
                             * @param {Integer} integer value to set
                             */
                            this.setByInteger = function (intValue) {
                                var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(String(intValue), 10);
                                this.setByBigInteger(bi);
                            };
                            /**
                             * set value by integer value
                             * @name setValueHex
                             * @memberOf KJUR.asn1.DEREnumerated#
                             * @function
                             * @param {String} hexadecimal string of integer value
                             * @description
                             * <br/>
                             * NOTE: Value shall be represented by minimum octet length of
                             * two's complement representation.
                             */
                            this.setValueHex = function (newHexString) {
                                this.hV = newHexString;
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params['int'] != "undefined") {
                                    this.setByInteger(params['int']);
                                } else if (typeof params == "number") {
                                    this.setByInteger(params);
                                } else if (typeof params['hex'] != "undefined") {
                                    this.setValueHex(params['hex']);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DEREnumerated, _KJUR2.asn1.ASN1Object);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER UTF8String
                         * @name KJUR.asn1.DERUTF8String
                         * @class class for ASN.1 DER UTF8String
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * @see KJUR.asn1.DERAbstractString - superclass
                         */
                        _KJUR2.asn1.DERUTF8String = function (params) {
                            _KJUR2.asn1.DERUTF8String.superclass.constructor.call(this, params);
                            this.hT = "0c";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERUTF8String, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER NumericString
                         * @name KJUR.asn1.DERNumericString
                         * @class class for ASN.1 DER NumericString
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * @see KJUR.asn1.DERAbstractString - superclass
                         */
                        _KJUR2.asn1.DERNumericString = function (params) {
                            _KJUR2.asn1.DERNumericString.superclass.constructor.call(this, params);
                            this.hT = "12";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERNumericString, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER PrintableString
                         * @name KJUR.asn1.DERPrintableString
                         * @class class for ASN.1 DER PrintableString
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * @see KJUR.asn1.DERAbstractString - superclass
                         */
                        _KJUR2.asn1.DERPrintableString = function (params) {
                            _KJUR2.asn1.DERPrintableString.superclass.constructor.call(this, params);
                            this.hT = "13";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERPrintableString, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER TeletexString
                         * @name KJUR.asn1.DERTeletexString
                         * @class class for ASN.1 DER TeletexString
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * @see KJUR.asn1.DERAbstractString - superclass
                         */
                        _KJUR2.asn1.DERTeletexString = function (params) {
                            _KJUR2.asn1.DERTeletexString.superclass.constructor.call(this, params);
                            this.hT = "14";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERTeletexString, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER IA5String
                         * @name KJUR.asn1.DERIA5String
                         * @class class for ASN.1 DER IA5String
                         * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
                         * @extends KJUR.asn1.DERAbstractString
                         * @description
                         * @see KJUR.asn1.DERAbstractString - superclass
                         */
                        _KJUR2.asn1.DERIA5String = function (params) {
                            _KJUR2.asn1.DERIA5String.superclass.constructor.call(this, params);
                            this.hT = "16";
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERIA5String, _KJUR2.asn1.DERAbstractString);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER UTCTime
                         * @name KJUR.asn1.DERUTCTime
                         * @class class for ASN.1 DER UTCTime
                         * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
                         * @extends KJUR.asn1.DERAbstractTime
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * <li>date - specify Date object.</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         * <h4>EXAMPLES</h4>
                         * @example
                         * d1 = new KJUR.asn1.DERUTCTime();
                         * d1.setString('130430125959Z');
                         *
                         * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
                         * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
                         * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
                         */
                        _KJUR2.asn1.DERUTCTime = function (params) {
                            _KJUR2.asn1.DERUTCTime.superclass.constructor.call(this, params);
                            this.hT = "17";
                            /**
                             * set value by a Date object<br/>
                             * @name setByDate
                             * @memberOf KJUR.asn1.DERUTCTime#
                             * @function
                             * @param {Date} dateObject Date object to set ASN.1 value(V)
                             * @example
                             * o = new KJUR.asn1.DERUTCTime();
                             * o.setByDate(new Date("2016/12/31"));
                             */
                            this.setByDate = function (dateObject) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.date = dateObject;
                                this.s = this.formatDate(this.date, 'utc');
                                this.hV = stohex(this.s);
                            };
                            this.getFreshValueHex = function () {
                                if (typeof this.date == "undefined" && typeof this.s == "undefined") {
                                    this.date = new Date();
                                    this.s = this.formatDate(this.date, 'utc');
                                    this.hV = stohex(this.s);
                                }
                                return this.hV;
                            };
                            if (params !== undefined) {
                                if (params.str !== undefined) {
                                    this.setString(params.str);
                                } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
                                    this.setString(params);
                                } else if (params.hex !== undefined) {
                                    this.setStringHex(params.hex);
                                } else if (params.date !== undefined) {
                                    this.setByDate(params.date);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERUTCTime, _KJUR2.asn1.DERAbstractTime);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER GeneralizedTime
                         * @name KJUR.asn1.DERGeneralizedTime
                         * @class class for ASN.1 DER GeneralizedTime
                         * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
                         * @property {Boolean} withMillis flag to show milliseconds or not
                         * @extends KJUR.asn1.DERAbstractTime
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
                         * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
                         * <li>date - specify Date object.</li>
                         * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
                         * </ul>
                         * NOTE1: 'params' can be omitted.
                         * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
                         */
                        _KJUR2.asn1.DERGeneralizedTime = function (params) {
                            _KJUR2.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
                            this.hT = "18";
                            this.withMillis = false;
                            /**
                             * set value by a Date object
                             * @name setByDate
                             * @memberOf KJUR.asn1.DERGeneralizedTime#
                             * @function
                             * @param {Date} dateObject Date object to set ASN.1 value(V)
                             * @example
                             * When you specify UTC time, use 'Date.UTC' method like this:<br/>
                             * o1 = new DERUTCTime();
                             * o1.setByDate(date);
                             *
                             * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
                             */
                            this.setByDate = function (dateObject) {
                                this.hTLV = null;
                                this.isModified = true;
                                this.date = dateObject;
                                this.s = this.formatDate(this.date, 'gen', this.withMillis);
                                this.hV = stohex(this.s);
                            };
                            this.getFreshValueHex = function () {
                                if (this.date === undefined && this.s === undefined) {
                                    this.date = new Date();
                                    this.s = this.formatDate(this.date, 'gen', this.withMillis);
                                    this.hV = stohex(this.s);
                                }
                                return this.hV;
                            };
                            if (params !== undefined) {
                                if (params.str !== undefined) {
                                    this.setString(params.str);
                                } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
                                    this.setString(params);
                                } else if (params.hex !== undefined) {
                                    this.setStringHex(params.hex);
                                } else if (params.date !== undefined) {
                                    this.setByDate(params.date);
                                }
                                if (params.millis === true) {
                                    this.withMillis = true;
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERGeneralizedTime, _KJUR2.asn1.DERAbstractTime);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Sequence
                         * @name KJUR.asn1.DERSequence
                         * @class class for ASN.1 DER Sequence
                         * @extends KJUR.asn1.DERAbstractStructured
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>array - specify array of ASN1Object to set elements of content</li>
                         * </ul>
                         * NOTE: 'params' can be omitted.
                         */
                        _KJUR2.asn1.DERSequence = function (params) {
                            _KJUR2.asn1.DERSequence.superclass.constructor.call(this, params);
                            this.hT = "30";
                            this.getFreshValueHex = function () {
                                var h = '';
                                for (var i = 0; i < this.asn1Array.length; i++) {
                                    var asn1Obj = this.asn1Array[i];
                                    h += asn1Obj.getEncodedHex();
                                }
                                this.hV = h;
                                return this.hV;
                            };
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERSequence, _KJUR2.asn1.DERAbstractStructured);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER Set
                         * @name KJUR.asn1.DERSet
                         * @class class for ASN.1 DER Set
                         * @extends KJUR.asn1.DERAbstractStructured
                         * @description
                         * <br/>
                         * As for argument 'params' for constructor, you can specify one of
                         * following properties:
                         * <ul>
                         * <li>array - specify array of ASN1Object to set elements of content</li>
                         * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
                         * </ul>
                         * NOTE1: 'params' can be omitted.<br/>
                         * NOTE2: sortflag is supported since 1.0.5.
                         */
                        _KJUR2.asn1.DERSet = function (params) {
                            _KJUR2.asn1.DERSet.superclass.constructor.call(this, params);
                            this.hT = "31";
                            this.sortFlag = true; // item shall be sorted only in ASN.1 DER
                            this.getFreshValueHex = function () {
                                var a = new Array();
                                for (var i = 0; i < this.asn1Array.length; i++) {
                                    var asn1Obj = this.asn1Array[i];
                                    a.push(asn1Obj.getEncodedHex());
                                }
                                if (this.sortFlag == true) a.sort();
                                this.hV = a.join('');
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params.sortflag != "undefined" && params.sortflag == false) this.sortFlag = false;
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERSet, _KJUR2.asn1.DERAbstractStructured);
                        // ********************************************************************
                        /**
                         * class for ASN.1 DER TaggedObject
                         * @name KJUR.asn1.DERTaggedObject
                         * @class class for ASN.1 DER TaggedObject
                         * @extends KJUR.asn1.ASN1Object
                         * @description
                         * <br/>
                         * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
                         * For example, if you find '[1]' tag in a ASN.1 dump,
                         * 'tagNoHex' will be 'a1'.
                         * <br/>
                         * As for optional argument 'params' for constructor, you can specify *ANY* of
                         * following properties:
                         * <ul>
                         * <li>explicit - specify true if this is explicit tag otherwise false
                         *     (default is 'true').</li>
                         * <li>tag - specify tag (default is 'a0' which means [0])</li>
                         * <li>obj - specify ASN1Object which is tagged</li>
                         * </ul>
                         * @example
                         * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
                         * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
                         * hex = d2.getEncodedHex();
                         */
                        _KJUR2.asn1.DERTaggedObject = function (params) {
                            _KJUR2.asn1.DERTaggedObject.superclass.constructor.call(this);
                            this.hT = "a0";
                            this.hV = '';
                            this.isExplicit = true;
                            this.asn1Object = null;
                            /**
                             * set value by an ASN1Object
                             * @name setString
                             * @memberOf KJUR.asn1.DERTaggedObject#
                             * @function
                             * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
                             * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
                             * @param {ASN1Object} asn1Object ASN.1 to encapsulate
                             */
                            this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {
                                this.hT = tagNoHex;
                                this.isExplicit = isExplicitFlag;
                                this.asn1Object = asn1Object;
                                if (this.isExplicit) {
                                    this.hV = this.asn1Object.getEncodedHex();
                                    this.hTLV = null;
                                    this.isModified = true;
                                } else {
                                    this.hV = null;
                                    this.hTLV = asn1Object.getEncodedHex();
                                    this.hTLV = this.hTLV.replace(/^../, tagNoHex);
                                    this.isModified = false;
                                }
                            };
                            this.getFreshValueHex = function () {
                                return this.hV;
                            };
                            if (typeof params != "undefined") {
                                if (typeof params['tag'] != "undefined") {
                                    this.hT = params['tag'];
                                }
                                if (typeof params['explicit'] != "undefined") {
                                    this.isExplicit = params['explicit'];
                                }
                                if (typeof params['obj'] != "undefined") {
                                    this.asn1Object = params['obj'];
                                    this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
                                }
                            }
                        };
                        _yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(_KJUR2.asn1.DERTaggedObject, _KJUR2.asn1.ASN1Object);

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/lib/jsrsasign/yahoo.js":
                    /*!***********************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/lib/jsrsasign/yahoo.js ***!
                      \***********************************************************/
                    /***/function node_modulesJsencryptLibLibJsrsasignYahooJs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                        "use strict";

                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export */__webpack_require__.d(__webpack_exports__, {
                            /* harmony export */"YAHOO": function YAHOO() {
                                return (/* binding */_YAHOO
                                );
                            }
                            /* harmony export */ });
                        /*!
                        Copyright (c) 2011, Yahoo! Inc. All rights reserved.
                        Code licensed under the BSD License:
                        http://developer.yahoo.com/yui/license.html
                        version: 2.9.0
                        */
                        var _YAHOO = {};
                        _YAHOO.lang = {
                            /**
                             * Utility to set up the prototype, constructor and superclass properties to
                             * support an inheritance strategy that can chain constructors and methods.
                             * Static members will not be inherited.
                             *
                             * @method extend
                             * @static
                             * @param {Function} subc   the object to modify
                             * @param {Function} superc the object to inherit
                             * @param {Object} overrides  additional properties/methods to add to the
                             *                              subclass prototype.  These will override the
                             *                              matching items obtained from the superclass
                             *                              if present.
                             */
                            extend: function extend(subc, superc, overrides) {
                                if (!superc || !subc) {
                                    throw new Error("YAHOO.lang.extend failed, please check that " + "all dependencies are included.");
                                }
                                var F = function F() {};
                                F.prototype = superc.prototype;
                                subc.prototype = new F();
                                subc.prototype.constructor = subc;
                                subc.superclass = superc.prototype;
                                if (superc.prototype.constructor == Object.prototype.constructor) {
                                    superc.prototype.constructor = superc;
                                }
                                if (overrides) {
                                    var i;
                                    for (i in overrides) {
                                        subc.prototype[i] = overrides[i];
                                    }
                                    /*
                                     * IE will not enumerate native functions in a derived object even if the
                                     * function was overridden.  This is a workaround for specific functions
                                     * we care about on the Object prototype.
                                     * @property _IEEnumFix
                                     * @param {Function} r  the object to receive the augmentation
                                     * @param {Function} s  the object that supplies the properties to augment
                                     * @static
                                     * @private
                                     */
                                    var _IEEnumFix = function _IEEnumFix() {},
                                        ADD = ["toString", "valueOf"];
                                    try {
                                        if (/MSIE/.test(navigator.userAgent)) {
                                            _IEEnumFix = function _IEEnumFix(r, s) {
                                                for (i = 0; i < ADD.length; i = i + 1) {
                                                    var fname = ADD[i],
                                                        f = s[fname];
                                                    if (typeof f === 'function' && f != Object.prototype[fname]) {
                                                        r[fname] = f;
                                                    }
                                                }
                                            };
                                        }
                                    } catch (ex) {}
                                    
                                    _IEEnumFix(subc.prototype, overrides);
                                }
                            }
                        };

                        /***/
                    },

                    /***/"./node_modules/jsencrypt/lib/version.json":
                    /*!*************************************************!*\
                      !*** ./node_modules/jsencrypt/lib/version.json ***!
                      \*************************************************/
                    /***/function node_modulesJsencryptLibVersionJson(module) {

                        "use strict";

                        module.exports = { "version": "3.2.0" };

                        /***/
                    }

                    /******/ };
                /************************************************************************/
                /******/ // The module cache
                /******/var __webpack_module_cache__ = {};
                /******/
                /******/ // The require function
                /******/function __webpack_require__(moduleId) {
                    /******/ // Check if module is in cache
                    /******/var cachedModule = __webpack_module_cache__[moduleId];
                    /******/if (cachedModule !== undefined) {
                        /******/return cachedModule.exports;
                        /******/
                    }
                    /******/ // Create a new module (and put it into the cache)
                    /******/var module = __webpack_module_cache__[moduleId] = {
                        /******/ // no module.id needed
                        /******/ // no module.loaded needed
                        /******/exports: {}
                        /******/ };
                    /******/
                    /******/ // Execute the module function
                    /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
                    /******/
                    /******/ // Return the exports of the module
                    /******/return module.exports;
                    /******/
                }
                /******/
                /************************************************************************/
                /******/ /* webpack/runtime/define property getters */
                /******/(function () {
                    /******/ // define getter functions for harmony exports
                    /******/__webpack_require__.d = function (exports, definition) {
                        /******/for (var key in definition) {
                            /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                                /******/Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                                /******/
                            }
                            /******/
                        }
                        /******/
                    };
                    /******/
                })();
                /******/
                /******/ /* webpack/runtime/hasOwnProperty shorthand */
                /******/(function () {
                    /******/__webpack_require__.o = function (obj, prop) {
                        return Object.prototype.hasOwnProperty.call(obj, prop);
                    };
                    /******/
                })();
                /******/
                /******/ /* webpack/runtime/make namespace object */
                /******/(function () {
                    /******/ // define __esModule on exports
                    /******/__webpack_require__.r = function (exports) {
                        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                            /******/Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                            /******/
                        }
                        /******/Object.defineProperty(exports, '__esModule', { value: true });
                        /******/
                    };
                    /******/
                })();
                /******/
                /************************************************************************/
                var __webpack_exports__ = {};
                // This entry need to be wrapped in an IIFE because it need to be in strict mode.
                (function () {
                    "use strict";

                    var exports = __webpack_exports__;
                    /*!***********************!*\
                      !*** ./enc.source.js ***!
                      \***********************/

                    var armor = __webpack_require__( /*! !./node_modules/@tencent/js-armor-loader/dist/runtime.js */"./node_modules/@tencent/js-armor-loader/dist/runtime.js");
                    Object.defineProperty(exports, "__esModule", { value: true });
                    exports['default'] = void 0;
                    var _jsencrypt = _interopRequireDefault(__webpack_require__( /*! jsencrypt */"./node_modules/jsencrypt/lib/index.js"));
                    var _genOverlayProperty = _interopRequireDefault(__webpack_require__( /*! ./gen-overlay-property */"./gen-overlay-property.js"));
                    var _aes = _interopRequireDefault(__webpack_require__( /*! ./aes */"./aes.js"));
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { 'default': obj };
                    }
                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError('Cannot call a class as a function');
                        }
                    }
                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    function _createClass(Constructor, protoProps, staticProps) {
                        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }
                    var Enc = function () {
                        function Enc() {
                            _classCallCheck(this, Enc);
                            this.overlayKey = (0, _genOverlayProperty['default'])();
                            this.overlayIv = (0, _genOverlayProperty['default'])();
                        }
                        _createClass(Enc, [{
                            key: 'base64ToHex',
                            value: function base64ToHex(str) {
                                var raw = atob(str);
                                var result = '';
                                for (var i = 0; i < raw.length; i++) {
                                    var hex = raw.charCodeAt(i).toString(16);
                                    result += hex.length === 2 ? hex : '0' + hex;
                                }
                                return result;
                            }
                        }, {
                            key: 'checkEnvironment',
                            value: function checkEnvironment() {
                                if (!Hls || !Hls.isSupported()) {
                                    console.error('\u672A\u68C0\u6D4B\u5230 Hls \u5168\u5C40\u53D8\u91CF\u6216\u5F53\u524D\u73AF\u5883\u4E0D\u652F\u6301 hls.js\uFF0C\u8BF7\u9009\u62E9\u5176\u4ED6\u64AD\u653E\u65B9\u5F0F');
                                    return false;
                                }
                                return true;
                            }
                        }, {
                            key: 'generatePlayCgiUrl',
                            value: function generatePlayCgiUrl(url) {
                                return armor.g(armor.v(0, armor.d(["JAQGAgYDQyEkBwYCBgMGBAYFBgYhAzoAPxoAZABlAGYAYQB1AGwAdAUKAA04OCEEGgBNAEkARwBmAE0AQQAwAEcAQwBTAHEARwBTAEkAYgAzAEQAUQBFAEIAQQBRAFUAQQBBADQARwBOAEEARABDAEIAaQBRAEsAQgBnAFEAQwAzAHAARABBADcARwBUAHgATwB2AE4AYgBYAFIARwBNAGkAOQBRAFMASQB6AFEARQBJACsARQBNAEQAMQBIAGMAVQBQAEoAUwBRAFMARgB1AFIAawBaAGsAVwBvADQAVgBRAEUAQwB1AFAAUgBnAC8AeABWAGoAcQB3AFgAMQB5AFUAcgBIAFUAdgBHAFEASgBzAEIAdwBUAFMALwA2AEwASQBjAFEAaQBTAHcAWQBzAE8AcQBmACsAOABUAFcAeABHAFEATwBKAHkAVwA0ADYAZwBQAFAAUQBWAHoAVABqAE4AVABpAFUAbwBxADQAMwA1AFEAQgAwAHYAMQAxAGwATgB4AHYASwBXAEIAUQBJAFoATABtAGEAYwBVAFoAMgByADEAQQBQAHQAYQA3AGkALwBNAFkANABMAHgAOQBYAGwAWgBWAE0AWgBOAFUAZABVAHkAdwBJAEQAQQBRAEEAQg04OCEDGgBzAGUAdABQAHUAYgBsAGkAYwBLAGUAeSUOBDwBOCEFIQAaAGIAYQBzAGUANgA0AFQAbwBIAGUAeCUhAxoAZQBuAGMAcgB5AHAAdCUhABoAbwB2AGUAcgBsAGEAeQBLAGUAeSUdPAE8AQ04OCEGIQAaAGIAYQBzAGUANgA0AFQAbwBIAGUAeCUhAxoAZQBuAGMAcgB5AHAAdCUhABoAbwB2AGUAcgBsAGEAeQBJAHYlHTwBPAENOBsBPxoATQBlAGQAaQBhAFMAbwB1AHIAYwBlBRoAcAByAG8AdABvAHQAeQBwAGUFGgBlAG4AZABPAGYAUwB0AHIAZQBhAG0FGgB0AG8AUwB0AHIAaQBuAGcFPAAaAHIAZQBwAGwAYQBjAGUIOgIiGgBcAHMaAGcoAho8AhoAZgB1AG4AYwB0AGkAbwBuAGUAbgBkAE8AZgBTAHQAcgBlAGEAbQAoACkAewBbAG4AYQB0AGkAdgBlAGMAbwBkAGUAXQB9NkEDGwE/GgBNAGUAZABpAGEAUwBvAHUAcgBjAGUFGgBwAHIAbwB0AG8AdAB5AHAAZQUaAGEAZABkAFMAbwB1AHIAYwBlAEIAdQBmAGYAZQByBRoAdABvAFMAdAByAGkAbgBnBTwAGgByAGUAcABsAGEAYwBlCDoCIhoAXABzGgBnKAIaPAIaAGYAdQBuAGMAdABpAG8AbgBhAGQAZABTAG8AdQByAGMAZQBCAHUAZgBmAGUAcgAoACkAewBbAG4AYQB0AGkAdgBlAGMAbwBkAGUAXQB9NkEDOEM6OCEFIQAaAGIAYQBzAGUANgA0AFQAbwBIAGUAeCUhAxoAZQBuAGMAcgB5AHAAdCU6ABsDPxoAZABlAGYAYQB1AGwAdAUdKAA8ATwBDTg4IQYhABoAYgBhAHMAZQA2ADQAVABvAEgAZQB4JSEDGgBlAG4AYwByAHkAcAB0JToAGwM/GgBkAGUAZgBhAHUAbAB0BR0oADwBPAENODg6BD8eHRoAJgBjAGkAcABoAGUAcgBlAGQATwB2AGUAcgBsAGEAeQBLAGUAeQA9GgBjAG8AbgBjAGEAdAgOBRoAJgBjAGkAcABoAGUAcgBlAGQATwB2AGUAcgBsAGEAeQBJAHYAPTwCGgBjAG8AbgBjAGEAdAgOBhoAJgBrAGUAeQBJAGQAPQAxPAIsBCoAOBsEIjUhAzIJAAANODgcNQ==", [7, 1389, 868, 1081, 1082, 1087, 1085, 1242]]), [function () {
                                    return typeof _jsencrypt == 'undefined' ? undefined : _jsencrypt;
                                }, function () {
                                    return typeof window == 'undefined' ? undefined : window;
                                }, function () {
                                    return typeof RegExp == 'undefined' ? undefined : RegExp;
                                }, function () {
                                    return typeof _genOverlayProperty == 'undefined' ? undefined : _genOverlayProperty;
                                }, function () {
                                    return typeof url == 'undefined' ? undefined : url;
                                }])).call(this);
                            }
                        }, {
                            key: 'generateKey',
                            value: function generateKey(key) {
                                var responseKey = new Uint8Array(key);
                                var decryptedKey;
                                if (this.overlayKey && this.overlayIv) {
                                    var keyArray = [];
                                    var ivArray = [];
                                    for (var i = 0; i < 16; i++) {
                                        var _key = this.overlayKey.substring(i * 2, i * 2 + 2);
                                        var _iv = this.overlayIv.substring(i * 2, i * 2 + 2);
                                        keyArray.push(parseInt(_key, 16));
                                        ivArray.push(parseInt(_iv, 16));
                                    }
                                    var aesCbc = new _aes['default'].modeOfOperation.cbc(keyArray, ivArray);
                                    decryptedKey = aesCbc.decrypt(responseKey);
                                }
                                return decryptedKey || responseKey;
                            }
                        }]);
                        return Enc;
                    }();
                    var _default = Enc;
                    exports['default'] = _default;
                })();

                __webpack_exports__ = __webpack_exports__['default'];
                /******/return __webpack_exports__;
                /******/
            }()
        );
    });
});

var Enc = unwrapExports(enc);

var strictUriEncode = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty$1.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				} else if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

function extract(str) {
	var queryStart = str.indexOf('?');
	if (queryStart === -1) {
		return '';
	}
	return str.slice(queryStart + 1);
}

function parse(str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^[?#&]/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeUriComponent(val);

		formatter(decodeUriComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
}

var extract_1 = extract;
var parse_1 = parse;

var stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	if (opts.sort === false) {
		opts.sort = function () {};
	}

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort(opts.sort).map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

var parseUrl$1 = function (str, opts) {
	return {
		url: str.split('?')[0] || '',
		query: parse(extract(str), opts)
	};
};

var queryString = {
	extract: extract_1,
	parse: parse_1,
	stringify: stringify,
	parseUrl: parseUrl$1
};

var count = 0;

/**
 * Noop function.
 */

function jsonp(url, opts, fn) {
  if ('function' == typeof opts) {
    fn = opts;
    opts = {};
  }
  if (!opts) opts = {};

  var prefix = opts.prefix || '__jp';

  // use the callback name that was passed if one was provided.
  // otherwise generate a unique name by incrementing our counter.
  var id = opts.name || prefix + count++;
  var funcKey = opts.funcKey || 'callback';
  var param;
  if (_typeof(opts.param) == 'object') {
    param = queryString.stringify(opts.param);
  } else {
    param = opts.param;
  }
  var timeout = null != opts.timeout ? opts.timeout : 6000;
  var enc = encodeURIComponent;
  var target = document.getElementsByTagName('script')[0] || document.head;
  var script;
  var timer;

  if (timeout) {
    timer = setTimeout(function () {
      cleanup();
      if (fn) fn(new Error('Timeout'));
    }, timeout);
  }

  function cleanup() {
    if (script.parentNode) script.parentNode.removeChild(script);
    window[id] = '';
    // window[id] = noop;
    // delete window[id];
    if (timer) clearTimeout(timer);
  }

  function cancel() {
    if (window[id]) {
      cleanup();
    }
  }

  window[id] = function (data) {
    cleanup();
    if (fn) fn(null, data);
  };

  // add qs component
  url += (~url.indexOf('?') ? '&' : '?') + param + '&' + funcKey + '=' + enc(id);
  url = url.replace('?&', '?');

  // create script
  script = document.createElement('script');
  // script.src = url;
  script.setAttribute('src', url);
  script.setAttribute('async', true);
  script.onload = function (e) {
    // onload事件会在响应内容执行完毕后触发
    // console.log('jsonp onload', e);
  };
  script.onreadystatechange = function () {
    // console.log('jsonp onreadystatechange', this.readyState, window[id]);
    if (this.readyState === 'loaded' && window[id]) {
      cleanup();
      if (fn) fn(new Error('ServerError'));
    }
    // IE8 没有onload error事件 只有onreadystatechange，readyState 为loading或loaded。loaded 时回调已执行
  };
  script.onerror = function (e) {
    // console.log('jsonp onerror', e);
    cleanup();
    if (fn) fn(new Error('ServerError'));
  };
  target.parentNode.insertBefore(script, target);
  return cancel;
}

function genOverlay() {
  var key = '';
  var array = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
  for (i = 0; i < 32; i++) {
    var randomInt = getRandomInt(0, 15);
    key += array[randomInt];
  }
  return key;
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

/**
 * @file async-loader.js
 */
/**
 * TODO 可以检测当前播放环境，分析传入的视频格式，
 * TODO 可以异步加载需要的播放组件例如 hls.js、flv.js 等，
 *
 * MediaAsyncLoader 用于替代loader.js的逻辑，只用于腾讯云点播业务
 *
 * @link MultiResolution
 * @extends Component
 */

var MediaAsyncLoader = function (_Component) {
  inherits(MediaAsyncLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaAsyncLoader(player, options, ready) {
    classCallCheck(this, MediaAsyncLoader);

    log$2('MediaAsyncLoader initializing');
    // 生成overlayKey & overlayIv
    if (options.playerOptions && options.playerOptions.psign && IS_ENABLED_MSE && !videojs.browser.IS_TBS && !videojs.browser.IS_MQQB && !videojs.browser.IS_SAFARI && !(videojs.browser.IE_VERSION && videojs.browser.IE_VERSION < 11)) {
      options.playerOptions.overlayKey = genOverlay();
      options.playerOptions.overlayIv = genOverlay();
      options.playerOptions.dKeyDebug = options.dKeyDebug || false;
    }
    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    var playerOptions = options_.playerOptions || options_;
    // log('MediaAsyncLoader', options_, playerOptions);
    _this.getInfo(playerOptions);

    // 在 player实例中挂载方法，用于切换 fileid 播放
    player['loadVideoByID'] = bind(_this, _this.loadVideoByID);
    log$2('MediaAsyncLoader initialized');
    return _this;
  }

  MediaAsyncLoader.prototype.getInfo = function getInfo(playerOptions) {
    if (playerOptions && playerOptions['fileID'] && playerOptions['appID']) {
      performance && performance.mark('firstFrameStart');
      if (playerOptions['playDefinition']) {
        this.getInfoV3(playerOptions);
      } else if (playerOptions['sign'] || playerOptions['ssign']) {
        // 传入 sign 或者 ssign 通过 v2版本进行播放
        this.getInfoV2(playerOptions);
      } else {
        // v4版本支持 psign rlimit 参数
        this.getInfoV4(playerOptions);
      }
    }
  };

  /**
   * 无防盗链
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}?callback=jquery_callback&refer=somehost.com
   * 普通防盗链
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}?callback=jquery_callback&refer=somehost.com&playerid=233&t=5949fdc9&us=test_user&sign=xxx
   * 带试看的防盗链
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}?callback=jquery_callback&refer=somehost.com&playerid=233&t=5949fdc9&exper=300&us=test_user&sign=xxx
   * version:v2
   * interface:getplayinfo
   * t: 加密链接超时时间戳，转换为16进制小写字符串，腾讯云 CDN 服务器会根据该时间判断该链接是否有效  防盗链有效期，建议不要比视频时长短
   * us: 唯一标识请求，增加链接唯一性  建议尽量随机化
   * exper: 试看时长，单位：秒，十进制数值。试看防盗链须带的参数，0表示不试看，即返回完整视频。mp4、ts 的试看时长不能大于原视频时长，否则出错
   * sign:  签名字符串  对于普通防盗链和带试看功能防盗链
   *
   * 普通防盗链签名：
   * sign = md5(KEY+appId+fileId+t+us)
   *
   * 带试看的防盗链签名：
   * sign = md5(KEY+appId+fileId+t+exper+us)
   *
   * 例子
   * http://playvideo.qcloud.com/getplayinfo/v2/1255566655/4564972818519602447?&t=5c08d9fa&us=someus&sign=65b202bc855c0981da719f2d8df85859
   * @param appID
   * @param fileID
   */


  MediaAsyncLoader.prototype.getInfoV2 = function getInfoV2(args) {
    var player = this.player();
    var url = this.assemblyPath('getplayinfo', args['appID'], args['fileID']);
    // url = //playvideo.qcloud.com/getplayinfo/v2/1253874054/7447398156382199900
    var _t = args['t'],
        _key = 'mykey',
        _us = args['us'],
        _exper = args['exper'],
        _sign = args['sign'];
    var params = {};

    if (args['ssign']) {
      //控制台预览必传参数
      params['super_sign'] = args['ssign'];
    } else if (_sign) {
      //key防盗链
      params = {
        't': _t,
        'sign': _sign
      };
      if (_us || _us == 0) {
        params['us'] = _us;
      }
      if (_exper || _exper == 0) {
        params['exper'] = _exper;
        player.trigger({ type: 'feature', data: 'exper' });
      }
      player.trigger({ type: 'feature', data: 'key' });
    }
    // 播放器配置ID
    if (args['playerID']) {
      params['playerid'] = args['playerID'];
    }
    // console.log(params);
    this.requestTimestamp = +new Date().getTime();
    player.trigger({ type: 'playcgistart', data: { time: this.requestTimestamp, url: url } });
    log$2('playcgi loading');

    //xhr时需要拼接 url
    var queryString$$1 = queryString.stringify(params);
    if (queryString$$1) {
      url += (~url.indexOf('?') ? '&' : '?') + queryString$$1;
      url = url.replace('?&', '?');
    }

    //重试逻辑 出现超时或者返回异常数据 在onResult 里重新调用 getInfoRequest
    this.getInfoRetryTimes = 0;
    this.getInfoRequest = function (isBackup) {
      if (isBackup) {
        // TODO 把url playvideo.qcloud.com 切换为备份域名 bkplayvideo.qcloud.com
        url = url.replace(SERVER_PATH, SERVER_PATH_BACKUP);
      }
      if (IE_VERSION && IE_VERSION < 10) {
        jsonp(url, {
          param: params,
          timeout: 3000,
          prefix: 'TcCallBack'
        }, bind(this, this.onResult));
      } else {
        xhr({
          url: url,
          timeout: 3000
        }, bind(this, this.onResult));
      }
    };
    this.getInfoRequest();
  };

  /**
   * jsonp请求响应
   * @param error
   * @param result
   */


  MediaAsyncLoader.prototype.onResult = function onResult(error, result, body) {
    // console.log('onResult', error, result, body);
    // 处理 xhr 返回的数据格式，注意 body 可能不是 json 格式
    try {
      if (body) {
        result = JSON.parse(body);
      } else if (!error && !result) {
        error = new Error('ServerError');
      }
    } catch (exception) {
      error = new Error('ServerError');
    }

    var player = this.player();

    if (!error) {
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });

      if (result.code != 0) {
        //server data error
        log$2('playcgi loaded failure');
        this.player().error({ code: result.code });
        return;
      }
      log$2('playcgi loaded success');
      var coverInfo = result.coverInfo,
          videoInfo = result.videoInfo,
          playerInfo = result.playerInfo;

      this.setPoster(coverInfo);
      this.setLogo(playerInfo);
      this.setSrc(result);
      this.setPatch(playerInfo);
      this.setVttThumbnail(result);
      this.setDots(result);
      this.setOriginDuration(videoInfo);
      this.setPlayList(playerInfo);
    } else {
      log$2('playcgi loaded failure');
      // retry playcgi返回无法识别的数据，或者超时没有响应，重试3次
      if (this.getInfoRetryTimes < 3) {
        this.getInfoRetryTimes++;
        this.getInfoRequest();
        return;
      } else if (this.getInfoRetryTimes < 6) {
        this.getInfoRetryTimes++;
        this.getInfoRequest({ isBackup: true });
        return;
      }
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });
      // server error or timeout
      var code = 12;
      switch (error.message) {
        case 'XMLHttpRequest timeout':
        case 'Timeout':
          code = 10;
          break;
        case 'ServerError':
          code = 11;
          break;
      }
      this.player().error({ code: code });
    }
  };

  /**
   * playcgi V3 版本
   *
   * 无防盗链
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}/{playDefinition}
   * 普通防盗链（Referer和带时间戳防盗链）
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}/{playDefinition}?playerid=233&t=5949fdc9&us=test_user&sign=xxx
   * 带有播放 IP 数限制的防盗链（rlimit 指定播放数限制）
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}/{playDefinition}?playerid=233&t=5949fdc9&rlimit=3&us=test_user&sign=xxx
   *
   * --------- path 字段: ---------
   * appId	应用 appid
   * fileId	文件 ID
   * version	v3
   * interface	getplayinfo
   * playDefinition	播放模板 ID
   *
   * --------- querystring 字段: ---------
   * playerid	播放器 ID，可选。默认使用文件绑定的播放器 ID 或默认播放器 ID
   * t	16进制字符串，表示链接的过期时间，仅当开启防盗链时填写
   * us	唯一标识请求，增加链接唯一性，仅当开启防盗链时填写
   * rlimit	允许不同 IP 的播放次数，仅当开启防盗链且需要开启试看时填写
   * sign	防盗链签名
   *
   * --------- 签名计算方式 ---------
   * 普通防盗链签名：
   * sign = md5(KEY+appId+fileId+playDefinition+t+us)
   * 带有播放 IP 数限制的防盗链
   * sign = md5(KEY+appId+fileId+playDefinition+t+rlimit+us)
   *
   * @param args
   */


  MediaAsyncLoader.prototype.getInfoV3 = function getInfoV3(args) {
    var player = this.player();
    var url = this.assemblyPathV3('getplayinfo', args['appID'], args['fileID'], args['playDefinition']);
    var _t = args['t'],
        _us = args['us'],
        _rlimit = args['rlimit'],
        _sign = args['sign'];
    var params = {};

    if (args['ssign']) {
      //控制台预览必传参数 v3 版本 控制台逻辑待定
      params['super_sign'] = args['ssign'];
    } else if (_sign) {
      //key防盗链
      params = {
        't': _t,
        'sign': _sign
      };
      if (_us || _us == 0) {
        params['us'] = _us;
      }
      if (_rlimit) {
        params['rlimit'] = _rlimit;
      }
      player.trigger({ type: 'feature', data: 'key' });
    }
    // 播放器配置ID
    if (args['playerID']) {
      params['playerid'] = args['playerID'];
    }
    this.requestTimestamp = +new Date().getTime();
    player.trigger({ type: 'playcgistart', data: { time: this.requestTimestamp, url: url } });
    log$2('playcgi v3 loading');

    //xhr时需要拼接 url
    var queryString$$1 = queryString.stringify(params);
    if (queryString$$1) {
      url += (~url.indexOf('?') ? '&' : '?') + queryString$$1;
      url = url.replace('?&', '?');
    }

    //重试逻辑 出现超时或者返回异常数据 在onResult 里重新调用 getInfoRequest
    this.getInfoRetryTimes = 0;
    this.getInfoRequest = function (isBackup) {
      if (isBackup) {
        // TODO 把url playvideo.qcloud.com 切换为备份域名 bkplayvideo.qcloud.com
        url = url.replace(SERVER_PATH_V3, SERVER_PATH_BACKUP);
      }
      if (IE_VERSION && IE_VERSION < 10) {
        jsonp(url, {
          param: params,
          timeout: 1000 * 3,
          prefix: 'TcCallBack'
        }, bind(this, this.onResultV3));
      } else {
        xhr({
          url: url,
          timeout: 3000
        }, bind(this, this.onResultV3));
      }
    };
    this.getInfoRequest();
  };

  /**
   * V3 应答数据
   * playerInfo
   *
   * mediaInfo
   *  basicInfo	Object	视频基本信息，类型为 BasicInfo 类型。
   *  adaptiveDynamicStreamingInfo	Object	多码率视频信息，类型为 AdaptiveDynamicStreamingInfo 类型。
   *  previewStreamingInfo	Object	试看视频信息，类型为 PreviewStreamingInfo 类型。
   *  imageSpriteInfo	Object	雪碧图信息，主要用于实现播放器对视频的预览，参考雪碧图信息。
   *  keyFrameDescInfo	Object	视频打点信息，用于播放器在时间轴上的打点，参考打点信息。
   *
   * basicInfo
   *  name	String	视频名称。
   *  size	Integer	视频大小。
   *  duration	Float	视频时长。
   *  description	String	视频描述。
   *  coverUrl	String	视频封面。
   *
   * @param error
   * @param result
   * @param body
   */


  MediaAsyncLoader.prototype.onResultV3 = function onResultV3(error, result, body) {
    // console.log('onResultV3', error, result, body);
    try {
      if (body) {
        result = JSON.parse(body);
      } else if (!error && !result.body) {
        error = new Error('ServerError');
      }
    } catch (exception) {
      error = new Error('ServerError');
    }

    var player = this.player();

    if (!error) {
      // console.log('play cgi', result);
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });

      if (result.code != 0) {
        //server data error
        log$2('playcgi v3 loaded failure');
        this.player().error({ code: result.code });
        return;
      }
      log$2('playcgi v3 loaded success');

      var mediaInfo = result.mediaInfo,
          playerInfo = result.playerInfo;

      this.setPoster({ coverUrl: mediaInfo['basicInfo']['coverUrl'] });
      this.setLogo(playerInfo);
      this.setSrcV3(mediaInfo);
      this.setPatch(playerInfo);
      this.setVttThumbnail(mediaInfo);
      this.setDots(mediaInfo);
    } else {
      log$2('playcgi v3 loaded failure');
      // retry playcgi返回无法识别的数据，或者超时没有响应，重试3次
      if (this.getInfoRetryTimes < 3) {
        this.getInfoRetryTimes++;
        this.getInfoRequest();
        return;
      } else if (this.getInfoRetryTimes < 6) {
        this.getInfoRetryTimes++;
        this.getInfoRequest({ isBackup: true });
        return;
      }
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });
      // server error or timeout
      var code = 12;
      switch (error.message) {
        case 'XMLHttpRequest timeout':
        case 'Timeout':
          code = 10;
          break;
        case 'ServerError':
          code = 11;
          break;
      }
      this.player().error({ code: code });
    }
  };

  /**
   * 判断环境
   * Chrome widevine 方案
   * Safari fairplay 方案
   * 非以上浏览器，支持hls simple AES 播放的浏览器
   * @param mediaInfo
   */


  MediaAsyncLoader.prototype.setSrcV3 = function setSrcV3(mediaInfo, skipPlan) {
    var _this2 = this;

    var player = this.player(),
        optionsPlugins = player.options_.plugins,
        DRMOptions = player.DRM().options || optionsPlugins.DRM,
        token = void 0,
        urlEncodeToken = void 0,
        certificateUri = void 0,
        src = [],
        previewList = {},
        streamList = {};
    skipPlan = skipPlan ? skipPlan : DRMOptions ? DRMOptions.skipPlan : '';
    console.log('setSrcV3', mediaInfo, player.options_);
    if (mediaInfo['previewStreamingInfo'] && mediaInfo['previewStreamingInfo']['previewStreamingList'].length > 0) {
      // 试看视频
      mediaInfo['previewStreamingInfo']['previewStreamingList'].forEach(function (item, index) {
        item.mineType = _this2.getMIMEType(item.url);
        previewList[getFileExtension(item.url)] = item;
      });
    } else if (mediaInfo['dynamicStreamingInfo']['adaptiveStreamingInfoList'] && mediaInfo['dynamicStreamingInfo']['adaptiveStreamingInfoList'].length > 0) {
      // 正式视频地址
      mediaInfo['dynamicStreamingInfo']['adaptiveStreamingInfoList'].forEach(function (item, index) {
        item.mineType = _this2.getMIMEType(item.url);
        streamList[item['drmType'].toLowerCase() || getFileExtension(item.url)] = item;
      });
      // 没有DRM配置则跳过CDM的加密播放方案
      if (!DRMOptions || !DRMOptions.token) {
        skipPlan = 'all';
      } else {
        token = DRMOptions.token;
        certificateUri = DRMOptions.certificateUri;
        skipPlan = IS_SAFARI && !certificateUri ? 'fairplay' : skipPlan;
        urlEncodeToken = window_1.encodeURIComponent(token);
      }
      console.log(browser);
      console.log(window_1.navigator.userAgent);
      // 判断平台选择对应的播放方案
      // 目前只有原生chrome 和 Firefox 支持 widevine
      if ((IS_CHROME || IS_FIREFOX) && window_1.navigator.requestMediaKeySystemAccess && streamList['widevine'] && skipPlan != 'widevine' && skipPlan != 'all') {
        // widevine
        src.push({
          'src': unifyProtocol(streamList['widevine']['url']),
          'type': this.getMIMEType(streamList['widevine']['url']),
          'keySystems': {
            'com.widevine.alpha': {
              serverURL: LICENSE_PATH + '?token=' + urlEncodeToken + '&drmType=' + streamList['widevine']['drmType']
            }
          }
        });
        log$2('DRM source widevine', src);
      } else if (IS_SAFARI && !IS_MQQB && streamList['fairplay'] && skipPlan != 'fairplay' && skipPlan != 'all') {
        // fairplay
        src.push({
          'src': unifyProtocol(streamList['fairplay']['url']),
          'type': this.getMIMEType(streamList['fairplay']['url']),
          'keySystems': {
            'com.apple.fps.1_0': {
              certificateUri: certificateUri,
              licenseUri: LICENSE_PATH + '?token=' + urlEncodeToken + '&drmType=' + streamList['fairplay']['drmType']
            }
          }
        });
        log$2('DRM source fairplay', src);
      }
      if (streamList['simpleaes'] && skipPlan != 'all') {
        // simpleAES
        var url = streamList['simpleaes']['url'].split('/');
        url[url.length - 1] = 'voddrm.token.' + urlEncodeToken + '.' + url[url.length - 1];
        src.push({
          'src': unifyProtocol(url.join('/')), // + voddrm.token.<xxx>.adp.1012.m3u8。
          'type': this.getMIMEType(streamList['simpleaes']['url'])
        });
        log$2('DRM source simpleaes', src);
      }
      if (streamList['m3u8']) {
        src.push({
          'src': unifyProtocol(streamList['m3u8']['url']),
          'type': this.getMIMEType(streamList['m3u8']['url'])
        });
      }
      if (streamList['mpd']) {
        src.push({
          'src': unifyProtocol(streamList['mpd']['url']),
          'type': this.getMIMEType(streamList['mpd']['url'])
        });
      }
    } else {
      this.player().error({ code: 13, message: 'no video stream' });
      return;
    }
    console.log(streamList, previewList, src);
    if (src.length > 0) {
      player.src(src);
    } else {
      this.player().error({ code: 4 });
      return;
    }

    var onError = function onError(event) {
      console.log('DRM init Error', event);
      log$2('DRM init Error', src);
      // 播放失败时选择另一种播放方案
      // dash getlicense 失败 5
      // dash get fragment 失败 2
      // fairplay natvie getlicense 失败 3
      // simpleAES hls.js getkey 失败返回 14
      // simpleAES natvie getKey 失败返回 3
      if ((event.data.code === 5 || event.data.code === 2) && src[0]['keySystems']['com.widevine.alpha']) {
        _this2.setSrcV3(mediaInfo, 'widevine');
        return;
      }
      if (event.data.code === 3 && src[0]['keySystems']['com.apple.fps.1_0']) {
        _this2.setSrcV3(mediaInfo, 'fairplay');
        return;
      }
      if (event.data.code === 14 || event.data.code === 3) {
        _this2.setSrcV3(mediaInfo, 'all');
        return;
      }
    };
    if (skipPlan !== 'all') {
      window_1.setTimeout(function () {
        player.one('error', onError);
      }, 0);
      player.one('playing', function (event) {
        // player.off('error', onError);
      });
    }
  };
  /**
   * playcgi V4 版本
   *
   * 请求结构
   * https://playvideo.qcloud.com/{interface}/{version}/{appId}/{fileId}?pcfg=.&t=.&rlimit=.&us=.&psign=xxx
   *
   * 基础方式
   * https://playvideo.qcloud.com/getplayinfo/v4/1255566655/4564972818519602447
   * 带试看时间
   * https://playvideo.qcloud.com/getplayinfo/v4/1255566655/4564972818519602447?exper=300
   * 指定播放配置
   * https://playvideo.qcloud.com/getplayinfo/v4/1255566655/4564972818519602447?pcfg=MyCfg
   * KEY 防盗链（带过期时间戳）
   * https://playvideo.qcloud.com/getplayinfo/v4/1255566655/4564972818519602447?t=5949fdc9&us=test_user&psign=xxx
   * 带有播放 IP 数限制的 KEY 防盗链（rlimit 指定播放数限制）
   * https://playvideo.qcloud.com/getplayinfo/v4/1255566655/4564972818519602447?t=5949fdc9&rlimit=3&us=test_user&psign=xxx
   *
   * --------- path 字段: ---------
   * appId	应用 appid
   * fileId	文件 ID
   * version	v4
   * interface	getplayinfo
   *
   * --------- querystring 字段: ---------
   * pcfg	播放配置名称
   * t	16进制字符串，表示链接的过期时间，仅当开启防盗链时填写
   * exper	视频的试看时长，仅当需要试看时填写
   * rlimit	允许不同 IP 的播放次数，仅当开启防盗链且需要开启试看时填写
   * us	唯一标识请求，增加链接唯一性，仅当开启防盗链时填写
   * psign	防盗链签名，使用防盗链 KEY 对其他参数做签名
   *
   * --------- 签名计算方式 ---------
   * 盗链签名：
   * psign = md5(KEY+appId+fileId+pcfg+t+exper+rlimit+us)
   *
   *
   * @param args
   */


  MediaAsyncLoader.prototype.getInfoV4 = function getInfoV4(args) {
    var player = this.player();
    var url = this.assemblyPathV4('getplayinfo', args['appID'], args['fileID']);
    var _t = args['t'],
        _us = args['us'],
        _rlimit = args['rlimit'],
        _psign = args['psign'],
        _exper = args['exper'];
    var params = {};

    if (args['ssign']) {
      //控制台预览必传参数 v4 版本 控制台逻辑待定
      params['super_sign'] = args['ssign'];
    } else if (_psign) {
      //key防盗链
      params = {
        't': _t,
        'psign': _psign
      };
      if (_us || _us == 0) {
        params['us'] = _us;
      }
      if (_rlimit) {
        params['rlimit'] = _rlimit;
      }
      if (_exper) {
        params['exper'] = _exper;
      }
    }
    // 播放v4版本的播放器配置
    if (args['playerConfig']) {
      params['pcfg'] = args['playerConfig'];
    }
    // 兼容v2版本的播放器配置ID
    if (args['playerID']) {
      params['playerid'] = args['playerID'];
    }
    this.requestTimestamp = +new Date().getTime();
    player.trigger({ type: 'playcgistart', data: { time: this.requestTimestamp, url: url } });
    log$2('playcgi v4 loading');

    //xhr时需要拼接 url
    var queryString$$1 = queryString.stringify(params);
    if (queryString$$1) {
      url += (~url.indexOf('?') ? '&' : '?') + queryString$$1;
      url = url.replace('?&', '?');
      if (IS_ENABLED_MSE && (!IS_ANY_SAFARI || IS_MAC && IS_SAFARI)) {
        this.enModule = new Enc();
        url = this.enModule.generatePlayCgiUrl(url);
      }
    }

    //重试逻辑 出现超时或者返回异常数据 在onResult 里重新调用 getInfoRequest
    this.getInfoRetryTimes = 0;
    this.getInfoRequest = function (isBackup) {
      if (isBackup) {
        // TODO 把url playvideo.qcloud.com 切换为备份域名 bkplayvideo.qcloud.com
        url = url.replace(SERVER_PATH_V4, SERVER_PATH_BACKUP);
      }
      if (IE_VERSION && IE_VERSION < 10) {
        jsonp(url, {
          param: params,
          timeout: 3000,
          prefix: 'TcCallBack'
        }, bind(this, this.onResultV4));
      } else {
        xhr({
          url: url,
          timeout: 3000
        }, bind(this, this.onResultV4));
      }
    };
    this.getInfoRequest();
  };
  /**
   * V4 应答数据
   *
   */


  MediaAsyncLoader.prototype.onResultV4 = function onResultV4(error, result, body) {
    try {
      if (body) {
        result = JSON.parse(body);
      } else if (!error && !result.body) {
        error = new Error('ServerError');
      }
    } catch (exception) {
      error = new Error('ServerError');
    }
    // 测试数据
    // result = {
    //   "code": 0,
    //   "message": "",
    //   "requestId": "829c5b727bdd4b0fa58f1545d4cc4602",
    //   "version": 4,
    //   "context": "",
    //   "warning": "",http://localhost:8081/docs/examples/vod/tcplayer-vod-drm.html
    //   "media": {
    //     "basicInfo": {
    //       "name": "播放器预览视频",
    //       "size": 25690944,
    //       "duration": 61,
    //       "coverUrl": "http://1256993030.vod2.myqcloud.com/20f8b585vodgzp1256993030/7732bd367447398157015849771/7447398156945023921.jpg",
    //       "description": "-"
    //     },
    //     "streamingInfo": {
    //       "plainOutput": {
    //         "type": "plain",
    //         "url": "http://1256993030.vod2.myqcloud.com/d520582dvodtransgzp1256993030/7732bd367447398157015849771/adp.10.m3u8",
    //         "subStreams": null
    //       }
    //     },
    //     "imageSpriteInfo": {
    //       "webVttUrl": "http://1256993030.vod2.myqcloud.com/d520582dvodtransgzp1256993030/7732bd367447398157015849771/imageSprite/1559273486.vtt",
    //       "imageUrls": ["http://1256993030.vod2.myqcloud.com/d520582dvodtransgzp1256993030/7732bd367447398157015849771/imageSprite/1559273486_2075510498.100_0.jpg"]
    //     },
    //     "keyFrameDescInfo": {
    //       "keyFrameDescList": [{
    //         "content": "%E4%BA%91%E7%AB%AF%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%88%9B%E6%96%B0%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8",
    //         "timeOffset": 2000
    //       }, {
    //         "content": "%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E9%81%8D%E5%B8%83%E5%85%A8%E7%90%83%E4%BA%94%E5%A4%A7%E6%B4%B2%EF%BC%8C600%E4%B8%AACDN%E8%8A%82%E7%82%B9",
    //         "timeOffset": 12000
    //       }, {
    //         "content": "%E6%8F%90%E4%BE%9B%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%88%B0%E5%B9%B3%E5%8F%B0%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%B1%82%E4%BA%91%E6%9C%8D%E5%8A%A1",
    //         "timeOffset": 19000
    //       }, {
    //         "content": "%E6%9B%B4%E7%8B%AC%E5%AE%B6%E6%8E%A8%E5%87%BA%E9%BB%91%E7%9F%B3%E5%86%85%E7%BD%91%E7%BA%A7%E6%B7%B7%E5%90%88%E4%BA%91%E6%9E%B6%E6%9E%84",
    //         "timeOffset": 26000
    //       }, {
    //         "content": "%E6%8F%90%E4%BE%9B%E4%B8%93%E4%B8%9A%E4%BA%91%E8%AE%A1%E7%AE%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88",
    //         "timeOffset": 38000
    //       }, {
    //         "content": "%E4%BC%98%E5%9B%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%EF%BC%8C%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E7%AD%89",
    //         "timeOffset": 46000
    //       }, {
    //         "content": "%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%8E%E6%82%A8%E5%85%B1%E5%90%8C%E8%BF%9E%E6%8E%A5%E6%99%BA%E8%83%BD%E6%9C%AA%E6%9D%A5",
    //         "timeOffset": 55000
    //       }]
    //     }
    //   }
    // }


    var player = this.player();
    if (!error) {
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });

      if (result.code != 0) {
        //server data error
        log$2('playcgi v4 loaded failure');
        if (result.code >= 2000 && result.code < 3000) {
          if (this.getInfoRetryTimes < 3) {
            this.getInfoRetryTimes++;
            this.getInfoRequest();
            return;
          } else if (this.getInfoRetryTimes < 6) {
            this.getInfoRetryTimes++;
            this.getInfoRequest({ isBackup: true });
            return;
          }
        }
        this.player().error({ code: result.code });
        return;
      }
      log$2('playcgi v4 loaded success', result);

      if (result.version === 4) {
        // v4 的处理逻辑
        // media Object	媒体信息，元素类型为 Media，当 version 为 4 时有效。
        // 当有转自适应码流结果时，返回 V4 版本输出
        // "media": {
        //   "basicInfo": {
        //     "name": "动物世界",
        //     "size": 26246026,
        //     "duration": 30.5,
        //     "description": "来自CCTV的经典动物节目",
        //     "coverUrl": "http://xxx.vod2.myqcloud.com/xxx/xxx/xx.jpg?t=5c08d9fa&us=someus&sign=xxx"
        //   },
        //   "adaptiveDynamicStreamingInfo": {
        //     "url": "http://xxx.vod2.myqcloud.com/xxx/xxx/xx.m3u8?t=5c08d9fa&us=someus&sign=xxx",
        //     "drmUrls": []
        //   },
        //   "imageSpriteInfo": {
        //     "webVttUrl": "http://xx.vod2.myqcloud.com/xxx/xxx/xx.vtt?t=5c08d9fa&us=someus&sign=xxx"
        //   },
        //   "keyFrameDescInfo": {
        //     "keyFrameDescList": [{
        //         "timeOffset": 1.1, // 毫秒
        //         "content": "片头开始..."
        //       },
        //       {
        //         "timeOffset": 100.2, // 毫秒
        //         "content": "即将结束..."
        //       }
        //     ]
        //   }
        // }
        // player Object 播放器配置，元素类型为 Player，当 version 为 4 时有效。
        // "player": {
        //   "resolutionNames": [{
        //     "minEdgeLength": 240,
        //     "name": "流畅"
        // },
        // {
        //     "minEdgeLength": 480,
        //     "name": "标清"
        // },
        // {
        //     "minEdgeLength": 720,
        //     "name": "高清"
        // }}

        var mediaInfo = result.media;
        this.setPoster({ coverUrl: mediaInfo['basicInfo']['coverUrl'] });
        this.setSrcV4(mediaInfo);
        this.setVttThumbnailV4(mediaInfo);
        this.setDots(mediaInfo);
        this.setOriginDurationV4(mediaInfo);
      } else if (result.version === 2) {
        // 要兼容 v2 的处理逻辑
        var coverInfo = result.coverInfo,
            videoInfo = result.videoInfo,
            playerInfo = result.playerInfo;

        this.setPoster(coverInfo);
        this.setLogo(playerInfo);
        this.setSrc(result);
        this.setPatch(playerInfo);
        this.setVttThumbnail(result);
        this.setDots(result);
        this.setOriginDuration(videoInfo);
        // this.setPlayList(playerInfo);
      }
    } else {
      log$2('playcgi v4 loaded failure');
      // retry playcgi返回无法识别的数据，或者超时没有响应，重试3次
      if (this.getInfoRetryTimes < 3) {
        this.getInfoRetryTimes++;
        this.getInfoRequest();
        return;
      } else if (this.getInfoRetryTimes < 6) {
        this.getInfoRetryTimes++;
        this.getInfoRequest({ isBackup: true });
        return;
      }
      player.trigger({
        type: 'playcgiend',
        data: { time: +new Date().getTime(), startTime: this.requestTimestamp, error: error, result: result }
      });
      // server error or timeout
      var code = 12;
      switch (error.message) {
        case 'XMLHttpRequest timeout':
        case 'Timeout':
          code = 10;
          break;
        case 'ServerError':
          code = 11;
          break;
      }
      this.player().error({ code: code });
    }
  };
  /**
   * v4接口只支持 master play list
   *
   * @param {Object} mediaInfo
   */


  MediaAsyncLoader.prototype.setSrcV4 = function setSrcV4(mediaInfo, skipPlan) {
    var _this3 = this;

    console.log('setSrcV4', mediaInfo);
    var player = this.player(),
        options = player.options_,
        src = void 0,
        qualityLabelList = void 0,
        optionsPlugins = player.options_.plugins,
        DRMOptions = player.DRM().options || optionsPlugins.DRM;

    var drmType = 'plain';
    skipPlan = skipPlan ? skipPlan : DRMOptions ? DRMOptions.skipPlan : '';
    var drmData = [];
    var drmTypes = []; // 接口返回了几个drm方案


    // 如果配置了播放原始或者转码文件，去setSrc处理
    if (mediaInfo.audioVideoType === 'Original' || mediaInfo.audioVideoType === 'Transcode') {
      this.setSrc(mediaInfo);
      return false;
    }

    // 没有流信息，报错
    if (!mediaInfo.streamingInfo) {
      this.player().error({ code: 13, message: 'no stream info' });
      return;
    }

    // 优先播放无加密的 HLS MPL
    if (mediaInfo.streamingInfo) {
      // 设置视频播放地址
      if (mediaInfo.streamingInfo.drmOutput && Array.isArray(mediaInfo.streamingInfo.drmOutput)) {
        // drm
        console.log('setSrcV4 DRM');
        // 统计服务端设置的 drm 策略，存入 drmTypes
        var drmArray = mediaInfo.streamingInfo.drmOutput;
        for (var i = 0; i < drmArray.length; i++) {
          drmTypes.push(drmArray[i].type);
        }

        if (IS_ANY_SAFARI && !IS_MQQB && drmTypes.indexOf('FairPlay') !== -1 && skipPlan != 'fairplay' && skipPlan != 'all') {
          var drmIndex = drmTypes.indexOf('FairPlay');
          qualityLabelList = drmArray[drmIndex].subStreams;
          // fairplay
          drmData.push({
            'src': unifyProtocol(drmArray[drmIndex]['url']),
            'type': this.getMIMEType(drmArray[drmIndex]['url']),
            'keySystems': {
              'com.apple.fps.1_0': {
                certificateUri: mediaInfo.streamingInfo.fairPlayCertificateUrl || (DRMOptions || {}).certificateUri,
                licenseUri: mediaInfo.streamingInfo.fairplayLicenseUrl
              }
            }
          });
          log$2('DRM source fairplay', src);
        } else if (window_1.navigator.requestMediaKeySystemAccess && drmTypes.indexOf('Widevine') !== -1 && skipPlan !== 'widevine' && skipPlan !== 'all') {
          // widevine
          var _drmIndex = drmTypes.indexOf('Widevine');
          qualityLabelList = drmArray[_drmIndex].subStreams;
          var audioStream = qualityLabelList[qualityLabelList.length - 1];
          // widevine 会返回音频流，把音频流去除
          if (audioStream.type === 'audio' || audioStream.width === 0 && audioStream.height === 0) {
            qualityLabelList.pop();
          }
          drmData.push({
            'src': unifyProtocol(drmArray[_drmIndex]['url']),
            'type': this.getMIMEType(drmArray[_drmIndex]['url']),
            'keySystems': {
              'com.widevine.alpha': {
                // serverURL: mediaInfo.streamingInfo.widevineLicenseUrl + '?drmToken=' + mediaInfo.streamingInfo.drmToken,
                serverURL: mediaInfo.streamingInfo.widevineLicenseUrl
              }
            }
          });
          log$2('DRM source widevine', src);
        }

        if (drmTypes.indexOf('SimpleAES') !== -1 && skipPlan != 'all') {
          var _keySystems;

          var _drmIndex2 = drmTypes.indexOf('SimpleAES');
          drmType = 'SimpleAES';
          var _url = drmArray[_drmIndex2].url.split('/');
          _url[_url.length - 1] = 'voddrm.token.' + mediaInfo.streamingInfo.drmToken + '.' + _url[_url.length - 1];
          src = _url.join('/');
          qualityLabelList = drmArray[_drmIndex2].subStreams;

          src && drmData.push({
            'src': unifyProtocol(src),
            'type': EXT_MIME['m3u8'],
            'keySystems': (_keySystems = {}, _keySystems[drmType] = {}, _keySystems)
          });
        }
      } else if (mediaInfo.streamingInfo.plainOutput) {
        var _keySystems2;

        // 不加密文件播放
        src = mediaInfo.streamingInfo.plainOutput.url;
        src && drmData.push({
          'src': unifyProtocol(src),
          'type': EXT_MIME['m3u8'],
          'keySystems': (_keySystems2 = {}, _keySystems2[drmType] = {}, _keySystems2)
        });
        qualityLabelList = mediaInfo.streamingInfo.plainOutput.subStreams;
      }

      this.setHlsConfig(options, qualityLabelList, drmTypes.indexOf('SimpleAES') !== -1 && drmTypes.length > 1);

      console.log('setSrcV4', src);
      if (drmData.length > 0) {
        player.src(drmData);
      } else {
        if (drmTypes.length !== 0) {
          this.player().error({ code: 18 });
        } else {
          this.player().error({ code: 13, message: 'no stream info' });
        }
      }
      this.setQualityLabelList(qualityLabelList);
    }

    var onError = function onError(event) {
      console.log('DRM init Error', event);
      log$2('DRM init Error', drmData);
      // 播放失败时选择另一种播放方案
      // dash getlicense 失败 5
      // dash get fragment 失败 2
      // fairplay natvie getlicense 失败 3
      // simpleAES hls.js getkey 失败返回 14
      // simpleAES natvie getKey 失败返回 3
      if (drmData[0]['keySystems']['com.widevine.alpha']) {
        console.log('jiangjiwidevine_' + event.data.code);
        _this3.setSrcV4(mediaInfo, 'widevine');
        return;
      }
      if (drmData[0]['keySystems']['com.apple.fps.1_0']) {
        _this3.setSrcV4(mediaInfo, 'fairplay');
        return;
      }
      if (event.data.code === 14 || event.data.code === 3) {
        _this3.setSrcV4(mediaInfo, 'all');
        return;
      }
    };
    if (skipPlan !== 'all') {
      window_1.setTimeout(function () {
        player.one('error', onError);
      }, 0);
    }
  };

  // 设置 hlsconfig


  MediaAsyncLoader.prototype.setHlsConfig = function setHlsConfig(options, qualityLabelList, drmBackup) {
    // 如果没有设置 hlsConfig 优先播放 5 level，如果没有5 level 则播放最高level
    var startLevel = 5;
    if (!options.hlsConfig) {
      options.hlsConfig = {
        overlayKey: this.enModule && this.enModule.overlayKey,
        overlayIv: this.enModule && this.enModule.overlayIv,
        qualityLabelList: qualityLabelList,
        // drmBackup,
        startLevel: qualityLabelList ? qualityLabelList.length - 1 || startLevel : startLevel
      };
    } else {
      options.hlsConfig.overlayKey = this.enModule && this.enModule.overlayKey;
      options.hlsConfig.overlayIv = this.enModule && this.enModule.overlayIv;
      options.hlsConfig.qualityLabelList = qualityLabelList;
      // options.hlsConfig.drmBackup = drmBackup;
      if (!options.hlsConfig.startLevel) {
        options.hlsConfig.startLevel = qualityLabelList ? qualityLabelList.length - 1 || startLevel : startLevel;
      }
    }
  };

  /**
   * 设置清晰度映射关系
   * @param {*} qualityLabelList subStreams
   */


  MediaAsyncLoader.prototype.setQualityLabelList = function setQualityLabelList(list) {
    console.log('setQualityLabelList', list);
    this.player().QualitySwitcher().setOptions({
      qualityLabelList: {
        video: list
      }
    });
  };
  /**
   * 更新logo
   * @param playerInfo
   */


  MediaAsyncLoader.prototype.setLogo = function setLogo(playerInfo) {
    var player = this.player();
    if (playerInfo['logoPic']) {
      player.logoImage.update({
        img: {
          url: unifyProtocol(playerInfo['logoPic']),
          position: playerInfo['logoLocation']
        },
        link: unifyProtocol(playerInfo['logoUrl'])
      });
      player.trigger({ type: 'feature', data: 'logo' });
      /*player.trigger({
        type: 'logochange', data: {
          img: {
            url: Utils.unifyProtocol(playerInfo['logoPic']),
            position: playerInfo['logoLocation']
          },
          link: Utils.unifyProtocol(playerInfo['logoUrl'])
        }
      });*/
    } else {
      player.logoImage.reset();
    }
  };

  MediaAsyncLoader.prototype.setPoster = function setPoster(coverInfo) {
    var player = this.player();
    if (coverInfo && coverInfo['coverUrl']) {
      player.poster(unifyProtocol(coverInfo['coverUrl']));
    } else {
      // reset 如果通过video poster属性指定了封面，这里会把封面删除，判断原始配置poster是否有封面，没有再删除接口获取的配置
      if (!player.options_.playerOptions.poster) {
        player.poster('');
      }
    }
  };

  MediaAsyncLoader.prototype.setDots = function setDots(result) {
    var player = this.player();
    //首先进行清空。可能会存在之前的点。
    player.options_.dots = null;
    if (result.keyFrameDescInfo && result.keyFrameDescInfo.keyFrameDescList && result.keyFrameDescInfo.keyFrameDescList.length > 0) {
      var dots = result.keyFrameDescInfo.keyFrameDescList;
      player.options_.dots = dots;
    }

    var customizedPlugins = player.options_.plugins;
    if (customizedPlugins && customizedPlugins['ProgressMarker'] && customizedPlugins['ProgressMarker'].markers && customizedPlugins['ProgressMarker'].markers.length > 0) {
      player.options_.dots = player.options_.dots.concat(customizedPlugins['ProgressMarker'].markers);
    }

    player.ProgressMarker().init();
  };

  MediaAsyncLoader.prototype.setSrc = function setSrc(result) {
    var player = this.player();
    // v4播放原始视频
    var videoInfo = result.videoInfo || {};
    if (result.audioVideoType === 'Original') {
      videoInfo['sourceVideo'] = result.originalInfo;
    }

    // v4播放转码文件
    if (result.audioVideoType === 'Transcode') {
      videoInfo['sourceVideo'] = result.transcodeInfo;
    }

    // 自定义域名替换，该属性暂不提供文档说明，点播后台告知控制台已支持配置自定义域名并通过playcgi返回，播放端关闭该功能
    // this.customHost(videoInfo);
    if ((player.options_['definition'] != null || player.options_['definition'] != undefined) && videoInfo['transcodeList'] && videoInfo['transcodeList'].length > 0) {
      player.trigger({ type: 'feature', data: 'definition' });
      //指定播放某个分辨率格式视频
      var source = this.getSrcByDefinition(videoInfo, player.options_.definition);
      if (source) {
        player.src({
          'src': unifyProtocol(source['url']),
          'type': this.getMIMEType(source['url'])
        });
        return true;
      }
    }
    // 重置多清晰度插件
    player.MultiResolution().reset();
    if (videoInfo['masterPlayList']) {
      // 优先使用master playlist
      player.src(this.getMasterSouces(videoInfo));
      player.MultiResolution().store(this.getMultiResolutionData(result));
    } else if (videoInfo['transcodeList'] && videoInfo['transcodeList'].length > 0) {
      // 使用多码率视频地址，要注意没有转码的视频
      var multiRes = this.getMultiResolutionData(result);
      if (multiRes['showOrder'].length > 0) {
        player.MultiResolution().init(multiRes);
      } else {
        // 没有找到匹配分辨率配置的视频，比如自定义码率的视频目前不会自动添加到分辨率配置里。获取转码视频里的第一个地址进行播放。
        var url = videoInfo['transcodeList'][0]['url'];
        player.src({
          'src': unifyProtocol(url),
          'type': this.getMIMEType(url)
        });
      }
    } else if (videoInfo['sourceVideo'] && this.getMIMEType(videoInfo['sourceVideo']['url'])) {
      // 没有转码的视频，判断是否有原始视频且格式是否为可播放的格式，如果编码不是h264，则播放失败
      player.src({
        'src': unifyProtocol(videoInfo['sourceVideo']['url']),
        'type': this.getMIMEType(videoInfo['sourceVideo']['url'])
      });
    } else {
      // 没有可用的播放数据
      this.player().error({ code: 13 });
    }
  };

  MediaAsyncLoader.prototype.setPatch = function setPatch(playerInfo) {
    var player = this.player();
    if (playerInfo['patchInfo']) {
      player.ImagePatch().init(playerInfo['patchInfo']);
    } else {
      player.ImagePatch().reset();
    }
  };

  MediaAsyncLoader.prototype.setVttThumbnail = function setVttThumbnail(result) {
    var player = this.player();
    if (result['imageSpriteInfo'] && result['imageSpriteInfo']['imageSpriteList']) {
      player.ready(bind(this, function () {
        player.VttThumbnail().init({
          // 'imgUrl': Utils.unifyProtocol(result['imageSpriteInfo']['imageSpriteList'][0]['imageUrls'][0]), // 图片路径在vtt文件里获取
          'vttUrl': unifyProtocol(result['imageSpriteInfo']['imageSpriteList'][0]['webVttUrl'])
        });
      }));
    } else {
      player.VttThumbnail().reset();
    }
  };

  MediaAsyncLoader.prototype.setVttThumbnailV4 = function setVttThumbnailV4(result) {
    var player = this.player();
    if (result['imageSpriteInfo'] && result['imageSpriteInfo']['webVttUrl']) {
      player.ready(bind(this, function () {
        player.VttThumbnail().init({
          'vttUrl': unifyProtocol(result['imageSpriteInfo']['webVttUrl'])
        });
      }));
    } else {
      player.VttThumbnail().reset();
    }
  };

  /**
   * 开启试看后显示原始视频时长
   * 有缺陷，video触发durationChange 会把duration重置为视频实际时长。特别是hls.js播放时。。
   * @param videoInfo
   */


  MediaAsyncLoader.prototype.setOriginDuration = function setOriginDuration(videoInfo) {
    var player = this.player();
    if (player.options_['exper'] > 0) {
      var originDuration = videoInfo.sourceVideo ? videoInfo.sourceVideo.floatDuration : videoInfo.transcodeList[0].floatDuration;
      player.one('play', function () {
        player.duration(originDuration);
      });
      // 开了试看即使durationchange 也要强制显示原生时长
      // player.one('durationchange', function () {
      //   player.duration(originDuration);
      // });
    }
  };

  MediaAsyncLoader.prototype.setOriginDurationV4 = function setOriginDurationV4(mediaInfo) {
    var _this4 = this;

    var player = this.player();
    // 标记视频原始时长
    player.cache_.originDuration = mediaInfo.basicInfo.duration;
    // let bind = Fn.bind(this, this.keepOriginDuration)
    // console.log('setOriginDurationV4', bind.guid);
    player.off('durationchange', this.keepOriginDuration);
    player.one('durationchange', function (event) {
      // 如果首次获取视频实际时长与原始时长不一致，强制显示原始时长
      if (!player.duration() || player.duration() > 0 && Math.floor(player.cache_.originDuration) !== Math.floor(player.duration())) {
        _this4.keepOriginDuration(event);
        player.on('durationchange', _this4.keepOriginDuration);
      }
    });
  };

  MediaAsyncLoader.prototype.keepOriginDuration = function keepOriginDuration(event) {
    var player = this.player();
    var originDuration = player.cache_.originDuration;
    if (Math.floor(originDuration) !== Math.floor(player.duration())) {
      log$2('试看视频');
      // 以后端给的原始时长为准
      player.duration(Math.round(originDuration));
    }
  };
  /**
   * 获取master player list 提供给player.src & quality switcher
   * @param playerInfo
   * @returns {Array}
   *  - Array
   *    [{
   *      'src': ''
   *      'type': ''
   *    }]
   */


  MediaAsyncLoader.prototype.getMasterSouces = function getMasterSouces(videoInfo) {
    var masterPlaylist = videoInfo.masterPlayList,
        sources = [];
    sources.push({
      'src': unifyProtocol(masterPlaylist.url),
      'type': EXT_MIME['m3u8']
    });
    return sources;
  };

  /**
   * 获取多分辨率数据 提供给mutil resolution plugin & quality switcher 使用
   * @param playerInfo
   * @returns {{sources: {}, labels: {}, showOrder: Array, defaultRes: string}}
   *  - Object
   *    multiResolution:
   *    {
   *      'sources': {'sd':[{Object}]}
   *      'labels': {'sd':'标清','hd':'高清'},
   *      'showOrder': ['sd','hd'],
   *      'defaultRes': 'sd'
   *    }
   */


  MediaAsyncLoader.prototype.getMultiResolutionData = function getMultiResolutionData(result) {
    var multiResolution = {
      'sources': {},
      'labels': {},
      'showOrder': [],
      'defaultRes': ''
    },
        sources = [],
        transcodeList = result.videoInfo['transcodeList'],
        resolutionConfig = result.playerInfo['videoClassification'],
        self = this;
    resolutionConfig.forEach(function (configItem, index) {
      // console.log(configItem, index);
      // transcodeList的length在filter后会减少
      if (transcodeList.length > 0) {
        // console.log(transcodeList.length, multiResolution);
        // 根据清晰度配置，过滤出清晰度在configItem中存在的视频,并按照resolutionConfig的遍历顺序，push到sources
        transcodeList = transcodeList.filter(function (source) {
          if (configItem['definitionList'].indexOf(source.definition) > -1) {
            if (!sources[configItem.id]) {
              // switcher控件的默认显示顺序将按照接口返回配置的数组顺序
              multiResolution['showOrder'].push(configItem.id);
              multiResolution['labels'][configItem.id] = configItem.name;
              sources[configItem.id] = [];
            }
            // todo 检测视频能否可以在当前浏览器环境下播放，可以的才push到sources
            sources[configItem.id].push({
              'src': unifyProtocol(source.url),
              'type': self.getMIMEType(source.url)
            });
          } else {
            // 保留不在当前config item里的sources，用于下一次filter
            return true;
          }
        });
      }
    });
    multiResolution['sources'] = sources;
    // 需要注意transcodeList里的视频清晰度都没有在 videoClassification 中匹配到的情况，这时sources为空数组
    // 默认播放清晰度，需要接口返回，如果没有则默认取第一个
    multiResolution['defaultRes'] = result.playerInfo.defaultVideoClassification || Object.keys(sources)[0];
    // console.log('getMultiResolutionData', multiResolution);
    return multiResolution;
  };

  /**
   * 根据 definition 获取playcgi返回的视频url
   * @param videoInfo
   * @param definition
   * @returns {*}
   */


  MediaAsyncLoader.prototype.getSrcByDefinition = function getSrcByDefinition(videoInfo, definition) {
    var transcodeList = videoInfo['transcodeList'],
        sourceVideo = videoInfo['sourceVideo'];
    if (definition == 0) {
      return sourceVideo;
    }
    for (var i = 0; i < transcodeList.length; i++) {
      if (transcodeList[i].definition == definition) {
        return transcodeList[i];
      }
    }
  };

  /**
   * 根据url的文件扩展名，获取对应的mime type
   * @param url
   * @returns {string}
   */


  MediaAsyncLoader.prototype.getMIMEType = function getMIMEType$$1(url) {
    var mineType = EXT_MIME[getFileExtension(url)];
    if (mineType) {
      return mineType;
    } else {
      log$2.error('MIME type no found! Ext = ' + getFileExtension(url));
      return '';
    }
  };

  /**
   * 装配 playcgi 的请求链接
   * @param action
   * @param appID
   * @param fileID
   * @returns {string}
   */


  MediaAsyncLoader.prototype.assemblyPath = function assemblyPath(action, appID, fileID) {
    // Constant.SERVER_PATH
    var protocol = window_1.location.protocol;
    if (protocol != 'http:' && protocol != 'https:') {
      protocol = 'https:';
    }
    return '' + protocol + SERVER_PATH + '/' + action + '/v2/' + appID + '/' + fileID;
  };

  MediaAsyncLoader.prototype.assemblyPathV3 = function assemblyPathV3(action, appID, fileID, playDefinition) {
    // Constant.SERVER_PATH
    var protocol = window_1.location.protocol;
    if (protocol != 'http:' && protocol != 'https:') {
      protocol = 'https:';
    }
    // https://adapter.vod.myqcloud.com/getplayinfo/v3/1253039488/15517827183850370616/10
    // 播放参数模板 PlayDefinition，控制防盗链时间和允许展示的播放结果, 提供 ID 为 10，11，12，20 共 4 个预置播放模板。
    return '' + protocol + SERVER_PATH_V3 + '/' + action + '/v3/' + appID + '/' + fileID + '/' + playDefinition;
  };

  MediaAsyncLoader.prototype.assemblyPathV4 = function assemblyPathV4(action, appID, fileID) {
    // Constant.SERVER_PATH
    var protocol = window_1.location.protocol;
    if (protocol != 'http:' && protocol != 'https:') {
      protocol = 'https:';
    }
    // https://adapter.vod.myqcloud.com/getplayinfo/v4/1255566954/5285890790826532114
    return '' + protocol + SERVER_PATH_V4 + '/' + action + '/v4/' + appID + '/' + fileID;
  };
  /**
   * 自定义域名替换
   * @param videoInfo
   */


  MediaAsyncLoader.prototype.customHost = function customHost(videoInfo) {
    var player = this.player();
    if (player.options_['customHost'] && /^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$/.test(player.options_['customHost'])) {
      if (videoInfo['masterPlayList']) {
        videoInfo['masterPlayList']['url'] = replaceHost(videoInfo['masterPlayList']['url'], player.options_['customHost']);
      }
      if (videoInfo['sourceVideo']) {
        videoInfo['sourceVideo']['url'] = replaceHost(videoInfo['sourceVideo']['url'], player.options_['customHost']);
      }
      if (videoInfo['transcodeList'].length > 0) {
        videoInfo['transcodeList'].forEach(function (item, index) {
          item.url = replaceHost(item.url, player.options_['customHost']);
        });
      }
      player.trigger({ type: 'feature', data: 'customHost' });
    }
  };

  /**
   * 根据 fileID appID 切换视频进行播放，该方法可通过player实例直接调用，this作用域仍为MediaAsyncLoader
   * @param {Object} [args]
   *        appID 必须
   *        fileID 必须
   *        t: 加密链接超时时间戳，转换为16进制小写字符串，腾讯云 CDN 服务器会根据该时间判断该链接是否有效  防盗链有效期，建议不要比视频时长短
   *        us: 唯一标识请求，增加链接唯一性  建议尽量随机化
   *        exper: 试看时长，单位：秒，十进制数值。试看防盗链须带的参数，0表示不试看，即返回完整视频。mp4、ts 的试看时长不能大于原视频时长，否则出错
   *        sign:  签名字符串  对于普通防盗链和带试看功能防盗链
   *        playerID:  播放器ID
   */


  MediaAsyncLoader.prototype.loadVideoByID = function loadVideoByID(args) {
    var player = this.player();
    player.trigger({ type: 'loadnewvideo' });
    if (args.psign && Hls && Hls.isSupported() && !videojs.browser.IS_TBS && !videojs.browser.IS_MQQB && !videojs.browser.IS_SAFARI && !(videojs.browser.IE_VERSION && videojs.browser.IE_VERSION < 11)) {
      args.overlayKey = player.options_.playerOptions.overlayKey;
      args.overlayIv = player.options_.playerOptions.overlayIv;
    }
    player.hasStarted(false); // reset player start status
    this.getInfo(args);

    // reset task 以下为需要重置的配置
    player.duration(0);
    player.playbackRate(1);
    player.options_['appID'] = args['appID'];
    player.options_['fileID'] = args['fileID'];
    player.options_['psign'] = args['psign'];
    args['definition'] && (player.options_['definition'] = args['definition']);

    // 在multi-resolution plugin 触发切换清晰度时，会隐藏bigPlayButton
    player.bigPlayButton && player.bigPlayButton.show();

    if (player.options_['plugins']['ContinuePlay']) {
      player.ContinuePlay().init();
    }
  };

  /**
   * 播放列表playlist, 优先从用户配置参数获取
   * @param playerInfo
   */


  MediaAsyncLoader.prototype.setPlayList = function setPlayList(playerInfo) {
    var player = this.player();
    if (player.options_.plugins.PlayList) return;

    if (playerInfo.playlist && playerInfo.playlist.data instanceof Array && playerInfo.playlist.data.length > 0) {
      this.player_.PlayList(playerInfo.playlist);
    }
  };

  return MediaAsyncLoader;
}(Component);

Component.registerComponent('MediaAsyncLoader', MediaAsyncLoader);

/**
 * @file logo.js
 */

var Component$2 = videojs.getComponent('Component');
var ClickableComponent$2 = videojs.getComponent('ClickableComponent');
var positionMap = ['left-top', 'left-bottom', 'right-top', 'right-bottom'];

var LogoImage = function (_ClickableComponent) {
  inherits(LogoImage, _ClickableComponent);

  function LogoImage(player, options) {
    classCallCheck(this, LogoImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    player.on('logochange', videojs.bind(_this, function (event) {
      this.update(event.data);
    }));
    if (options.img) {
      _this.update(options);
    }
    return _this;
  }

  LogoImage.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-logo vjs-hidden'
    });
    var linkEl_ = videojs.dom.createEl('a', {
      className: 'tcp-logo-link',
      target: '_blank'
    });
    var imgEl_ = videojs.dom.createEl('img', {
      className: 'tcp-logo-img'
    });
    this.linkEl_ = linkEl_;
    this.imgEl_ = imgEl_;

    linkEl_.appendChild(imgEl_);
    el.appendChild(linkEl_);

    return el;
  };

  /**
   *
   * @param event
   * data:{
   *  img:{url:'', position:['left-top'|'left-bottom'|'right-top'|'right-bottom']}
   *  link:'' // url
   * }
   */


  LogoImage.prototype.update = function update(data) {
    var img = data.img,
        linkUrl = data.link;
    this.setImg(img);
    this.setHref(linkUrl);
    this.options_ = videojs.mergeOptions(this.options_, data);
    this.show();
  };

  /**
   * 设置logo图片， position允许值 0~3 or e.g.'left-top'
   * @param data
   */


  LogoImage.prototype.setImg = function setImg(data) {
    if (this.imgEl_) {
      this.imgEl_.src = data.url;
      var position = positionMap[data.position] || data.position || 'left-top';
      videojs.dom.addClass(this.el_, position);
    }
  };

  LogoImage.prototype.setHref = function setHref(url) {
    if (this.linkEl_ && url) {
      this.linkEl_.href = url;
    }
  };

  LogoImage.prototype.reset = function reset() {
    this.hide();
    this.imgEl_.removeAttribute('src');
    this.linkEl_.removeAttribute('href');
  };

  return LogoImage;
}(ClickableComponent$2);

videojs.registerComponent('LogoImage', LogoImage);

/**
 * @file continue-play-tips.js
 */

var Component$3 = videojs.getComponent('Component');
var Button$2 = videojs.getComponent('Button');

var ContinuePlayTips = function (_Component) {
  inherits(ContinuePlayTips, _Component);

  function ContinuePlayTips(player, options) {
    classCallCheck(this, ContinuePlayTips);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    console.log('init ContinuePlayTips', options);
    _this.init(options);
    return _this;
  }

  ContinuePlayTips.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-continue-play-tips'
    });

    return el;
  };

  ContinuePlayTips.prototype.close = function close() {
    this.hide();
  };

  /**
   * @param options
   */


  ContinuePlayTips.prototype.init = function init(options) {
    var close = this.addChild('closeButton', { controlText: 'Close' });
    this.on(close, 'close', this.close);
    this.addChild('ContinuePlayTipsContent', options);
    var continuePlayButton = this.addChild('ContinuePlayButton', options);
    this.on(continuePlayButton, ['tap', 'click'], this.close);

    this.setTimeout(function () {
      this.close();
    }, 3500);
  };

  return ContinuePlayTips;
}(Component$3);

videojs.registerComponent('ContinuePlayTips', ContinuePlayTips);

var ContinuePlayTipsContent = function (_Component2) {
  inherits(ContinuePlayTipsContent, _Component2);

  function ContinuePlayTipsContent(player, options) {
    classCallCheck(this, ContinuePlayTipsContent);
    return possibleConstructorReturn(this, _Component2.call(this, player, options));
  }

  ContinuePlayTipsContent.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('span', {
      className: 'tcp-continue-play-tips-content'
    });
    var textEl_ = videojs.dom.createEl('span', {
      className: 'tcp-text',
      textContent: this.localize(this.options_['text'] || 'Last time play at ')
    });
    var timeEl_ = videojs.dom.createEl('span', {
      className: 'tcp-time',
      textContent: videojs.formatTime(this.options_['time'])
    });
    this.textEl_ = textEl_;
    this.timeEl_ = timeEl_;
    el.appendChild(textEl_);
    el.appendChild(timeEl_);

    return el;
  };

  return ContinuePlayTipsContent;
}(Component$3);

videojs.registerComponent('ContinuePlayTipsContent', ContinuePlayTipsContent);

var ContinuePlayButton = function (_Button) {
  inherits(ContinuePlayButton, _Button);

  function ContinuePlayButton(player, options) {
    classCallCheck(this, ContinuePlayButton);
    return possibleConstructorReturn(this, _Button.call(this, player, options));
  }

  ContinuePlayButton.prototype.createEl = function createEl() {
    return _Button.prototype.createEl.call(this, 'button', {
      className: 'tcp-continue-play-buttom',
      textContent: this.localize(this.options_['btnText'] || 'Resume play')
    });
  };

  ContinuePlayButton.prototype.handleClick = function handleClick() {
    this.options_['resumeCallback'].call();
  };

  return ContinuePlayButton;
}(Button$2);

videojs.registerComponent('ContinuePlayButton', ContinuePlayButton);

/**
 * @file level-switch-tips.js
 */

var Component$4 = videojs.getComponent('Component');

var LevelSwitchTips = function (_Component) {
  inherits(LevelSwitchTips, _Component);

  function LevelSwitchTips(player, options) {
    classCallCheck(this, LevelSwitchTips);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.playing = false;

    _this.timeoutID = undefined;
    _this.levelSwitch = player.options_.plugins.ContextMenu.levelSwitch;

    _this.init();

    player.on('playing', videojs.bind(_this, function () {
      _this.playing = true;
    }));

    player.on('resolutionswitching', videojs.bind(_this, function (event) {
      if (_this.playing) {
        if (event.data.label) {
          _this.switchHandler(_this.createSwitching(event.data.label), 2000);
        } else {
          var qualityData = _this.player().QualitySwitcher().options.qualityData;
          if (qualityData) {
            var target = qualityData.video.filter(function (item) {
              return event.data.newQuality === item.id;
            })[0];
            _this.switchHandler(_this.createSwitching(target.label), 2000);
          }
        }
      }
    }));

    player.on('resolutionswitched', videojs.bind(_this, function () {
      if (_this.playing) {
        _this.switchHandler(_this.createSwitched(), 2000);
      }
    }));

    player.on('levelSwitchError', videojs.bind(_this, function () {
      _this.switchHandler(_this.createSwitchError(), 2000);
    }));
    return _this;
  }

  LevelSwitchTips.prototype.switchHandler = function switchHandler(text, time) {
    var _this2 = this;

    if (this.timeoutID) {
      clearTimeout(this.timeoutID);
    }
    this.textNode.innerText = text;
    this.show();
    this.timeoutID = setTimeout(function () {
      _this2.hide();
    }, time);
  };

  LevelSwitchTips.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-switch vjs-hidden'
    });
    this.textNode = videojs.dom.createEl('div', {
      innerText: ''
    });
    el.appendChild(this.textNode);
    return el;
  };

  LevelSwitchTips.prototype.init = function init() {
    var close = this.addChild('closeButton', { controlText: 'Close' });
    this.on(close, 'close', this.hide);
  };

  LevelSwitchTips.prototype.createSwitching = function createSwitching(level) {
    if (this.levelSwitch.switchingText) {
      return this.levelSwitch.switchingText + level;
    }
    return '正在为您切换至' + level;
  };

  LevelSwitchTips.prototype.createSwitched = function createSwitched() {
    if (this.levelSwitch.switchedText) {
      return this.levelSwitch.switchedText;
    }
    return '切换成功';
  };

  LevelSwitchTips.prototype.createSwitchError = function createSwitchError() {
    if (this.levelSwitch.switchErrorText) {
      return this.levelSwitch.switchErrorText;
    }
    return '切换失败';
  };

  LevelSwitchTips.prototype.show = function show() {
    _Component.prototype.show.call(this);
    this.popped = true;
  };

  LevelSwitchTips.prototype.hide = function hide() {
    _Component.prototype.hide.call(this);
    this.popped = false;
  };

  return LevelSwitchTips;
}(Component$4);

videojs.registerComponent('LevelSwitchTips', LevelSwitchTips);

/**
 * @file video-text-item.js
 */

var Component$7 = videojs.getComponent('Component');

var mapKey = {
  'fileID': 'file ID',
  'requestID': 'request ID',
  'mediaType': 'media type',
  'mimeType': 'mime type',
  'provider': 'provider',
  'resolution': 'resolution',
  'rate': 'rate',
  'frames': 'frames',
  'buffer': 'buffer',
  'connectionSpeed': 'connection speed',
  'info': 'info'
};

var VideoTextItem = function (_Component) {
  inherits(VideoTextItem, _Component);

  function VideoTextItem(player, options) {
    classCallCheck(this, VideoTextItem);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.display = false;
    _this.displayData = 'loading';
    return _this;
  }

  VideoTextItem.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-statistic-line vjs-hidden'
    });
    var title = videojs.dom.createEl('span', {
      className: 'tcp-statistic-title',
      innerText: mapKey[this.options_.key] + ':'
    });
    var data = videojs.dom.createEl('span', {
      className: 'tcp-statistic-data',
      innerText: this.options_.data
    });
    el.appendChild(title);
    el.appendChild(data);
    return el;
  };

  VideoTextItem.prototype.updateTextNode_ = function updateTextNode_() {
    var item = this.el_.lastChild;
    while (item.firstChild) {
      item.removeChild(item.firstChild);
    }
    if (this.displayData) {
      this.show();
    }
    this.textNode_ = document_1.createTextNode(this.displayData || '');
    item.appendChild(this.textNode_);
  };

  VideoTextItem.prototype.updateContent = function updateContent(data) {
    if (data === this.displayData) {
      return;
    }
    this.displayData = data;
    this.requestAnimationFrame(this.updateTextNode_);
  };

  VideoTextItem.prototype.isDisplay = function isDisplay() {
    return this.display;
  };

  VideoTextItem.prototype.show = function show() {
    _Component.prototype.show.call(this);
    this.display = true;
    this.popped = true;
  };

  VideoTextItem.prototype.hide = function hide() {
    _Component.prototype.hide.call(this);
    this.display = false;
    this.popped = false;
  };

  VideoTextItem.prototype.reset = function reset() {
    _Component.prototype.hide.call(this);
    this.display = false;
    this.displayData = '';
  };

  return VideoTextItem;
}(Component$7);

videojs.registerComponent('VideoTextItem', VideoTextItem);

var defaultConfig = {
  enableRecoverMediaError: true,
  recoverMediaErrorMaxRetry: 5,
  fragLoadingMaxRetry: 3
};

var Html5HlsJS = function () {
  /**
   * 引入hls.js实现h5播放hls的功能
   * 已实现的接口：
   * 播放hls
   * hlsConfig:{
   *  enableRecoverMediaError
   *  recoverMediaErrorMaxRetry
   * }
   * @extends
   */
  function Html5HlsJS(source, tech, options) {
    var _this = this;

    classCallCheck(this, Html5HlsJS);

    var hlsOptions = {};
    if (source.keySystems && source.keySystems['com.widevine.alpha'] && source.keySystems['com.widevine.alpha'].serverURL) {
      options.hlsConfig.widevineLicenseUrl = source.keySystems['com.widevine.alpha'].serverURL;
      options.hlsConfig.enableWorker = true;
      options.hlsConfig.emeEnabled = true;
      options.hlsConfig.startLevel = (options.hlsConfig.qualityLabelList || []).length - 1;
      hlsOptions = options.hlsConfig;
    } else {
      // 场景： 通过loadVideoByID、src、 plugin playList等方式切换视频
      // 协议相同就不会重新loadTech，而loadTech里面有关键的一步是把player option赋值给tech option，不更新tech option，里面的hlsconfig overlaykey等信息就是旧的，会解密失败
      hlsOptions = tech.player_.options_.hlsConfig || options.hlsConfig;
    }
    this.drmBackup = options.hlsConfig && options.hlsConfig.drmBackup;
    var createInstance = function createInstance() {
      var Hls = window.Hls;
      var hls = new Hls(videojs.mergeOptions(defaultConfig, hlsOptions));
      var video = tech.el();
      _this.Hls = Hls;
      _this.tech = tech;
      _this.hls = hls;
      _this.switchStatus = '';
      _this.manifests = [];
      _this.subtitlesLoadedCount = 0;
      _this.audioTrackLoadedCount = 0;
      _this.subtitles = [];
      _this.audioTracks = [];
      //处理异常
      // create separate error handlers for hlsjs and the video tag
      _this.hlsjsErrorHandler = _this.errorHandlerFactory();

      hls.on(Hls.Events.ERROR, _this.onError.bind(_this));
      hls.on(Hls.Events.MANIFEST_PARSED, videojs.bind(_this, _this.onMetaData));
      hls.on(Hls.Events.MANIFEST_LOADED, _this.loadSubtiles.bind(_this));
      hls.on(Hls.Events.MANIFEST_LOADED, _this.loadAudioTracks.bind(_this));
      hls.on(Hls.Events.LEVEL_LOADED, _this.onLevelLoaded.bind(_this));
      var player = _this.tech.player();
      // player 就绪后加载 vtt 字幕
      player.on('ready', _this.addHlsSubtitles.bind(_this));
      //监听所有hls.js 事件
      for (var eventName in Hls.Events) {
        hls.on(Hls.Events[eventName], videojs.bind(_this, _this.onEvent));
      }
      hls.attachMedia(video);

      console.log('source src, ', source.src);
      hls.loadSource(source.src);
    };

    if (!window.Hls) {
      loadScript(HLS_PATH, function () {
        createInstance();
      });
    } else {
      createInstance();
    }
  }

  Html5HlsJS.prototype.switchQuality = function switchQuality(data) {
    console.log('switchQuality', data, this.hls);
    if (data.id != this.hls.currentLevel) {
      this.switchStatus = 'switching';
      this.switchData = data;
      this.tech.trigger({ type: 'hlsresolutionswitching', data: this.switchData });
      this.hls.nextLevel = data.id;
    }
  };

  Html5HlsJS.prototype.dispose = function dispose() {
    console.log('Html5HlsJS dispose');
    this.hls.destroy();
  };

  Html5HlsJS.prototype.onSubtitleLoaded = function onSubtitleLoaded(event, data) {
    var _this2 = this;

    var player = this.tech.player();
    var idx = this.subtitlesLoadedCount;
    var subtitles = this.hls.subtitleTracks;
    var subtitle = this.subtitles[idx];
    subtitle.url = data.details.fragments[0].url;

    if (++this.subtitlesLoadedCount < subtitles.length) {
      console.log('\u52A0\u8F7D\u7B2C' + (this.subtitlesLoadedCount + 1) + '\u6761\u5B57\u5E55');
      this.hls.trigger(this.Hls.Events.SUBTITLE_TRACK_LOADING, { url: subtitles[this.subtitlesLoadedCount].url, id: subtitles[this.subtitlesLoadedCount].id });
    } else {
      // 字幕头文件解析完成后再次执行添加字幕方法，确保加载字幕时机
      player.ready(function () {
        _this2.addHlsSubtitles();
      });
    }
  };

  Html5HlsJS.prototype.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
    var _this3 = this;

    var player = this.tech.player();
    var idx = this.audioTrackLoadedCount;
    var audioTracks = this.hls.audioTracks;
    var audioTrack = this.audioTracks[idx];
    audioTrack.url = data.details.fragments[0].url;

    if (++this.audioTrackLoadedCount < audioTracks.length) {
      console.log('\u52A0\u8F7D\u7B2C' + (this.audioTrackLoadedCount + 1) + '\u6761\u97F3\u8F68');
      this.hls.trigger(this.Hls.Events.AUDIO_TRACK_LOADING, { url: audioTracks[this.audioTrackLoadedCount].url, id: audioTracks[this.audioTrackLoadedCount].id });
    } else {
      // 字幕头文件解析完成后再次执行添加字幕方法，确保加载字幕时机
      player.ready(function () {
        _this3.addAudioTracks();
      });
    }
  };

  Html5HlsJS.prototype.loadAudioTracks = function loadAudioTracks() {
    var _this4 = this;

    var audioTracks = this.hls.audioTracks;
    if (!audioTracks.length) {
      return;
    }

    audioTracks.forEach(function (item) {
      _this4.audioTracks.push({
        id: item.id,
        name: item.name,
        lang: item.lang,
        loaded: false,
        'default': item['default']
      });
    });

    var target = audioTracks[0];
    this.hls.trigger(this.Hls.Events.AUDIO_TRACK_LOADING, { url: target.url, id: target.id });
    this.hls.on(this.Hls.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded.bind(this));
  };
  /**
   * 默认加载所有 hls 自带的所有字幕
   */


  Html5HlsJS.prototype.loadSubtiles = function loadSubtiles() {
    var _this5 = this;

    var subtitles = this.hls.subtitleTracks;
    console.log('[hls subtitles]: ', this.hls);
    if (!subtitles.length) {
      console.info('[hls info]: 无字幕');
      return;
    }
    subtitles.forEach(function (item) {
      _this5.subtitles.push({
        name: item.name,
        lang: item.lang,
        loaded: false
      });
    });
    var target = subtitles[0];
    this.hls.on(this.Hls.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleLoaded.bind(this));
    this.hls.trigger(this.Hls.Events.SUBTITLE_TRACK_LOADING, { url: target.url, id: target.id });
  };

  Html5HlsJS.prototype.addAudioTracks = function addAudioTracks() {
    var _this6 = this;

    if (!this.audioTracks.length) {
      return;
    }
    if (this.audioTracks.some(function (item) {
      return !item.loaded;
    })) {
      this.audioTracks.forEach(function (item) {
        var audioTrack = _this6.tech.addAudioTrack({ id: item.id, src: item.url, kind: 'audio', srclang: item.lang, label: item.name, enabled: item['default'] }, true);
        audioTrack.addEventListener('load', function () {
          item.loaded = true;
          console.log('audio load', audioTrack);
        });
      });
    }
  };

  /**
   * 调用 addRemoteTextTrack 方法添加 vtt 字幕
   */


  Html5HlsJS.prototype.addHlsSubtitles = function addHlsSubtitles() {
    var _this7 = this;

    if (!this.subtitles.length) {
      return;
    }
    if (this.subtitles.some(function (item) {
      return !item.loaded;
    })) {
      this.subtitles.forEach(function (item) {
        var subtitle = _this7.tech.addRemoteTextTrack({ src: item.url, kind: 'subtitles', srclang: item.lang, label: item.name }, true);
        subtitle.addEventListener('load', function () {
          item.loaded = true;
          console.log('subtitle load', subtitle);
        });
      });
    }
  };
  /**
   * hls事件统一处理
   * @param event
   * @param data
   */


  Html5HlsJS.prototype.onEvent = function onEvent(event, data) {
    this.tech.trigger({ type: event, data: data });
    var player = this.tech.player();
    switch (event) {
      //m3u8列表加载成功后，保存列表信息，可进一步分析里面的数值，比如直播回看Dvr.js需要解析出直播流的开始时间和可时移时长
      case this.Hls.Events.MANIFEST_LOADED:
        this.manifests.push(data.networkDetails.response || data.networkDetails.responseText);
        // console.log(Hls.Events.MANIFEST_LOADED, this.manifests);
        break;
      case this.Hls.Events.LEVEL_SWITCHING:
        break;
      case this.Hls.Events.LEVEL_SWITCHED:
        if (this.switchStatus == 'switching') {
          this.switchStatus = 'switched';
          this.tech.trigger({ type: 'hlsresolutionswitched', data: this.switchData });
          this.switchData = null;
        }
        break;
      case this.Hls.Events.LEVEL_SWITCH_ERROR:
        player.trigger({ type: 'levelSwitchError' });
        break;
    }
  };

  Html5HlsJS.prototype.onMetaData = function onMetaData(event, data) {
    console.log('hlsjs onMetaData', event, data);
    var cleanTracklist = [];
    var _hls = this.hls;
    var self = this;
    //更新hls level 数据
    if (data.levels.length > 1) {
      var autoLevel = {
        id: -1,
        label: "auto",
        selected: -1 === _hls.manualLevel
      };
      cleanTracklist.push(autoLevel);
    } else {
      return;
    }

    data.levels.forEach(function (level, index) {
      var resolution = {};
      resolution.id = index;
      resolution.selected = index === _hls.manualLevel;
      resolution.label = self.getLevelLabel(level);
      //TODO 需要处理label自定义
      cleanTracklist.push(resolution);
    });

    var payload = {
      qualityData: { video: cleanTracklist },
      callbacks: { video: videojs.bind(this, this.switchQuality) }
    };
    // console.log('hlsjs onMetaData', payload);
    // 加载并解析master playlist后更新media playlist信息，并发出事件。
    // 为了避免hls解析快于插件初始化，导致插件不能正常触发时间，这里做延迟处理。
    this.tech.setTimeout(function () {
      //这里的this 为tech
      this.trigger({ type: 'masterplaylistchange', data: payload });
    }, 1);
    // this.tech.trigger({ type: 'qualitydataloaded', data: payload });
  };

  Html5HlsJS.prototype.getLevelLabel = function getLevelLabel(level) {
    if (level.height) return level.height + "p";else if (level.width) return Math.round(level.width * 9 / 16) + "p";else if (level.bitrate) return level.bitrate / 1000 + "kbps";else return 0;
  };

  Html5HlsJS.prototype.onLevelLoaded = function onLevelLoaded(event, data) {
    // console.log('hlsjs level loaded', event, data);
    this._duration = data.details.live ? Infinity : data.details.totalduration;
  };

  Html5HlsJS.prototype.onError = function onError(event, data) {
    console.log('hlsjs onError', event, data, this.tech);
    var player = this.tech.player();
    if (data.fatal) {
      switch (data.type) {
        case this.Hls.ErrorTypes.NETWORK_ERROR:
          // 出现网络错误，增加重试
          // 错误还是保持触发，为了让使用者不感知，立即取消，以避免显示在视频画面上
          // this.hls.startLoad();
          player.error({ code: 14, source: data });
          // player.error(null);
          break;
        case this.Hls.ErrorTypes.MEDIA_ERROR:
          if (this.hls.config.enableRecoverMediaError) {
            this.hlsjsErrorHandler(data);
          } else {
            player.error({ code: 15, source: data });
          }
          break;
        case this.Hls.ErrorTypes.MUX_ERROR:
          player.error({ code: 16, source: data });
          break;
        case this.Hls.ErrorTypes.OTHER_ERROR:
        default:
          player.error({ code: 17, source: data });
          if (this.drmBackup && data.type === 'keySystemError') {
            // 自动降级清除错误显示
            player.error(null);
          }
          break;
      }
    } else {
      switch (data.details) {
        case this.Hls.ErrorDetails.KEY_LOAD_ERROR:
          // player.error({code: 14, source: data});
          break;
      }
    }
  };

  Html5HlsJS.prototype.errorHandlerFactory = function errorHandlerFactory() {
    var hls = this.hls;
    var player = this.tech.player();

    var _recoverDecodingErrorDate = null;
    var _recoverAudioCodecErrorDate = null;
    var recoverRetry = 0;
    return function (data) {
      var now = Date.now();
      console.log('hls errorHandlerFactory', data);
      if (recoverRetry == hls.config.recoverMediaErrorMaxRetry) {
        player.error({ code: 15, source: data });
      } else {
        if (!_recoverDecodingErrorDate || now - _recoverDecodingErrorDate > 2000) {
          _recoverDecodingErrorDate = now;
          hls.recoverMediaError();
        } else if (!_recoverAudioCodecErrorDate || now - _recoverAudioCodecErrorDate > 2000) {
          // if another Media Error is raised 'quickly' after this first Media Error : first call hls.swapAudioCodec(), then call hls.recoverMediaError(). https://github.com/video-dev/hls.js/blob/master/docs/API.md#hlsswapaudiocodec
          _recoverAudioCodecErrorDate = now;
          hls.swapAudioCodec();
          hls.recoverMediaError();
        }
        recoverRetry++;
      }
    };
  };

  Html5HlsJS.prototype.duration = function duration() {
    return this._duration;
  };

  return Html5HlsJS;
}();

var hlsTypeRE = /^application\/(x-mpegURL|vnd\.apple\.mpegURL)$/i;
var hlsExtRE = /\.m3u8/i;

var HlsSourceHandler = {
  name: 'hlsSourceHandler',
  canHandleSource: function canHandleSource(source) {
    console.log('canHandleSource', source);
    // skip hls fairplay, need to use Safari resolve it.
    if (source.skipHlsJs || source.keySystems && source.keySystems['com.apple.fps.1_0']) {
      return '';
    } else if (hlsTypeRE.test(source.type) && hlsExtRE.test(source.src)) {
      return 'probably';
    } else if (hlsExtRE.test(source.src)) {
      return 'maybe';
    } else {
      return '';
    }
  },
  handleSource: function handleSource(source, tech, options) {
    if (tech.hlsProvider) {
      tech.hlsProvider.dispose();
      tech.hlsProvider = null;
    } else {
      // hls关闭自动加载后，需要手动加载资源
      if (options.hlsConfig && options.hlsConfig.autoStartLoad === false) {
        // console.log('hls bind', tech.player().hasStarted());
        tech.on('play', function () {
          // console.log('hls play', this.player().hasStarted());
          if (!this.player().hasStarted()) {
            this.hlsProvider.hls.startLoad();
          }
        });
      }
    }
    console.log('handleSource', source, tech, options);
    tech.hlsProvider = new Html5HlsJS(source, tech, options);
    return tech.hlsProvider;
  },
  canPlayType: function canPlayType(type) {
    if (hlsTypeRE.test(type)) {
      return 'probably';
    }
    return '';
  }
};

function mountHlsProvider(enforce) {
  if (videojs.browser.IS_IOS && videojs.browser.IS_MQQ) {
    // ios13手机QQ内置浏览器 支持了Mediasource sourceBuffer API 但无法用于视频播放。需特殊判断
    return false;
  }
  // Hls && Hls.isSupported() && 
  if (!videojs.browser.IS_SAFARI_NOT_SIMULATOR || videojs.browser.IS_MAC && videojs.browser.IS_SAFARI || !!enforce) {
    // Safari不能使用hls.js
    try {
      var html5Tech = videojs.getTech && videojs.getTech('Html5');
      if (html5Tech) {
        html5Tech.registerSourceHandler(HlsSourceHandler, 0);
      }
    } catch (e) {
      console.error('hls.js init failed');
    }
  } else {
    //没有引入hls.js 或者 MSE 不可用或者x5内核禁用
  }
}
TCPlayer.mountHlsProvider = mountHlsProvider;
mountHlsProvider();

function handlePlaybackMetadataLoaded(player, tech) {
  var mediaPlayer = player.dash.mediaPlayer;

  var dashAudioTracks = mediaPlayer.getTracksFor('audio');
  var videojsAudioTracks = player.audioTracks();

  function generateIdFromTrackIndex(index) {
    return 'dash-audio-' + index;
  }

  function findDashAudioTrack(subDashAudioTracks, videojsAudioTrack) {
    return subDashAudioTracks.find(function (_ref) {
      var index = _ref.index;
      return generateIdFromTrackIndex(index) === videojsAudioTrack.id;
    });
  }

  // Safari creates a single native `AudioTrack` (not `videojs.AudioTrack`) when loading. Clear all
  // automatically generated audio tracks so we can create them all ourself.
  if (videojsAudioTracks.length) {
    tech.clearTracks(['audio']);
  }

  var currentAudioTrack = mediaPlayer.getCurrentTrackFor('audio');

  dashAudioTracks.forEach(function (dashTrack) {
    var label = dashTrack.lang;

    if (dashTrack.roles && dashTrack.roles.length) {
      label += ' (' + dashTrack.roles.join(', ') + ')';
    }

    // Add the track to the player's audio track list.
    videojsAudioTracks.addTrack(new videojs.AudioTrack({
      enabled: dashTrack === currentAudioTrack,
      id: generateIdFromTrackIndex(dashTrack.index),
      kind: dashTrack.kind || 'main',
      label: label,
      language: dashTrack.lang
    }));
  });

  var audioTracksChangeHandler = function audioTracksChangeHandler() {
    for (var i = 0; i < videojsAudioTracks.length; i++) {
      var track = videojsAudioTracks[i];

      if (track.enabled) {
        // Find the audio track we just selected by the id
        var dashAudioTrack = findDashAudioTrack(dashAudioTracks, track);

        // Set is as the current track
        mediaPlayer.setCurrentTrack(dashAudioTrack);

        // Stop looping
        continue;
      }
    }
  };

  videojsAudioTracks.addEventListener('change', audioTracksChangeHandler);
  player.dash.mediaPlayer.on(window.dashjs.MediaPlayer.events.STREAM_TEARDOWN_COMPLETE, function () {
    videojsAudioTracks.removeEventListener('change', audioTracksChangeHandler);
  });
}

/*
 * Call `handlePlaybackMetadataLoaded` when `mediaPlayer` emits
 * `dashjs.MediaPlayer.events.PLAYBACK_METADATA_LOADED`.
 */
function setupAudioTracks(player, tech) {
  // When `dashjs` finishes loading metadata, create audio tracks for `video.js`.
  player.dash.mediaPlayer.on(window.dashjs.MediaPlayer.events.PLAYBACK_METADATA_LOADED, handlePlaybackMetadataLoaded.bind(null, player, tech));
}

function find(l, f) {
  for (var i = 0; i < l.length; i++) {
    if (f(l[i])) {
      return l[i];
    }
  }
}

/*
 * Attach text tracks from dash.js to videojs
 *
 * @param {videojs} player the videojs player instance
 * @param {array} tracks the tracks loaded by dash.js to attach to videojs
 *
 * @private
 */
function attachDashTextTracksToVideojs(player, tech, tracks) {
  var trackDictionary = [];

  // Add remote tracks
  var tracksAttached = tracks
  // Map input data to match HTMLTrackElement spec
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTrackElement
  .map(function (track) {
    return {
      dashTrack: track,
      trackConfig: {
        label: track.lang,
        language: track.lang,
        srclang: track.lang,
        kind: track.kind
      }
    };
  })

  // Add track to videojs track list
  .map(function (_ref) {
    var trackConfig = _ref.trackConfig,
        dashTrack = _ref.dashTrack;

    var remoteTextTrack = player.addRemoteTextTrack(trackConfig, false);

    trackDictionary.push({ textTrack: remoteTextTrack.track, dashTrack: dashTrack });

    // Don't add the cues becuase we're going to let dash handle it natively. This will ensure
    // that dash handle external time text files and fragmented text tracks.
    //
    // Example file with external time text files:
    // https://storage.googleapis.com/shaka-demo-assets/sintel-mp4-wvtt/dash.mpd

    return remoteTextTrack;
  });

  /*
   * Scan `videojs.textTracks()` to find one that is showing. Set the dash text track.
   */
  function updateActiveDashTextTrack() {
    var dashMediaPlayer = player.dash.mediaPlayer;
    var textTracks = player.textTracks();
    var activeTextTrackIndex = -1;

    // Iterate through the tracks and find the one marked as showing. If none are showing,
    // `activeTextTrackIndex` will be set to `-1`, disabling text tracks.

    var _loop = function _loop(i) {
      var textTrack = textTracks[i];

      if (textTrack.mode === 'showing') {
        // Find the dash track we want to use

        /* jshint loopfunc: true */
        var dictionaryLookupResult = find(trackDictionary, function (track) {
          return track.textTrack === textTrack;
        });
        /* jshint loopfunc: false */

        var dashTrackToActivate = dictionaryLookupResult ? dictionaryLookupResult.dashTrack : null;

        // If we found a track, get it's index.
        if (dashTrackToActivate) {
          activeTextTrackIndex = tracks.indexOf(dashTrackToActivate);
        }
      }
    };

    for (var i = 0; i < textTracks.length; i += 1) {
      _loop(i);
    }

    // If the text track has changed, then set it in dash
    if (activeTextTrackIndex !== dashMediaPlayer.getCurrentTextTrackIndex()) {
      dashMediaPlayer.setTextTrack(activeTextTrackIndex);
    }
  }

  // Update dash when videojs's selected text track changes.
  player.textTracks().on('change', updateActiveDashTextTrack);

  // Cleanup event listeners whenever we start loading a new source
  player.dash.mediaPlayer.on(window_1.dashjs.MediaPlayer.events.STREAM_TEARDOWN_COMPLETE, function () {
    player.textTracks().off('change', updateActiveDashTextTrack);
  });

  // Initialize the text track on our first run-through
  updateActiveDashTextTrack();

  return tracksAttached;
}

/*
 * Wait for dash to emit `TEXT_TRACKS_ADDED` and then attach the text tracks loaded by dash if
 * we're not using native text tracks.
 *
 * @param {videojs} player the videojs player instance
 * @private
 */
function setupTextTracks(player, tech, options) {
  // Clear VTTCue if it was shimmed by vttjs and let dash.js use TextTrackCue.
  // This is necessary because dash.js creates text tracks
  // using addTextTrack which is incompatible with vttjs.VTTCue in IE11
  if (window_1.VTTCue && !/\[native code\]/.test(window_1.VTTCue.toString())) {
    window_1.VTTCue = false;
  }

  // Store the tracks that we've added so we can remove them later.
  var dashTracksAttachedToVideoJs = [];

  // We're relying on the user to disable native captions. Show an error if they didn't do so.
  if (tech.featuresNativeTextTracks) {
    videojs.log.error('You must pass {html: {nativeCaptions: false}} in the videojs constructor ' + 'to use text tracks in videojs-contrib-dash');
    return;
  }

  var mediaPlayer = player.dash.mediaPlayer;

  // Clear the tracks that we added. We don't clear them all because someone else can add tracks.
  function clearDashTracks() {
    dashTracksAttachedToVideoJs.forEach(player.removeRemoteTextTrack.bind(player));

    dashTracksAttachedToVideoJs = [];
  }

  function handleTextTracksAdded(_ref2) {
    var index = _ref2.index,
        tracks = _ref2.tracks;

    // Stop listening for this event. We only want to hear it once.
    mediaPlayer.off(window_1.dashjs.MediaPlayer.events.TEXT_TRACKS_ADDED, handleTextTracksAdded);

    // Cleanup old tracks
    clearDashTracks();

    if (!tracks.length) {
      // Don't try to add text tracks if there aren't any
      return;
    }

    // Save the tracks so we can remove them later
    dashTracksAttachedToVideoJs = attachDashTextTracksToVideojs(player, tech, tracks, options);
  }

  // Attach dash text tracks whenever we dash emits `TEXT_TRACKS_ADDED`.
  mediaPlayer.on(window_1.dashjs.MediaPlayer.events.TEXT_TRACKS_ADDED, handleTextTracksAdded);

  // When the player can play, remove the initialization events. We might not have received
  // TEXT_TRACKS_ADDED` so we have to stop listening for it or we'll get errors when we load new
  // videos and are listening for the same event in multiple places, including cleaned up
  // mediaPlayers.
  mediaPlayer.on(window_1.dashjs.MediaPlayer.events.CAN_PLAY, function () {
    mediaPlayer.off(window_1.dashjs.MediaPlayer.events.TEXT_TRACKS_ADDED, handleTextTracksAdded);
  });
}

var Html5DashJS = function () {
  function Html5DashJS(source, tech, options) {
    var _this = this;

    classCallCheck(this, Html5DashJS);

    var createInstance = function createInstance() {
      var dashjs = window_1.dashjs;
      _this.dashjs = dashjs;
      // Get options from tech if not provided for backwards compatibility
      console.log('Html5DashJS', source, tech, options);
      options = options || tech.options_;

      _this.player = videojs(options.playerId);
      _this.player.dash = _this.player.dash || {};

      _this.tech_ = tech;
      _this.el_ = tech.el();
      _this.elParent_ = _this.el_.parentNode;
      _this.hasFiniteDuration_ = false;

      // Do nothing if the src is falsey
      if (!source.src) {
        return;
      }

      // While the manifest is loading and Dash.js has not finished initializing
      // we must defer events and functions calls with isReady_ and then `triggerReady`
      // again later once everything is setup
      tech.isReady_ = false;

      if (Html5DashJS.updateSourceData) {
        videojs.log.warn('updateSourceData has been deprecated.' + ' Please switch to using hook("updatesource", callback).');
        source = Html5DashJS.updateSourceData(source);
      }

      // call updatesource hooks
      Html5DashJS.hooks('updatesource').forEach(function (hook) {
        source = hook(source);
      });

      var manifestSource = source.src;

      _this.keySystemOptions_ = Html5DashJS.buildDashJSProtData(source.keySystemOptions || source.keySystems);

      _this.player.dash.mediaPlayer = dashjs.MediaPlayer().create();

      _this.mediaPlayer_ = _this.player.dash.mediaPlayer;

      // Log MedaPlayer messages through video.js
      if (Html5DashJS.useVideoJSDebug) {
        videojs.log.warn('useVideoJSDebug has been deprecated.' + ' Please switch to using hook("beforeinitialize", callback).');
        Html5DashJS.useVideoJSDebug(_this.mediaPlayer_);
      }

      if (Html5DashJS.beforeInitialize) {
        videojs.log.warn('beforeInitialize has been deprecated.' + ' Please switch to using hook("beforeinitialize", callback).');
        Html5DashJS.beforeInitialize(_this.player, _this.mediaPlayer_);
      }

      Html5DashJS.hooks('beforeinitialize').forEach(function (hook) {
        hook(_this.player, _this.mediaPlayer_);
      });

      // Must run controller before these two lines or else there is no
      // element to bind to.
      _this.mediaPlayer_.initialize();

      // Retrigger a dash.js-specific error event as a player error
      // See src/streaming/utils/ErrorHandler.js in dash.js code
      // Handled with error (playback is stopped):
      // - capabilityError
      // - downloadError
      // - manifestError
      // - mediaSourceError
      // - mediaKeySessionError
      // Not handled:
      // - timedTextError (video can still play)
      // - mediaKeyMessageError (only fires under 'might not work' circumstances)
      _this.retriggerError_ = function (event) {
        if (event.error === 'capability' && event.event === 'mediasource') {
          // No support for MSE
          _this.player.error({
            code: 4,
            message: 'The media cannot be played because it requires a feature ' + 'that your browser does not support.'
          });
        } else if (event.error === 'manifestError' && (
        // Manifest type not supported
        event.event.id === 'createParser' ||
        // Codec(s) not supported
        event.event.id === 'codec' ||
        // No streams available to stream
        event.event.id === 'nostreams' ||
        // Error creating Stream object
        event.event.id === 'nostreamscomposed' ||
        // syntax error parsing the manifest
        event.event.id === 'parse' ||
        // a stream has multiplexed audio+video
        event.event.id === 'multiplexedrep')) {
          // These errors have useful error messages, so we forward it on
          _this.player.error({ code: 4, message: event.event.message });
        } else if (event.error === 'mediasource') {
          // This error happens when dash.js fails to allocate a SourceBuffer
          // OR the underlying video element throws a `MediaError`.
          // If it's a buffer allocation fail, the message states which buffer
          // (audio/video/text) failed allocation.
          // If it's a `MediaError`, dash.js inspects the error object for
          // additional information to append to the error type.
          if (event.event.match('MEDIA_ERR_ABORTED')) {
            _this.player.error({ code: 1, message: event.event });
          } else if (event.event.match('MEDIA_ERR_NETWORK')) {
            _this.player.error({ code: 2, message: event.event });
          } else if (event.event.match('MEDIA_ERR_DECODE')) {
            _this.player.error({ code: 3, message: event.event });
          } else if (event.event.match('MEDIA_ERR_SRC_NOT_SUPPORTED')) {
            _this.player.error({ code: 4, message: event.event });
          } else if (event.event.match('MEDIA_ERR_ENCRYPTED')) {
            _this.player.error({ code: 5, message: event.event });
          } else if (event.event.match('UNKNOWN')) {
            // We shouldn't ever end up here, since this would mean a
            // `MediaError` thrown by the video element that doesn't comply
            // with the W3C spec. But, since we should handle the error,
            // throwing a MEDIA_ERR_SRC_NOT_SUPPORTED is probably the
            // most reasonable thing to do.
            _this.player.error({ code: 4, message: event.event });
          } else {
            // Buffer allocation error
            _this.player.error({ code: 4, message: event.event });
          }
        } else if (event.error === 'capability' && event.event === 'encryptedmedia') {
          // Browser doesn't support EME
          _this.player.error({
            code: 5,
            message: 'The media cannot be played because it requires encryption ' + 'features that your browser does not support.'
          });
        } else if (event.error === 'key_session') {
          // This block handles pretty much all errors thrown by the
          // encryption subsystem
          _this.player.error({
            code: 5,
            message: event.event
          });
        } else if (event.error === 'download') {
          _this.player.error({
            code: 2,
            message: 'The media playback was aborted because too many consecutive ' + 'download errors occurred.'
          });
        } else if (event.error === 'mssError') {
          _this.player.error({
            code: 3,
            message: event.event
          });
        } else {
          // ignore the error
          return;
        }

        // only reset the dash player in 10ms async, so that the rest of the
        // calling function finishes
        setTimeout(function () {
          _this.mediaPlayer_.reset();
        }, 10);
      };

      _this.mediaPlayer_.on(dashjs.MediaPlayer.events.ERROR, _this.retriggerError_);

      _this.getDuration_ = function (event) {
        var periods = event.data.Period_asArray;
        var oldHasFiniteDuration = _this.hasFiniteDuration_;

        if (event.data.mediaPresentationDuration || periods[periods.length - 1].duration) {
          _this.hasFiniteDuration_ = true;
        } else {
          // in case we run into a weird situation where we're VOD but then
          // switch to live
          _this.hasFiniteDuration_ = false;
        }

        if (_this.hasFiniteDuration_ !== oldHasFiniteDuration) {
          _this.player.trigger('durationchange');
        }
      };

      _this.mediaPlayer_.on(dashjs.MediaPlayer.events.MANIFEST_LOADED, _this.getDuration_);

      _this.mediaPlayer_.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, videojs.bind(_this, _this.onMetaData));

      _this.currentQuality = {
        video: '',
        audio: ''
      };
      // listen all event
      Object.keys(dashjs.MediaPlayer.events).forEach(function (key) {
        _this.mediaPlayer_.on(dashjs.MediaPlayer.events[key], videojs.bind(_this, _this.onEvent));
      });

      // Apply all dash options that are set

      if (options.dashConfig) {
        Object.keys(options.dashConfig).forEach(function (key) {
          var _mediaPlayer_;

          var dashOptionsKey = 'set' + key.charAt(0).toUpperCase() + key.slice(1);
          var value = options.dashConfig[key];

          if (_this.mediaPlayer_.hasOwnProperty(dashOptionsKey)) {
            // Providing a key without `set` prefix is now deprecated.
            videojs.log.warn('Using dash options in videojs-contrib-dash without the set prefix ' + ('has been deprecated. Change \'' + key + '\' to \'' + dashOptionsKey + '\''));

            // Set key so it will still work
            key = dashOptionsKey;
          }

          if (!_this.mediaPlayer_.hasOwnProperty(key)) {
            videojs.log.warn('Warning: dash configuration option unrecognized: ' + key);

            return;
          }

          // Guarantee `value` is an array
          if (!Array.isArray(value)) {
            value = [value];
          }

          (_mediaPlayer_ = _this.mediaPlayer_)[key].apply(_mediaPlayer_, value);
        });
      }

      _this.mediaPlayer_.attachView(_this.el_);

      // Dash.js autoplays by default, video.js will handle autoplay
      _this.mediaPlayer_.setAutoPlay(false);

      // Setup audio tracks
      setupAudioTracks.call(null, _this.player, tech);

      // Setup text tracks
      setupTextTracks.call(null, _this.player, tech, options);

      // Attach the source with any protection data
      // console.log('setProtectionData',this.keySystemOptions_);
      _this.mediaPlayer_.setProtectionData(_this.keySystemOptions_);
      _this.mediaPlayer_.attachSource(manifestSource);

      _this.tech_.triggerReady();
    };

    if (!window_1.dashjs) {
      loadScript(DASH_PATH, function () {
        createInstance();
      });
    } else {
      createInstance();
    }
  }

  /*
   * Iterate over the `keySystemOptions` array and convert each object into
   * the type of object Dash.js expects in the `protData` argument.
   *
   * Also rename 'licenseUrl' property in the options to an 'serverURL' property
   */


  Html5DashJS.buildDashJSProtData = function buildDashJSProtData(keySystemOptions) {
    var output = {};

    if (!keySystemOptions) {
      return null;
    }
    if (Array.isArray(keySystemOptions)) {
      for (var i = 0; i < keySystemOptions.length; i++) {
        var keySystem = keySystemOptions[i];
        var options = videojs.mergeOptions({}, keySystem.options);

        if (options.licenseUrl) {
          options.serverURL = options.licenseUrl;
          delete options.licenseUrl;
        }

        output[keySystem.name] = options;
      }
    } else {
      output = keySystemOptions;
    }
    return output;
  };

  Html5DashJS.prototype.dispose = function dispose() {
    var _this2 = this;

    if (this.mediaPlayer_) {
      this.mediaPlayer_.off(this.dashjs.MediaPlayer.events.ERROR, this.retriggerError_);
      this.mediaPlayer_.off(this.dashjs.MediaPlayer.events.MANIFEST_LOADED, this.getDuration_);
      Object.keys(this.dashjs.MediaPlayer.events).forEach(function (key) {
        _this2.mediaPlayer_.off(_this2.dashjs.MediaPlayer.events[key], videojs.bind(_this2, _this2.onEvent));
      });

      this.mediaPlayer_.reset();
    }

    if (this.player.dash) {
      delete this.player.dash;
    }
  };

  Html5DashJS.prototype.duration = function duration() {
    if (this.mediaPlayer_.isDynamic() && !this.hasFiniteDuration_) {
      return Infinity;
    }
    return this.mediaPlayer_.duration();
  };

  /**
   * Get a list of hooks for a specific lifecycle
   *
   * @param {string} type the lifecycle to get hooks from
   * @param {Function=|Function[]=} hook Optionally add a hook tothe lifecycle
   * @return {Array} an array of hooks or epty if none
   * @method hooks
   */


  Html5DashJS.hooks = function hooks(type, hook) {
    Html5DashJS.hooks_[type] = Html5DashJS.hooks_[type] || [];

    if (hook) {
      Html5DashJS.hooks_[type] = Html5DashJS.hooks_[type].concat(hook);
    }

    return Html5DashJS.hooks_[type];
  };

  /**
   * Add a function hook to a specific dash lifecycle
   *
   * @param {string} type the lifecycle to hook the function to
   * @param {Function|Function[]} hook the function or array of functions to attach
   * @method hook
   */


  Html5DashJS.hook = function hook(type, _hook) {
    Html5DashJS.hooks(type, _hook);
  };

  /**
   * Remove a hook from a specific dash lifecycle.
   *
   * @param {string} type the lifecycle that the function hooked to
   * @param {Function} hook The hooked function to remove
   * @return {boolean} True if the function was removed, false if not found
   * @method removeHook
   */


  Html5DashJS.removeHook = function removeHook(type, hook) {
    var index = Html5DashJS.hooks(type).indexOf(hook);

    if (index === -1) {
      return false;
    }

    Html5DashJS.hooks_[type] = Html5DashJS.hooks_[type].slice();
    Html5DashJS.hooks_[type].splice(index, 1);

    return true;
  };

  /**
   * 获取可切换的视频比特率列表
   * @param event
   */


  Html5DashJS.prototype.onMetaData = function onMetaData(event) {
    var _this3 = this;

    var _mediaPlayer = this.mediaPlayer_;
    var bitrateInfoList = _mediaPlayer.getBitrateInfoListFor('video');

    var setting = _mediaPlayer.getSettings();
    var autoSwitchBitrate = setting.streaming.abr.autoSwitchBitrate.video;
    var trackList = [];
    if (bitrateInfoList.length > 0) {
      trackList.push({
        id: -1,
        label: 'auto',
        selected: autoSwitchBitrate
      });
    } else {
      return;
    }

    bitrateInfoList.forEach(function (level, index) {
      trackList.push({
        id: index,
        label: _this3.getLevelLabel(level),
        selected: autoSwitchBitrate ? false : _this3.currentQuality['video'] === index
      });
    });

    var payload = {
      qualityData: { video: trackList },
      callbacks: { video: videojs.bind(this, this.switchQuality) }
    };
    this.tech_.setTimeout(function () {
      this.trigger({ type: 'masterplaylistchange', data: payload });
    }, 1);
  };

  Html5DashJS.prototype.switchQuality = function switchQuality(data) {
    // console.log('switchQuality', data, this);
    var _mediaPlayer = this.mediaPlayer_;
    if (data.id === -1) {
      // migrate from 2.9.3 to 3.1.3 http://cdn.dashjs.org/v3.1.3/jsdoc/module-MediaPlayer.html#updateSettings__anchor
      // _mediaPlayer.setAutoSwitchQualityFor(data.trackType, true);
      _mediaPlayer.updateSettings({ 'streaming': { 'abr': { 'autoSwitchBitrate': { 'video': true } } } });
    } else if (data.id != this.currentQuality[data.trackType]) {
      // _mediaPlayer.setAutoSwitchQualityFor(data.trackType, false);
      _mediaPlayer.updateSettings({ 'streaming': { 'abr': { 'autoSwitchBitrate': { 'video': false } } } });
      _mediaPlayer.setQualityFor(data.trackType, data.id);
    }
    // setAutoSwitchQualityFor('video')
    // getAutoSwitchQualityFor('video')
    // getQualityFor(type) Gets the current download quality for media type
    // setQualityFor(type, val) Sets the current quality for media type instead of letting the ABR Heuristics automatically selecting it. This value will be overwritten by the ABR rules unless setAutoSwitchQualityFor(type, false) is called.
  };

  Html5DashJS.prototype.getLevelLabel = function getLevelLabel(level) {
    if (level.height) return level.height + "p";else if (level.width) return Math.round(level.width * 9 / 16) + "p";else if (level.bitrate) return level.bitrate / 1000 + "kbps";else return 0;
  };

  Html5DashJS.prototype.onEvent = function onEvent(event) {
    // console.log('dashjs', event.type);
    this.tech_.trigger({ type: 'dash_' + event.type, data: event });

    switch (event.type) {
      case this.dashjs.MediaPlayer.events.QUALITY_CHANGE_REQUESTED:
        this.tech_.trigger({ type: 'dashqualityswitching', data: event });
        break;
      case this.dashjs.MediaPlayer.events.QUALITY_CHANGE_RENDERED:
        this.tech_.trigger({ type: 'dashqualityswitched', data: event });
        this.currentQuality[event.mediaType] = event.newQuality;
        break;
    }
  };

  return Html5DashJS;
}();

Html5DashJS.hooks_ = {};

var canHandleKeySystems = function canHandleKeySystems(source) {
  // copy the source
  source = JSON.parse(JSON.stringify(source));

  if (Html5DashJS.updateSourceData) {
    videojs.log.warn('updateSourceData has been deprecated.' + ' Please switch to using hook("updatesource", callback).');
    source = Html5DashJS.updateSourceData(source);
  }

  // call updatesource hooks
  Html5DashJS.hooks('updatesource').forEach(function (hook) {
    source = hook(source);
  });

  var videoEl = document_1.createElement('video');

  if (source.keySystemOptions && !(window_1.navigator.requestMediaKeySystemAccess ||
  // IE11 Win 8.1
  videoEl.msSetMediaKeys)) {
    return false;
  }

  return true;
};

videojs.DashSourceHandler = function () {
  return {
    name: 'dashSourceHandler',
    canHandleSource: function canHandleSource(source) {
      var dashExtRE = /\.mpd/i;

      if (!canHandleKeySystems(source)) {
        return '';
      }

      if (videojs.DashSourceHandler.canPlayType(source.type)) {
        return 'probably';
      } else if (dashExtRE.test(source.src)) {
        return 'maybe';
      }
      return '';
    },
    handleSource: function handleSource(source, tech, options) {
      return new Html5DashJS(source, tech, options);
    },
    canPlayType: function canPlayType(type) {
      return videojs.DashSourceHandler.canPlayType(type);
    }
  };
};

videojs.DashSourceHandler.canPlayType = function (type) {
  var dashTypeRE = /^application\/dash\+xml/i;

  if (dashTypeRE.test(type)) {
    return 'probably';
  }

  return '';
};

function mountDashProvider(enforce) {
  // Only add the SourceHandler if the browser supports MediaSourceExtensions
  if (window_1.MediaSource || !!enforce) {
    videojs.getTech('Html5').registerSourceHandler(videojs.DashSourceHandler(), 0);
  }
}
TCPlayer.mountDashProvider = mountDashProvider;
mountDashProvider();

videojs.Html5DashJS = Html5DashJS;

/**
 * @file video-statistic-wrapper.js
 */

var Component$6 = videojs.getComponent('Component');

var hlsOption = ['fileID', 'requestID', 'mediaType', 'mimeType', 'provider', 'resolution', 'rate', 'frames', 'buffer', 'connectionSpeed'];

var mp4Option = ['fileID', 'requestID', 'mediaType', 'mimeType', 'resolution', 'rate', 'buffer'];

var dashOption = ['fileID', 'requestID', 'mediaType', 'mimeType', 'resolution', 'rate', 'buffer', 'provider', 'connectionSpeed'];

var infoOption = ['info'];

var VideoStatisticWrapper = function (_Component) {
  inherits(VideoStatisticWrapper, _Component);

  function VideoStatisticWrapper(player, options) {
    classCallCheck(this, VideoStatisticWrapper);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.nodelist = {};

    _this.status = {
      fileID: '',
      requestID: '',
      mediaType: '',
      mimeType: '',
      provider: '',
      resolution: '',
      rate: '',
      frames: '',
      buffer: '',
      connectionSpeed: '',
      info: ''
    };

    player.on('playcgiend', function () {
      clearTimeout(_this.timeoutID);
      Object.keys(_this.status).forEach(function (key) {
        _this.nodelist[key].reset();
      });
    });

    player.on('statistic', videojs.bind(_this, function (event) {
      if (event.data.action === 'open') {
        _this.tick();
      } else {
        _this.clearTimeout(_this.timeoutID);
      }
    }));

    _this.init();
    return _this;
  }

  VideoStatisticWrapper.prototype.tick = function tick() {
    var _this2 = this;

    this.timeoutID = setTimeout(videojs.bind(this, function () {
      _this2.tick();
    }), 1000);
    this.updatePanel();
  };

  VideoStatisticWrapper.prototype.createEl = function createEl() {
    return videojs.dom.createEl('div', {
      className: 'tcp-statistic-wrapper'
    });
  };

  VideoStatisticWrapper.prototype.init = function init() {
    var _this3 = this;

    Object.keys(this.status).forEach(function (key) {
      var item = new VideoTextItem(_this3, {
        key: key,
        data: _this3.status[key]
      });
      _this3.nodelist[key] = item;
      _this3.addChild(item);
    });
  };

  VideoStatisticWrapper.prototype.updatePanel = function updatePanel() {
    var _this4 = this;

    if (this.player().techName_ === 'Html5') {
      this.getStatus();
      switch (this.status.mediaType) {
        case 'm3u8':
          hlsOption.forEach(function (key) {
            _this4.nodelist[key].updateContent(_this4.status[key]);
          });
          break;
        case 'mp4':
          mp4Option.forEach(function (key) {
            _this4.nodelist[key].updateContent(_this4.status[key]);
          });
          break;
        case 'mpd':
          dashOption.forEach(function (key) {
            _this4.nodelist[key].updateContent(_this4.status[key]);
          });
        default:
          break;
      }
    } else if (this.player().techName_ === 'Flash') {
      this.getFlashStatus();
      infoOption.forEach(function (key) {
        if (key === 'info') {
          _this4.nodelist[key].updateContent(_this4.status[key]);
        }
      });
    }
  };

  VideoStatisticWrapper.prototype.getStatus = function getStatus() {
    this.getFileID();
    this.getRequestID();
    this.getMediaType();
    this.getMIMEType();
    this.getResolution();
    this.getRate();
    this.getProvider();
    this.getBuffer();
    if (this.status.mediaType === 'm3u8') {
      this.getFrames();
      this.getConnectionSpeed();
    }
    if (this.status.mediaType === 'mpd') {
      this.getConnectionSpeed();
    }
  };

  VideoStatisticWrapper.prototype.getFlashStatus = function getFlashStatus() {
    this.status.mediaType = 'flash';
    this.getSupport();
  };

  VideoStatisticWrapper.prototype.getFileID = function getFileID() {
    var fileID = this.player().options_.fileID || '';
    this.status.fileID = fileID;
    return fileID;
  };

  VideoStatisticWrapper.prototype.getRequestID = function getRequestID() {
    var playStatus = this.player().PlayerMetrics().playStatus;
    if (playStatus) {
      var requestID = playStatus.requestID;
      this.status.requestID = requestID;
      return requestID;
    }
  };

  VideoStatisticWrapper.prototype.getMediaType = function getMediaType() {
    this.player_.src() && /\/(.+)\.(.+)\?|\/(.+)\.(.+)/.test(this.player_.src());
    var mediaType = RegExp.$2 || RegExp.$4 || '';
    this.status.mediaType = mediaType;
    return mediaType;
  };

  VideoStatisticWrapper.prototype.getMIMEType = function getMIMEType() {
    var url = this.player().src();
    var mimeType = EXT_MIME[getFileExtension(url)] || '';
    this.status.mimeType = mimeType;
    return mimeType;
  };

  VideoStatisticWrapper.prototype.getResolution = function getResolution() {
    var videoHeight = this.player_.tech_.el_.videoHeight || 0;
    var videoWidth = this.player_.tech_.el_.videoWidth || 0;
    var resolution = videoWidth + " x " + videoHeight;
    this.status.resolution = resolution;
    return resolution;
  };

  VideoStatisticWrapper.prototype.getRate = function getRate() {
    var rate = this.player().playbackRate() || 1;
    this.status.rate = rate + 'x';
    return rate;
  };

  VideoStatisticWrapper.prototype.getBuffer = function getBuffer() {
    var bufferedEnd = this.player_.bufferedEnd().toFixed(1) || 0;
    var duration = this.player_.duration().toFixed(1) || 0;
    var percent = (bufferedEnd / duration * 100).toFixed(1) + '%';
    var buffer = bufferedEnd + " / " + duration + " (" + percent + ")";
    this.status.buffer = buffer;
    return buffer;
  };

  VideoStatisticWrapper.prototype.getSupport = function getSupport() {
    var info = void 0;
    if (this.status.mediaType !== 'm3u8' && this.status.mediaType !== 'mp4' && this.status.mediaType !== 'dash') {
      info = '视频统计功能不支持当前视频格式';
    } else {
      info = '';
    }
    this.status.info = info;
    return info;
  };

  VideoStatisticWrapper.prototype.getProvider = function getProvider() {
    var provider = this.player_.tech_.sourceHandler_;
    if (provider instanceof Html5HlsJS) {
      this.status.provider = 'HlsJS';
      return 'HlsJS';
    } else if (provider instanceof Html5DashJS) {
      this.status.provider = 'DashJS';
      return 'DashJS';
    }
    return '';
  };

  VideoStatisticWrapper.prototype.getFrames = function getFrames() {
    var quality = this.player_.getVideoPlaybackQuality();
    var frames = (quality.droppedVideoFrames || 0) + " dropped of " + (quality.totalVideoFrames || 0);
    this.status.frames = frames;
    return frames;
  };

  VideoStatisticWrapper.prototype.getConnectionSpeed = function getConnectionSpeed() {
    var connectionSpeed = void 0;
    if (this.status.mediaType === 'm3u8') {
      var bwEstimator = this.player_.tech_.hlsProvider.hls.abrController._bwEstimator;
      if (bwEstimator && bwEstimator.getEstimate()) {
        connectionSpeed = (bwEstimator.getEstimate() * 0.000125).toFixed(0) + 'KB/s';
      } else {
        connectionSpeed = '0KB/s';
      }
      this.status.connectionSpeed = connectionSpeed;
    }
    if (this.status.mediaType === 'mpd') {
      var player = this.player_.dash.mediaPlayer;
      // https://github.com/Dash-Industry-Forum/dash.js/wiki/Migration-3.0
      var dashMetrics = player.getDashMetrics();
      var dashAdapter = player.getDashAdapter();
      // http://cdn.dashjs.org/v3.1.3/jsdoc/module-MediaPlayer.html#getActiveStream__anchor
      var streamInfo = player.getActiveStream().getStreamInfo(); // get active stream info
      var periodId = streamInfo.index;
      // http://cdn.dashjs.org/v3.1.3/jsdoc/module-DashMetrics.html#getCurrentRepresentationSwitch__anchor
      var representationId = dashMetrics.getCurrentRepresentationSwitch('video').to;
      // http://cdn.dashjs.org/v3.1.3/jsdoc/module-DashAdapter.html#getBandwidthForRepresentation__anchor
      // Returns the bandwidth for a given representation id
      var bandwidth = dashAdapter.getBandwidthForRepresentation(representationId, periodId);
      if (bandwidth) {
        connectionSpeed = (bandwidth * 0.000125).toFixed(0) + 'KB/s';
      } else {
        connectionSpeed = '0KB/s';
      }
      this.status.connectionSpeed = connectionSpeed;
    }
    return connectionSpeed;
  };

  return VideoStatisticWrapper;
}(Component$6);

videojs.registerComponent('VideoStatisticWrapper', VideoStatisticWrapper);

/**
 * @file video-statistic-panel.js
 */

var Component$5 = videojs.getComponent('Component');

var VideoStatisticPanel = function (_Component) {
  inherits(VideoStatisticPanel, _Component);

  function VideoStatisticPanel(player, options) {
    classCallCheck(this, VideoStatisticPanel);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    player.on('statistic', videojs.bind(_this, function (event) {
      if (event.data.action === 'open') {
        _this.show();
      } else {
        _this.hide();
      }
    }));

    player.on('playcgistart', function () {
      player.trigger({ type: 'statistic', data: {
          action: 'close'
        } });
    });

    _this.init();
    return _this;
  }

  VideoStatisticPanel.prototype.createEl = function createEl() {
    var _this2 = this;

    var el = videojs.dom.createEl('div', {
      className: 'tcp-statistic vjs-hidden'
    });
    var close = videojs.dom.createEl('div', {
      className: 'tcp-statistic-close',
      innerText: '[X]'
    });
    close.addEventListener('click', function () {
      _this2.hide();
      var player = _this2.player();
      player.trigger({ type: 'statistic', data: {
          action: 'close'
        } });
    });
    el.appendChild(close);
    return el;
  };

  VideoStatisticPanel.prototype.init = function init() {
    this.addChild('VideoStatisticWrapper');
  };

  VideoStatisticPanel.prototype.show = function show() {
    _Component.prototype.show.call(this);
    this.popped = true;
  };

  VideoStatisticPanel.prototype.hide = function hide() {
    _Component.prototype.hide.call(this);
    this.popped = false;
  };

  return VideoStatisticPanel;
}(Component$5);

videojs.registerComponent('VideoStatisticPanel', VideoStatisticPanel);

var MenuItem$3 = videojs.getComponent('MenuItem');

var MirrorMenuItem = function (_MenuItem) {
  inherits(MirrorMenuItem, _MenuItem);

  function MirrorMenuItem(player, options) {
    classCallCheck(this, MirrorMenuItem);

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.addClass('tc-menu-list');
    _this.open = false; // 默认未开启镜像
    _this.hasOpen = false; // 是否开启过镜像功能
    _this.player = player;
    _this.setup();
    return _this;
  }

  MirrorMenuItem.prototype.setup = function setup() {
    var _this2 = this;

    this.on(['tap', 'click'], function () {
      var tag = _this2.player.tech().el(); // 获取video元素

      if (!_this2.hasOpen) {
        // 统计镜像使用量
        window.MtaH5 && MtaH5.clickStat('mirror', {
          appid: _this2.player.options_['appID'],
          fileid: _this2.player.options_['fileID']
        });
        _this2.player.trigger({ type: 'feature', data: 'mirror' });
      }

      if (!_this2.open) {
        videojs.dom.addClass(tag, 'tcp-mirror');
        videojs.dom.addClass(_this2.el_, 'tcp-menu-item-select');
        _this2.hasOpen = true;
      } else {
        videojs.dom.removeClass(tag, 'tcp-mirror');
        videojs.dom.removeClass(_this2.el_, 'tcp-menu-item-select');
      }
      _this2.open = !_this2.open;
    });
  };

  return MirrorMenuItem;
}(MenuItem$3);

videojs.registerComponent('MirrorMenuItem', MirrorMenuItem);

var MenuItem$4 = videojs.getComponent('MenuItem');

var PoweredByMenuItem = function (_MenuItem) {
  inherits(PoweredByMenuItem, _MenuItem);

  function PoweredByMenuItem(player, options) {
    classCallCheck(this, PoweredByMenuItem);

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.addClass('tc-menu-list');
    return _this;
  }

  return PoweredByMenuItem;
}(MenuItem$4);

videojs.registerComponent('PoweredByMenuItem', PoweredByMenuItem);

var MenuItem$5 = videojs.getComponent('MenuItem');

var StatusMenuItem = function (_MenuItem) {
  inherits(StatusMenuItem, _MenuItem);

  function StatusMenuItem(player, options) {
    classCallCheck(this, StatusMenuItem);

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.addClass('tc-menu-list');

    _this.hasOpen = false; // 是否已经打开状态panel
    _this.player = player;

    player.on('statistic', videojs.bind(_this, function (event) {
      if (event.data.action === 'close') {
        videojs.dom.removeClass(_this.el_, 'tcp-menu-item-select');
        _this.hasOpen = false;
      }
    }));

    _this.setup();
    return _this;
  }

  StatusMenuItem.prototype.setup = function setup() {
    var _this2 = this;

    this.on(['tap', 'click'], function () {
      if (!_this2.hasOpen) {
        videojs.dom.addClass(_this2.el_, 'tcp-menu-item-select');
        _this2.player.trigger({ type: 'statistic', data: {
            action: 'open'
          } });
        _this2.hasOpen = true;
        window.MtaH5 && MtaH5.clickStat('mirror', {
          appid: _this2.player.options_['appID'],
          fileid: _this2.player.options_['fileID']
        });
        _this2.player.trigger({ type: 'feature', data: 'statistic' });
      } else {
        videojs.dom.removeClass(_this2.el_, 'tcp-menu-item-select');
        _this2.player.trigger({ type: 'statistic', data: {
            action: 'close'
          } });
        _this2.hasOpen = false;
      }
    });
  };

  return StatusMenuItem;
}(MenuItem$5);

videojs.registerComponent('StatusMenuItem', StatusMenuItem);

/**
 * @file right-click-popup-menu.js
 */

var Component$8 = videojs.getComponent('Component');
var Menu$2 = videojs.getComponent('Menu');
var MenuItem$2 = videojs.getComponent('MenuItem');
var RightClickPopupMenu = function (_Menu) {
  inherits(RightClickPopupMenu, _Menu);

  function RightClickPopupMenu(player, options) {
    classCallCheck(this, RightClickPopupMenu);

    var _this = possibleConstructorReturn(this, _Menu.call(this, player, options));

    _this.hide();
    _this.addChild('PoweredByMenuItem', {
      label: 'Powered by Tencent Cloud.'
    });

    if (options.statistic && !IS_IOS && !IS_ANDROID) {
      _this.addChild('StatusMenuItem', {
        label: 'Video statistic'
      });
    }

    if (options.mirror) {
      _this.addChild('MirrorMenuItem', {
        label: 'Mirror'
      });
    }

    player.on('contextmenu', videojs.bind(_this, _this.onContextmenu));
    player.on(['tap', 'click'], videojs.bind(_this, function (event) {
      if (this.popped) {
        this.hide();
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
    }));
    videojs.on(document, ['tap', 'click'], videojs.bind(_this, function (event) {
      if (this.popped) {
        this.hide();
      }
    }));
    var self = _this;
    _this.children().forEach(function (item) {
      item.on(['tap', 'click'], function () {
        self.hide();
      });
    });
    return _this;
  }

  RightClickPopupMenu.prototype.createEl = function createEl() {
    var el = _Menu.prototype.createEl.call(this);
    videojs.dom.addClass(el, 'tcp-right-click-popup-menu');
    return el;
  };

  RightClickPopupMenu.prototype.show = function show() {
    _Menu.prototype.show.call(this);
    this.popped = true;
  };

  RightClickPopupMenu.prototype.hide = function hide() {
    _Menu.prototype.hide.call(this);
    this.popped = false;
  };

  RightClickPopupMenu.prototype.onContextmenu = function onContextmenu(event) {
    console.log('on contextmenu', event);
    event.preventDefault();
    this.show();

    var el = this.el(),
        x = event.clientX,
        y = event.clientY,
        maxSize = getViewportSize();
    var max_right = maxSize.width;
    var max_bottom = maxSize.height;
    var left_shift = x + el.offsetWidth - max_right + 5;
    left_shift = Math.max(0, left_shift);
    var top_shift = y + el.offsetHeight - max_bottom + 5;
    top_shift = Math.max(0, top_shift);
    var rect = this.player().el().getBoundingClientRect();
    el.style.left = Math.max(0, x - rect.left - left_shift) + 'px';
    el.style.top = Math.max(0, y - rect.top - top_shift) + 'px';
  };

  return RightClickPopupMenu;
}(Menu$2);

videojs.registerComponent('RightClickPopupMenu', RightClickPopupMenu);

var clickableComponent = videojs.getComponent('ClickableComponent');
var TimeTooltip$2 = videojs.getComponent('TimeTooltip');
var Component$9 = videojs.getComponent('Component');
var dom = videojs.dom;
var formatTime$2 = videojs.formatTime;

var COMMENT_WIDTH = 140;
var COMMENT_HEIGHT_SINGLE_LINE = 23;
var COMMENT_SHOW_ON_THE_LEFT = {
  POPUP_CONTAINER_OFFSET: -130,
  POPUP_CONTAINER_OFFSET_WITHOUTGIT: -100,
  TRIANGLE_OFFEST: 96,
  TRIANGLE_OFFEST_WITHOUTGIF: 95
};
var COMMENT_SHOW_ON_THE_RIGHT = {
  TRIANGLE_OFFEST: 6,
  POPUP_CONTAINER_OFFSET: 0
};

var ProgressMarkerGenerator = function (_clickableComponent) {
  inherits(ProgressMarkerGenerator, _clickableComponent);

  function ProgressMarkerGenerator(player, options) {
    classCallCheck(this, ProgressMarkerGenerator);

    var _this = possibleConstructorReturn(this, _clickableComponent.call(this, player, options));

    _this.duration = 0;
    _this.registerListener();
    return _this;
  }

  ProgressMarkerGenerator.prototype.registerListener = function registerListener() {
    this.player_.one('canplay', videojs.bind(this, this.resetDotsElement));
  };

  ProgressMarkerGenerator.prototype.resetDotsElement = function resetDotsElement() {
    // console.log('resetDotsElement');
    var player_ = this.player_;
    this.duration = player_.duration();

    //将所有的点清空在我们重置点之前
    dom.emptyEl(this.el_);

    //开始重置点
    this.resetEl();
  };

  ProgressMarkerGenerator.prototype.resetEl = function resetEl() {
    // console.log('resetEl');
    this.setUpEl();
  };

  //鼠标离开点时触发此函数


  ProgressMarkerGenerator.prototype.dotMouseLeave = function dotMouseLeave() {
    // console.log(' dot mouse leave');
    var dot = event.currentTarget;
    var containerID = dot.getAttribute('container-id');
    var popUpContainer = this.getChildById(containerID);
    popUpContainer.hide();
  };

  //鼠标触碰到点时触发此函数


  ProgressMarkerGenerator.prototype.dotHover = function dotHover() {
    // console.log('dot hover');
    //对溢出进行判别，判断当前显示位置是否会溢出边界
    var playerWidth = event.currentTarget.parentElement.offsetWidth,
        showingCommentWidth = event.currentTarget.offsetLeft + COMMENT_WIDTH,
        popUpContainer = this.getChildById(event.currentTarget.getAttribute('container-id')),
        isWithoutGIF = popUpContainer.getAttribute('class').search('tcp-without-gif') >= 0 ? true : false,
        triangle = popUpContainer.el_.querySelector('.tcp-triangle-both') || popUpContainer.el_.querySelector('.tcp-triangle');

    if (showingCommentWidth > playerWidth) {
      //右边边界溢出判断
      //文字模式下
      if (isWithoutGIF) {
        popUpContainer.el_.style.left = COMMENT_SHOW_ON_THE_LEFT.POPUP_CONTAINER_OFFSET_WITHOUTGIT + "px";
        triangle.style.left = COMMENT_SHOW_ON_THE_LEFT.TRIANGLE_OFFEST_WITHOUTGIF + "%";
      } else {
        //有图片模式下（图文或者纯图）
        popUpContainer.el_.style.left = COMMENT_SHOW_ON_THE_LEFT.POPUP_CONTAINER_OFFSET + "px";
        triangle.style.left = COMMENT_SHOW_ON_THE_LEFT.TRIANGLE_OFFEST + "%";
      }
    } else if (event.currentTarget.offsetLeft <= COMMENT_WIDTH && !isWithoutGIF) {
      //左边边界溢出判断
      popUpContainer.el_.style.left = COMMENT_SHOW_ON_THE_RIGHT.POPUP_CONTAINER_OFFSET + "px";
      triangle.style.left = COMMENT_SHOW_ON_THE_RIGHT.TRIANGLE_OFFEST + "px";
    }

    //如果在图片模式下，配上当前时间显示
    var dotImage = popUpContainer.getChild('DotImage');
    if (dotImage) {
      var timestampElement = dotImage.el_.getElementsByClassName('tcp-dot-timestamp')[0];
      var dotInsecond = event.currentTarget.getAttribute('dotinsecond');
      ///配置图片上的时间点
      var time = formatTime$2(dotInsecond);
      timestampElement.innerHTML = time;
    }

    popUpContainer.show();
  };

  //根据不同模式设置子元素


  ProgressMarkerGenerator.prototype.setChildInTheContainer = function setChildInTheContainer(item, popUpContainer) {
    //对编码的数据解编码
    var comment = item.content && item.content !== "" ? decodeURIComponent(item.content.replace(/\+/g, " ")) : "";
    if (comment !== "") {
      var dotComment = popUpContainer.addChild('DotComment');
      dotComment.el_.innerHTML = encodeHTML(comment);
    }
    if (item.img) {
      //有文字和图片 或 有图片模式下 默认情况下三角形位于中间
      var triangle = popUpContainer.el_.querySelector('.tcp-triangle');
      triangle.setAttribute('class', 'tcp-triangle-both');
      var dotImage = popUpContainer.addChild('DotImage');
      dotImage.el_.firstChild.setAttribute('src', item.img);
      if (comment == "") {
        ///只有图模式
        popUpContainer.addClass("tcp-only-gif");
        dotImage.el_.firstChild.className = 'tcp-image-in-container-only-image';
      } else {
        ///有图有字模式
        var contentSize = this.countContentSize(comment); //通过字数来确定comment内容框的高度
        if (contentSize <= 20) {
          ///一行 一个中文字占两个长度, 有图有字模式下的容器宽度为140px，可放10个字
          popUpContainer.addClass('tcp-single-line');
          dotComment.el_.style.height = COMMENT_HEIGHT_SINGLE_LINE + 'px';
        }
      }
    } else if (comment !== "") {
      //仅显示文字内容模式
      var _contentSize = this.countContentSize(comment); //通过字数来确定comment内容框的高度
      if (_contentSize <= 14) {
        //一行 一个中文字占两个长度
        popUpContainer.addClass('tcp-single-line');
      } else if (_contentSize <= 28) {
        ///两行
        popUpContainer.addClass('tcp-two-lines');
      }
      popUpContainer.addClass('tcp-without-gif');
      dotComment.addClass('tcp-large-comment');
    }
  };

  ProgressMarkerGenerator.prototype.markSetUp = function markSetUp(item) {
    var timeOffset = item.timeOffset > 0 ? item.timeOffset / 1000 : 0; //点偏移时间
    var duration = this.duration ? this.duration : 0; //视频总时长

    //用户配置的时间点超出了视频的最大长度以及输入非法字符，将不建立元素
    if (typeof timeOffset !== 'number' || timeOffset > duration) {
      return;
    }

    //建立标记点
    var dot = document.createElement('div');
    dot.className = "tcp-dot-basic-style";
    dot.setAttribute("dotinsecond", timeOffset.toString()); //配上时间点

    //用户自定义标记点样式
    if (item['class']) {
      dot.className += " " + item['class'];
    }

    //标记提示信息的容器
    var popUpContainer = this.addChild('PopUpContainer');
    dot.setAttribute('container-id', popUpContainer.id_);

    //根据不同模式设置子元素
    this.setChildInTheContainer(item, popUpContainer);

    dot.appendChild(popUpContainer.el_);
    dot.style.left = timeOffset / duration * 100 + "%";

    //添加dot事件，用来检测鼠标是否在点位置，如果在，就触发comment的显示
    dot.addEventListener('mouseover', videojs.bind(this, this.dotHover));
    dot.addEventListener('mouseleave', videojs.bind(this, this.dotMouseLeave));

    return dot;
  };

  ProgressMarkerGenerator.prototype.setUpEl = function setUpEl() {
    var _this2 = this;

    // console.log(this.player_.dots);
    var dotsSetting = this.player_.options_.dots || 0;

    var el = this.el_ || _clickableComponent.prototype.createEl.call(this);
    videojs.dom.addClass(el, 'tcp-dot-component');

    //将playcgi上的点以及用户自定义的点统统建立起来
    if (dotsSetting && dotsSetting instanceof Array && dotsSetting.length > 0) {
      dotsSetting.forEach(function (item) {
        //每个item为每个标记点对象

        var comment = item.content || "";

        // item.content = ""; //这条语句用来开启有无文字模式。//测试无字有图片情况
        //测试所需 图片目前后台没有，因此自己Hard code 进行测试
        // item.img = "http://testgif.com/test.gif" //这条语句用来开启有gif图片模式。

        //图片和comment都没有，不打点返回
        if (!(comment && comment != "") && !item.img) {
          return;
        }

        //调用打点函数
        var dot = _this2.markSetUp(item);
        if (dot) {
          el.appendChild(dot);
        }
      });
    }

    return el;
  };

  //获取的tip里文字信息长度


  ProgressMarkerGenerator.prototype.countContentSize = function countContentSize(str) {
    var realLength = 0,
        len = str.length,
        charCode = -1;
    for (var i = 0; i < len; i++) {
      charCode = str.charCodeAt(i);
      if (charCode >= 0 && charCode <= 128) realLength += 1;else realLength += 2;
    }
    return realLength;
  };

  //create dom element based on the number of needed dots.
  ProgressMarkerGenerator.prototype.createEl = function createEl() {
    return this.setUpEl();
  };

  return ProgressMarkerGenerator;
}(clickableComponent);

videojs.registerComponent('ProgressMarkerGenerator', ProgressMarkerGenerator);

/**
 * 标记信息组件
 * @extends TimeTooltip
 */

var DotComment = function (_Component) {
  inherits(DotComment, _Component);

  function DotComment(player, options) {
    classCallCheck(this, DotComment);

    var _this3 = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this3.addClass('tcp-dot-comment');
    return _this3;
  }

  return DotComment;
}(Component$9);

videojs.registerComponent('DotComment', DotComment);

/**
 *
 * 标记上的图片组件
 * @extends Component
 */

var DotImage = function (_Component2) {
  inherits(DotImage, _Component2);

  function DotImage(player, options) {
    classCallCheck(this, DotImage);

    var _this4 = possibleConstructorReturn(this, _Component2.call(this, player, options));

    _this4.addClass('tcp-dot-image');
    // this.hide(); //默认隐藏
    var el = _this4.el_ || _Component2.prototype.createEl.call(_this4);
    var image = dom.createEl('img');
    image.className = 'tcp-image-in-container';
    el.appendChild(image);

    //image内有一个时间span
    var span = dom.createEl('span');
    span.className = "tcp-dot-timestamp";
    span.innerHTML = "";
    el.appendChild(span);
    return _this4;
  }

  return DotImage;
}(Component$9);

videojs.registerComponent('DotImage', DotImage);

/**
 *
 * 标记提示组件
 * @extends TimeTooltip
 */

var PopUpContainer = function (_TimeTooltip) {
  inherits(PopUpContainer, _TimeTooltip);

  function PopUpContainer(player, options) {
    classCallCheck(this, PopUpContainer);

    var _this5 = possibleConstructorReturn(this, _TimeTooltip.call(this, player, options));

    _this5.addClass('tcp-popup-container');

    //popUpContainer下面的倒三角
    var triangle = dom.createEl('div');
    triangle.setAttribute('class', 'tcp-triangle');
    _this5.el_.appendChild(triangle);
    _this5.hide(); //默认隐藏
    return _this5;
  }

  return PopUpContainer;
}(TimeTooltip$2);

videojs.registerComponent('PopUpContainer', PopUpContainer);

/**
 * @file dot-builder.js
 */

var Plugin$2 = videojs.getPlugin('plugin');

var SpeedUp = function (_Plugin) {
  inherits(SpeedUp, _Plugin);

  function SpeedUp(player) {
    classCallCheck(this, SpeedUp);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.TARGET_LANTENCY = 1; // 目标阈值，缓冲区时间低于此阈值，则不再追帧
    _this.MAX_LATENCY = 3;
    _this.RATEVALUE = 1.1;
    player.ready(videojs.bind(_this, _this.init));
    return _this;
  }

  SpeedUp.prototype.checkLatency = function checkLatency() {
    var latency = this.player.bufferedEnd() - this.player.currentTime();
    console.log('latency', latency, this.MAX_LATENCY);
    if (latency > this.MAX_LATENCY) {
      console.log('开始追帧');
      this.player.playbackRate(this.RATEVALUE);
    }

    if (latency < this.TARGET_LANTENCY) {
      console.log('结束追帧');
      this.player.playbackRate(1);
    }
  };

  SpeedUp.prototype.init = function init() {
    var _this2 = this;

    var player = this.player;
    var timer = void 0;

    player.on('playing', function () {
      console.log('playing');
      if (player.duration() === Infinity) {
        timer = setInterval(_this2.checkLatency.bind(_this2), 1000);
      }
    });
    player.on('waiting', function () {
      _this2.reset(timer);
    });
    player.on('pause', function () {
      _this2.reset(timer);
    });
  };

  SpeedUp.prototype.reset = function reset(timer) {
    this.player.playbackRate(1);
    clearInterval(timer);
  };

  return SpeedUp;
}(Plugin$2);

videojs.registerPlugin('SpeedUp', SpeedUp);

function getTemplate() {
  var _shapeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var _styleType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fill';

  var shapeType = _shapeType;
  var styleType = 'draw-' + _styleType; // fill, line, lines, dash
  var svgList = ['<svg height="100%" width="100%" viewBox="0 0 484 348">\n      <path class="' + styleType + '" transform="translate(4 4)" d="M383,124C350-42,122.3-40.5,90.6,123.5c-110.4,18.5-131,185,.6,216.5H381.6C519.7,310.7,494.1,137.8,383,124Z"/>\n      <path transform="translate(4 4)" d="M200.4,110.2c-9.4-5.8-19.6,2.7-19.4,11.7V256.2c0,8,10.4,16.7,19.4,10.8,2.2-1.4,111.8-65.9,114-67.3,7.4-4,10.1-15.8,0-22.2Z" style="fill:#fff ;"/>\n    </svg>', '<svg height="100%" width="100%" viewBox="0 0 476 340">\n      <path class="' + styleType + '" d="M383,124C350-42,122.3-40.5,90.6,123.5c-110.4,18.5-131,185,.6,216.5H381.6C519.7,310.7,494.1,137.8,383,124Z"/>\n      <path d="M200.4,110.2c-9.4-5.8-19.6,2.7-19.4,11.7V256.2c0,8,10.4,16.7,19.4,10.8,2.2-1.4,111.8-65.9,114-67.3,7.4-4,10.1-15.8,0-22.2Z" style="fill:#fff ;"/>\n    </svg>', '<svg height="100%" width="100%" viewBox="0 14 96 68">\n      <path class="' + styleType + '" d="M96,44.3v7.3c-0.1,7.7-1,15.5-1,15.5s-0.9,6.6-3.8,9.5c-3.6,3.8-7.7,3.8-9.6,4c-13.4,1-33.5,0.9-33.5,0.9 c-0.8,0-25-0.2-32.5-0.9c-2.1-0.4-6.9-0.3-10.6-4.1c-2.9-2.9-3.8-9.5-3.8-9.5s-1-7.7-1.1-15.5v-7.3c0.2-7.8,1.1-15.5,1.1-15.5 s0.9-6.6,3.8-9.5c3.6-3.8,7.7-3.8,9.6-4.1c13.4-1,33.5-0.9,33.5-0.9s20.1-0.1,33.5,0.9c1.9,0.2,5.9,0.2,9.6,4.1 c2.9,2.9,3.8,9.5,3.8,9.5S95.9,36.6,96,44.3z M38.3,61.4L64,47.9L38.3,34.4V61.4z"/>\n      <polygon points="64,47.9 38.3,61.4 38.3,34.4" fill="#fff"/>\n    </svg>'];
  return svgList[shapeType];
}

var Button$3 = videojs.getComponent('Button');
var BigPlayButton$2 = videojs.getComponent('BigPlayButton');
BigPlayButton$2.prototype.createEl = function () {
  var el = Button$3.prototype.createEl.call(this);
  var _html = getTemplate();
  if (this.options_.shapeType || this.options_.styleType) {
    _html = getTemplate(this.options_.shapeType, this.options_.styleType);
  }
  el.appendChild(videojs.dom.createEl('div', {
    className: 'vjs-button-icon',
    innerHTML: _html
  }));
  return el;
};

BigPlayButton$2.prototype.controlText_ = 'Play';
/**
 * 修改已有component 的原型方法，不需要register
 */

var Component$10 = videojs.getComponent('Component');
var VideoStatisticWrapper$1 = videojs.getComponent('VideoStatisticWrapper');

var LoadingSpinner$2 = videojs.getComponent('LoadingSpinner');
LoadingSpinner$2.prototype.createEl = function () {
  var _this = this;

  var el = Component$10.prototype.createEl.call(this, 'div', {
    className: 'tcp-loading-spinner',
    dir: 'ltr'
  });

  if (!this.player_.options_.loadingSpeed) {
    return el;
  }

  var speedTextTimer = null;
  function updateSpeed(player, el) {
    var statistics = new VideoStatisticWrapper$1(player);
    statistics.getMediaType();
    if ((statistics.getBuffer() || '').indexOf('100.0%') > -1) {
      el.innerText = '';
      return false;
    }

    el.innerText = statistics.getConnectionSpeed();
  }

  this.player_.on('waiting', function () {
    speedTextTimer = setInterval(function () {
      updateSpeed(_this.player_, el);
    }, 100);
  });

  this.player_.on('timeupdate', function () {
    if (speedTextTimer) {
      clearInterval(speedTextTimer);
    }
  });

  return el;
};

var Plugin$3 = videojs.getPlugin('plugin');
var log$3 = videojs.log;
// const log = console.log;

var Skin = function (_Plugin) {
  inherits(Skin, _Plugin);

  function Skin(player, options) {
    classCallCheck(this, Skin);

    log$3('Skin initializing');

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.player.addClass('tcp-skin');
    log$3('Skin initialized');
    return _this;
  }

  return Skin;
}(Plugin$3);

videojs.registerPlugin('Skin', Skin);

var Plugin$4 = videojs.getPlugin('plugin');
var log$4 = videojs.log;
// const log = console.log;

var VID = function (_Plugin) {
  inherits(VID, _Plugin);

  /**
   * 该插件不会改变player 原型上的配置属性
   * 用于支持传入fileid appid的sources，使用 mediaAsyncLoader 替换原有的 medialoader，在mediaAsyncLoader中异步获取视频地址等信息。
   * 支持
   * {@link async-loader.js}
   *　
   *
   */
  function VID(player, options) {
    classCallCheck(this, VID);

    log$4('VID initializing');

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.init(_this.player.options_);
    log$4('VID initialized');
    return _this;
  }

  VID.prototype.init = function init(playerOptions) {
    var player = this.player;
    var sources = playerOptions.sources;
    if (playerOptions && playerOptions.appID && playerOptions.fileID || playerOptions.plugins.DRM && sources.length == 0) {
      // switch to async loader
      playerOptions.children.splice(0, playerOptions.children[0] == 'mediaLoader' ? 1 : 0, 'mediaAsyncLoader');
      // playerOptions.children[0] = 'MediaAsyncLoader';
    } else {
      // if (sources.length > 0 || playerOptions.multiResolution && playerOptions.multiResolution.sources) {
      //   // url mode
      //   if (playerOptions.children[0] != 'mediaLoader') {
      //     playerOptions.children.unshift('mediaLoader');
      //   }
      //   // playerOptions.children[0] = 'MediaLoader';
      // } else {
      //   log('no video fileID or source');
      //   if (playerOptions.children[0] != 'mediaLoader') {
      //     playerOptions.children.unshift('mediaLoader');
      //   }
      // }

      if (playerOptions.children[0] != 'mediaLoader') {
        playerOptions.children.unshift('mediaLoader');
      }
      // 如果mediaAsyncLoader没有初始化，手动初始化
      // player.ready(videojs.bind(this, function () {
      //   if(!player['mediaAsyncLoader']){
      //     player['mediaAsyncLoader'] = player.addChild('MediaAsyncLoader');
      //   }
      // }));
    }
  };

  return VID;
}(Plugin$4);

videojs.registerPlugin('VID', VID);

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$2;

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

var now = function() {
  return _root.Date.now();
};

var now_1 = now;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$2.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
}

var isSymbol_1 = isSymbol;

var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;
var nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber_1(wait) || 0;
  if (isObject_1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now_1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now_1());
  }

  function debounced() {
    var time = now_1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

var debounce_1 = debounce;

var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle$1(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject_1(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce_1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle$1;

var Component$11 = videojs.getComponent('Component');

var DvrProgressControl = function (_Component) {
  inherits(DvrProgressControl, _Component);

  function DvrProgressControl(player, options) {
    classCallCheck(this, DvrProgressControl);

    // this.handleMouseMove = _.throttle(this.handleMouseMove.bind(this), 25);
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.on('mousemove', _this.handleMouseMove);
    _this.on('mouseup', _this.handleMouseUp);
    return _this;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  DvrProgressControl.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control tcp-dvr-progress-control'
    });
  };

  DvrProgressControl.prototype.update = function update(percent) {
    // console.log('DvrProgressControl update', percent);
    this.getChild('DvrSeekBar').update(percent);
  };
  /**
   * 鼠标在DvrProgressControl上方移动时，获取事件并根据鼠标的相对位置进行计算时间
   */


  DvrProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    // console.log('DvrProgressControl move', event);
    var dvrSeekBar = this.getChild('DvrSeekBar');
    var percent = dvrSeekBar.calculateDistance(event);
    var mouseTimeDisplay = dvrSeekBar.getChild('DvrMouseTimeDisplay');
    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(videojs.dom.getBoundingClientRect(dvrSeekBar.el()), percent);
    }
  };

  DvrProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    // console.log('DvrProgressControl mouseup');
    var dvrSeekBar = this.getChild('DvrSeekBar');
    dvrSeekBar.handleMouseUp(event);
  };

  return DvrProgressControl;
}(Component$11);

DvrProgressControl.prototype.options_ = {
  children: ['DvrSeekBar']
};
videojs.registerComponent('DvrProgressControl', DvrProgressControl);

/**
 * 时移滑动条容器
 * @extends Slider
 */
var Slider$2 = videojs.getComponent('Slider');

var DvrSeekBar = function (_Slider) {
  inherits(DvrSeekBar, _Slider);

  function DvrSeekBar(player, options) {
    classCallCheck(this, DvrSeekBar);

    var _this2 = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this2.percent_ = 1;
    _this2.update = throttle_1(videojs.bind(_this2, _this2.update), 50);
    // this.update = videojs.bind(this, this.update);
    // console.log('DvrSeekBar init vertical:', this.vertical()) // false
    _this2.on(player, 'seekToLive', videojs.bind(_this2, function (event) {
      this.update(event.data);
    }));
    return _this2;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  DvrSeekBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };
  /**
   * 在目标点击或者拖拽后更新滑块的位置
   * 同时更新aria属性值
   * @param {number} percent
   *        取值区间为[0,1]
   */


  DvrSeekBar.prototype.update = function update(percent) {
    // const percent = super.update();
    if (percent == undefined) {
      return;
    }
    this.percent_ = percent;
    // console.log('DvrSeekBar update', (percent*100).toFixed(2), window.getComputedStyle(this.el_).height);
    this.bar.update(videojs.dom.getBoundingClientRect(this.el_), percent);
    this.updateAriaAttributes(percent);
  };

  DvrSeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    _Slider.prototype.handleMouseDown.call(this, event);
    this.isMouseDown = true;
  };
  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  DvrSeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    // let newTime = this.calculateDistance(event) * this.player_.duration();
    var percent = this.calculateDistance(event);
    // console.log('DvrSeekBar mouseDown or move', this.calculateDistance(event));
    this.update(percent);
  };

  DvrSeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this);
    var percent = this.calculateDistance(event);
    //slider handleMouseUp 会调用 update 方法，但是没有传入参数，会影响DvrSeekBar的update逻辑
    // console.log('DvrSeekBar mouseUp', this.calculateDistance(event));
    this.update(percent);
    //设置时移播放地址
    this.player().Dvr().timeShift(percent);
  };

  DvrSeekBar.prototype.stepBack = function stepBack() {};

  DvrSeekBar.prototype.stepForward = function stepForward() {};

  DvrSeekBar.prototype.updateAriaAttributes = function updateAriaAttributes(percent) {
    var el = this.el();
    el.setAttribute('aria-valuenow', (percent * 100).toFixed(2));
  };

  DvrSeekBar.prototype.getPercent = function getPercent() {
    return this.percent_;
  };

  return DvrSeekBar;
}(Slider$2);

DvrSeekBar.prototype.options_ = {
  children: ['DvrMouseTimeDisplay', 'DvrTimeShiftBar'],
  barName: 'DvrTimeShiftBar'
};
videojs.registerComponent('DvrSeekBar', DvrSeekBar);

/**
 * 可拖动的时移进度条
 * @extends Component
 */

var DvrTimeShiftBar = function (_Component2) {
  inherits(DvrTimeShiftBar, _Component2);

  function DvrTimeShiftBar(player, options) {
    classCallCheck(this, DvrTimeShiftBar);

    var _this3 = possibleConstructorReturn(this, _Component2.call(this, player, options));

    _this3.el_.style.width = '100%';
    return _this3;
  }

  DvrTimeShiftBar.prototype.createEl = function createEl() {
    return _Component2.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar tcp-dvr-time-shift',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 100%</span>'
    });
  };
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  DvrTimeShiftBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    // console.log('DvrTimeShiftBar', seekBarRect, seekBarPoint);

    var percentage = (seekBarPoint * 100).toFixed(2) + '%';
    var style = this.el_.style;
    style.width = percentage;
  };

  return DvrTimeShiftBar;
}(Component$11);

videojs.registerComponent('DvrTimeShiftBar', DvrTimeShiftBar);

/**
 * 鼠标hover时，显示时间标签
 *
 */
var MouseTimeDisplay$2 = videojs.getComponent('MouseTimeDisplay');

var DvrMouseTimeDisplay = function (_MouseTimeDisplay) {
  inherits(DvrMouseTimeDisplay, _MouseTimeDisplay);

  function DvrMouseTimeDisplay() {
    classCallCheck(this, DvrMouseTimeDisplay);
    return possibleConstructorReturn(this, _MouseTimeDisplay.apply(this, arguments));
  }

  DvrMouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this5 = this;

    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var maxTimeShift = _this5.player().Dvr().dvrData['maxTimeShift'];
      var content = videojs.formatTime((1 - seekBarPoint) * maxTimeShift, maxTimeShift);

      _this5.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this5.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return DvrMouseTimeDisplay;
}(MouseTimeDisplay$2);

videojs.registerComponent('DvrMouseTimeDisplay', DvrMouseTimeDisplay);

/**
 * 返回直播视频按钮
 *  @extends Button
 */
var Button$4 = videojs.getComponent('Button');

var LiveButton = function (_Button) {
  inherits(LiveButton, _Button);

  function LiveButton() {
    classCallCheck(this, LiveButton);
    return possibleConstructorReturn(this, _Button.apply(this, arguments));
  }

  LiveButton.prototype.createEl = function createEl() {
    var el = Button$4.prototype.createEl.call(this, 'button', {
      className: 'vjs-live-control vjs-control'
    });
    this.contentEl_ = videojs.dom.createEl('div', {
      className: 'vjs-live-display',
      innerHTML: this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });
    el.appendChild(this.contentEl_);
    return el;
  };

  LiveButton.prototype.update = function update() {};

  LiveButton.prototype.updateControlText = function updateControlText(isLive) {
    this.controlText(isLive ? '直播中' : '返回直播');
  };

  LiveButton.prototype.handleClick = function handleClick(event) {
    this.player().Dvr().seekToLive();
  };

  return LiveButton;
}(Button$4);

LiveButton.prototype.controlText_ = '返回直播';
videojs.registerComponent('LiveButton', LiveButton);

/**
 * 直播时移回看插件，需要实现的内容
 * 1.播放带delay参数的hls地址
 * 2.获取进度条拖拽结果，计算出delay值，更新url参数并播放新的hls地址
 * 3.进度条的拖拽区间，即delay的取值区间
 * 4.与默认的进度条不同，不需要随timeupdate更新
 * 5.
 */
var Plugin$5 = videojs.getPlugin('plugin');

/**
 * 时移插件，实现通过进度条控件，控制时移值，
 * Digital video recorder  Live Time Shift
 * delay
 *
 */

var Dvr = function (_Plugin) {
  inherits(Dvr, _Plugin);

  function Dvr(player, options) {
    classCallCheck(this, Dvr);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.isInit = false;
    _this.options = options;
    var self = _this;
    console.log('new Dvr');

    player.ready(function () {
      var tech = player.tech(true);
      var hlsProvider = tech && tech.hlsProvider;
      //采用hls.js时可以初始化Dvr组件
      if (hlsProvider && hlsProvider.Hls) {
        var Hls = hlsProvider.Hls;
        //在获取到m3u8后开始初始化 hlsManifestLoaded
        tech.one(Hls.Events.MANIFEST_LOADED, function (event) {
          console.log(Hls.Events.MANIFEST_LOADED, event);
        });
        tech.one(Hls.Events.LEVEL_LOADED, function (event) {
          console.log(Hls.Events.LEVEL_LOADED, event);
        });
        //
        player.one('loadedmetadata', function (event) {
          console.log('loadedmetadata', event);
          //避免时移切换的时候 video的poster自动显示
          tech.el_.setAttribute('poster', '');
          self.init();
          if (self.options['liveURL']) {
            self.seekToLive();
          }
          return;
        });
      }
      //networkError 触发后需要回到直播状态
    });
    return _this;
  }

  Dvr.prototype.init = function init() {
    var player = this.player;
    var hlsProvider = player.tech(true).hlsProvider;
    // 可以通过hls的 hlsManifestLoaded事件获取m3u8数据，然而dvr初始化时，hls已经开始加载并触发事件，所以在这里监听hls时间可能达不到预期的目的
    // 解析当前播放的m3u8
    this.parseM3u8(hlsProvider.manifests[0]);
    // 没有检测到必要的参数，退出初始化过程，当再次播放时，按需重新初始化
    if (!this.dvrData['startTime'] && !this.isInit) {
      player.one('loadedmetadata', videojs.bind(this, function (event) {
        console.log('loadedmetadata1', this.isInit, hlsProvider);
        this.init();
      }));
      return;
    }
    console.log('init', this);
    this.initControl();
    // 初始时移值
    this.delay = getParams('delay', player.tech_.currentSource_.src) || 0;
    this.updateControl(!this.isLive());
    //当通过player.src切换地址时，仍需要更新状态
    player.on('loadedmetadata', videojs.bind(this, function () {
      console.log('loadedmetadata2', hlsProvider);
      this.parseM3u8(hlsProvider.manifests[0]);
      this.delay = getParams('delay', player.tech_.currentSource_.src) || 0;
      this.updateControl();
    }));
    this.isInit = true;
  };

  Dvr.prototype.initControl = function initControl() {
    var player = this.player;
    player.addClass('vjs-dvr');
    player.controlBar.getChild('ProgressControl').hide();
    player.controlBar.getChild('LiveDisplay').hide();
    // removeChild(player.controlBar, 'ProgressControl');
    // removeChild(player.controlBar, 'LiveDisplay');
    player.controlBar.addChild('DvrProgressControl', {}, 5);
    player.controlBar.addChild('liveButton', {}, 6);
  };

  Dvr.prototype.updateControl = function updateControl(updateProgress) {
    var player = this.player,
        progressControl = player.controlBar.getChild('ProgressControl'),
        liveDisplay = player.controlBar.getChild('LiveDisplay'),
        dvrProgressControl = player.controlBar.getChild('DvrProgressControl'),
        liveButton = player.controlBar.getChild('LiveButton');
    player.toggleClass('vjs-dvr-live', this.isLive());
    liveButton.updateControlText(this.isLive());
    if (updateProgress) {
      dvrProgressControl.update(1 - this.delay / this.dvrData.maxTimeShift);
    }
    //是否播放时移hls
    if (this.dvrData['startTime']) {
      dvrProgressControl.show();
      liveButton.show();
      progressControl.hide();
      liveDisplay.hide();
    } else {
      //非时移hls
      dvrProgressControl.hide();
      liveButton.hide();
      progressControl.show();
      liveDisplay.show();
    }
  };

  Dvr.prototype.seekToLive = function seekToLive() {
    // console.log('seekToLive', this.player);
    if (!this.isLive()) {
      this.timeShift(1);
      this.player.trigger({ type: 'seekToLive', data: 1 });
    }
  };
  /**
   * 返回是否是直播中，timshift值等于0
   */


  Dvr.prototype.isLive = function isLive() {
    return !(this.delay > 0);
  };
  /**
   *
   * @param percent 进度条滑块所在位置的百分比
   *        [0,1]，当值为0时，时移最大值，值为1时，不时移
   */


  Dvr.prototype.timeShift = function timeShift(percent) {
    var player = this.player,
        liveButton = player.getChild('ControlBar').getChild('LiveButton'),
        source = player.tech_.currentSource_,
        delay = Math.floor(this.dvrData['maxTimeShift'] * (1 - percent));
    this.delay = delay;
    // 直播地址与时移地址不一致
    if (delay == 0 && this.options['liveURL']) {
      player.src(this.options['liveURL']);
    } else {
      source.src = (this.options['shiftURL'] || source.src).replace(/delay=*(\d+)/, 'delay=' + delay);
      // this.player.tech_.hlsProvider.hls.loadSource(this.player.tech_.currentSource_.src);
      player.src(player.tech_.currentSource_.src);
    }

    player.bigPlayButton.hide();
    player.posterImage.hide();
    player.tech_.one('hlsManifestParsed', videojs.bind(this, function () {
      // player.one('loadedmetadata', videojs.bind(this, function () {
      //     console.log('hlsManifestParsed');
      player.play();
      // this.updateControl(false);
    }));
  };

  Dvr.prototype.parseM3u8 = function parseM3u8(string) {
    this.dvrData = {};
    // 可以通过hls的 hlsManifestLoaded事件获取m3u8数据，然而dvr初始化时，hls已经开始加载并触发事件，所以在这里监听hls时间可能达不到预期的目的
    // 当前时间戳 - #EXT-TX-TS-START-TIME与#EXT-TX-TS-DURATION比较，选择小的
    // console.log('dvr init', hlsProvider);
    // const TX_TS_START_TIME=/#EXT-TX-TS-START-TIME:*(.+)/;
    // const TX_TS_DURATION_REGEX=/#EXT-TX-TS-DURATION:*(.+)/;
    var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXT-TX-TS-START-TIME:*(.+)/.source, /|#EXT-TX-TS-DURATION:*(.+)/.source].join(''), 'g');
    var result = void 0;
    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      if (result[1]) {
        //START-TIME 直播开始时间
        this.dvrData['startTime'] = result[1];
      } else if (result[2]) {
        //DURATION 直播持续时间，
        this.dvrData['duration'] = result[2];
      }
    }
    if (this.dvrData['startTime']) {
      //可回看时移最大值
      this.dvrData['maxTimeShift'] = Math.min(Math.floor(new Date().getTime() / 1000 - this.dvrData['startTime']), this.dvrData['duration']);
    }
    // console.log('dvr init', this.dvrData);
  };

  return Dvr;
}(Plugin$5);

videojs.registerPlugin('Dvr', Dvr);

var Menu$4 = videojs.getComponent('Menu');

var QualitySwitcherMenu = function (_Menu) {
  inherits(QualitySwitcherMenu, _Menu);

  function QualitySwitcherMenu() {
    classCallCheck(this, QualitySwitcherMenu);
    return possibleConstructorReturn(this, _Menu.apply(this, arguments));
  }

  QualitySwitcherMenu.prototype.addItem = function addItem(component) {
    _Menu.prototype.addItem.call(this, component);
    //更新非选中项的状态
    /*component.on(['tap', 'click'], () => {
      let children = this.children();
      for (var i=0; i < children.length; i++) {
        var child = children[i];
        if (component !== child) {
          child.selected(false);
          child.options_.selected = false;
        }else{
          //选中
          child.options_.selected = true;
        }
      }
    });*/
  };

  return QualitySwitcherMenu;
}(Menu$4);
// 不能通过配置创建的组件不能注册和声明name

var MenuItem$6 = videojs.getComponent('MenuItem');

var QualitySwitcherMenuItem = function (_MenuItem) {
  inherits(QualitySwitcherMenuItem, _MenuItem);

  function QualitySwitcherMenuItem(player, options) {
    classCallCheck(this, QualitySwitcherMenuItem);
    return possibleConstructorReturn(this, _MenuItem.call(this, player, options));
    // console.log('QualitySwitcherMenuItem', options);
  }

  QualitySwitcherMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this, event);
    this.updateItems();
    //需要调用对应quality的回调函数
    //options 包含的值在 QualitySwitcherMenuButton 初始化Item时传入
    this.options_.callback(this.options_);
    if (this.options_.trackType == 'video') {
      var menuButton = this.player().controlBar.getChild(this.options_.trackType + 'QualitySwitcherMenuButton');
      menuButton.updateLabel(this.options_);
      menuButton.unpressButton();
    }
  };
  /**
   * 更新所有item的选中状态
   */


  QualitySwitcherMenuItem.prototype.updateItems = function updateItems() {
    var menuButton = this.player().controlBar.getChild(this.options_.trackType + 'QualitySwitcherMenuButton'),
        menu = menuButton.getChild(this.options_.trackType + 'QualitySwitcherMenu'),
        children = menu.children();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (this !== child) {
        child.selected(false);
        child.options_.selected = false;
      } else {
        child.options_.selected = true;
      }
    }
  };

  return QualitySwitcherMenuItem;
}(MenuItem$6);
// 不能通过配置创建的组件不能注册和声明name

var MenuButton$2 = videojs.getComponent('MenuButton');
var Menu$3 = videojs.getComponent('Menu');

var QualitySwitcherMenuButton = function (_MenuButton) {
  inherits(QualitySwitcherMenuButton, _MenuButton);

  function QualitySwitcherMenuButton() {
    classCallCheck(this, QualitySwitcherMenuButton);
    return possibleConstructorReturn(this, _MenuButton.apply(this, arguments));
  }

  QualitySwitcherMenuButton.prototype.createEl = function createEl() {
    var el = _MenuButton.prototype.createEl.call(this);
    this.labelEl_ = videojs.dom.createEl('div', {
      className: 'tcp-quality-switcher-value',
      innerHTML: ''
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  QualitySwitcherMenuButton.prototype.createMenu = function createMenu() {
    var qualityList = this.options_.qualityList,
        menu = new QualitySwitcherMenu(this.player(), { 'name': this.options_.trackType + 'QualitySwitcherMenu' }),
        options = void 0;
    //创建item
    // console.log('createMenu QualitySwitcherMenuButton',this.options_);
    for (var i = qualityList.length - 1; i > -1; i--) {
      var qualityItem = qualityList[i];
      options = videojs.mergeOptions(qualityItem, {
        // 'name': qualityItem.label,
        'trackType': this.options_.trackType,
        'callback': this.options_.callback,
        'selectable': true
      });
      menu.addItem(new QualitySwitcherMenuItem(this.player(), options));
      if (qualityItem.selected) {
        this.updateLabel(qualityItem);
      }
    }
    return menu;
  };

  QualitySwitcherMenuButton.prototype.updateLabel = function updateLabel(data) {
    this.labelEl_.innerHTML = '<p>' + this.localize(data.label) + '</p>';
  };

  return QualitySwitcherMenuButton;
}(MenuButton$2);
// 不能通过配置创建的组件不能注册和声明name

/**
 * @file quality-switcher.js
 */
var Plugin$6 = videojs.getPlugin('plugin');
var TRACK_TYPES = ["video", "audio", "subtitle"];
var TRACK_CLASS = {
  video: 'tcp-video-quality-switcher',
  audio: 'tcp-audio-quality-switcher',
  subtitle: 'tcp-subtitle-quality-switcher'
};
var log$5 = videojs.log;
// const log = console.log;

var QualitySwitcher = function (_Plugin) {
  inherits(QualitySwitcher, _Plugin);

  /**
   * Hls质量平滑切换，依赖hls.js
   * 普通视频质量切换
   * 音频质量切换
   *
   * 1.在播放hls时，并解析到master playlist后初始化
   * 2.在palyer初始化传入多个source，并设置了多清晰度的参数时，进行初始化
   *
   * 初始化：分辨率切换按钮和菜单
   * 切换清晰度时的回调函数
   * hls的回调
   * 普通切换的回调
   *
   */
  function QualitySwitcher(player, options) {
    classCallCheck(this, QualitySwitcher);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    //注册事件，当触发load quality data时进行初始化
    player.on('qualitydataloaded', videojs.bind(_this, _this.init));
    return _this;
  }

  /**
   * 初始化 switcher
   * @param event
   * event.data
   * ｛
   *    qualityData：｛
   *      'video':[{
   *        'id': String
   *        'label': String
   *        'selected': Boolean
   *      },{...}],
   *      'audio:[{...},...]
   *      'subtitle':[{...},...]
   *    ｝
   *    callbacks：｛
   *      'video': function,
   *      'audio': function,
   *      'subtitle': function
   *    ｝
   * ｝
   */


  QualitySwitcher.prototype.init = function init(event) {
    log$5('QualitySwitcher initializing', event);
    var player = this.player,
        qualityData = event.data.qualityData,
        callbacks = event.data.callbacks;
    this.setOptions({ qualityData: qualityData, callbacks: callbacks });
    if (!player.controlBar) {
      log$5('QualitySwitcher can not initialize without control bar');
      return;
    }
    //分别创建 video audio subtitle的switch
    for (var i = 0; i < TRACK_TYPES.length; i++) {
      var track = TRACK_TYPES[i],

      //name 用于区分是哪种选择器，在item 被选中后,item根据name通知控件更新状态
      name = track + 'QualitySwitcherMenuButton',
          qualitySwitcherMenuButton = player.controlBar.getChild(name);

      if (qualityData[track] && qualityData[track].length > 0 && !!player.controlBar.options_['QualitySwitcherMenuButton']) {
        if (qualitySwitcherMenuButton && qualitySwitcherMenuButton.el()) {
          // 确保重复初始化时，之前的组件已经销毁，并且从父组件中移除.
          qualitySwitcherMenuButton.dispose();
          player.controlBar.removeChild(qualitySwitcherMenuButton);
        }
        this.repleaceLabel(track, qualityData); // 使用 playcgi 返回的 清晰度 lable 不利于国际化
        qualitySwitcherMenuButton = new QualitySwitcherMenuButton(player, { name: name, qualityList: qualityData[track], callback: callbacks[track], trackType: track });
        qualitySwitcherMenuButton.addClass(TRACK_CLASS[track]);
        player.controlBar.addChild(qualitySwitcherMenuButton, {}, 10);
      }
    }
    log$5('QualitySwitcher initialized', event, this);
  };
  /**
   * {
   *  qualityLabelList
   * }
   * @param {*} options
   */


  QualitySwitcher.prototype.setOptions = function setOptions(options) {
    this.options = videojs.mergeOptions(this.options, options);
    // console.log('setOptions', this, options);
  };
  /**
   *
   * @param {*} qualityItem {id: index}, index 0, 1, 2...
   */


  QualitySwitcher.prototype.setVideoQuality = function setVideoQuality(qualityItem) {
    if (this.options.qualityData && this.options.callbacks['video']) {
      var qualityData = this.options.qualityData['video'];
      for (var i = 0; i < qualityData.length; i++) {
        if (qualityData[i].selected) {
          qualityData[i].selected = false;
        }
        if (qualityData[i].id === qualityItem.id) {
          qualityData[i].selected = true;
        }
      }
      this.options.callbacks['video'](qualityItem);
    }
  };

  QualitySwitcher.prototype.getVideoQualityData = function getVideoQualityData() {
    return this.options.qualityData ? this.options.qualityData['video'] : undefined;
  };
  /**
   * 用 options.qualityLabelList 替换 qualityData['video'] 的 label
   * @param {string} trackName video 目前仅仅支持 video，audio 数据格式没有约定
   */


  QualitySwitcher.prototype.repleaceLabel = function repleaceLabel(trackName, qualityData) {
    if (!this.options.qualityLabelList) {
      return;
    }
    var qualityLabelList = this.options.qualityLabelList[trackName],
        qualityTrackData = qualityData[trackName];
    if (qualityTrackData && qualityTrackData.length > 0 && qualityLabelList && qualityLabelList.length > 0) {
      for (var i = 0; i < qualityTrackData.length; i++) {
        var label = qualityTrackData[i].label;
        label = label.slice(0, label.length - 1);
        for (var j = 0; j < qualityLabelList.length; j++) {
          if (qualityLabelList[j].height == label) {
            qualityTrackData[i].label = qualityLabelList[j].resolutionName;
            break;
          }
        }
      }
    }
  };
  /**
   * 重置质量切换插件
   */


  QualitySwitcher.prototype.reset = function reset() {
    var player = this.player;
    for (var i = 0; i < TRACK_TYPES.length; i++) {
      var track = TRACK_TYPES[i],
          qualitySwitcherMenuButton = player.controlBar && player.controlBar.getChild(track + 'QualitySwitcherMenuButton');
      if (qualitySwitcherMenuButton && qualitySwitcherMenuButton.el()) {
        qualitySwitcherMenuButton.dispose();
        player.controlBar.removeChild(qualitySwitcherMenuButton);
      }
    }
  };

  return QualitySwitcher;
}(Plugin$6);

videojs.registerPlugin('QualitySwitcher', QualitySwitcher);

var Plugin$7 = videojs.getPlugin('plugin');
var log$6 = videojs.log;

var defaultOptions = {
  'labels': { 'FLU': '流畅', 'SD': '标清', 'HD': '高清', 'FHD': '超清' },
  'showOrder': ['FLU', 'SD', 'HD', 'FHD'],
  'defaultRes': 'SD'
};

var MultiResolution = function (_Plugin) {
  inherits(MultiResolution, _Plugin);

  /**
   *
   * 用于支持传入多种分辨率的视频，依赖 QualitySwitcher
   * {@link QualitySwitcher}
   * multiResolution:
   * {
   *  sources:{'SD':[{Object}]}
   *  labels:{'SD':'标清','HD':'高清'},
   *  showOrder:['FLU', 'SD', 'HD', 'FHD'],
   *  defaultRes: 'SD',
   *  useManualOption: false,
   * }
   */
  function MultiResolution(player, options) {
    classCallCheck(this, MultiResolution);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    if (options.useManualOption) {
      _this.manualOptions = extend({}, options);
      // {
      //   'labels': options.labels,
      //   'showOrder': options.showOrder,
      //   'defaultRes': options.defaultRes
      // }
    }
    _this.hasInit = false;
    player.on('multiresolutionchange', videojs.bind(_this, function (event) {
      if (event.data) {
        this.update(data);
      }
    }));
    // 切换过程增加css class
    player.on(['resolutionswitching', 'resolutionswitched'], videojs.bind(_this, function (event) {
      if (event.type == 'resolutionswitching') {
        this.player.addClass('tcp-res-switching');
      } else {
        this.player.removeClass('tcp-res-switching');
      }
    }));
    player.ready(videojs.bind(_this, function () {
      var tech = player.tech(true);
      if (tech) {
        // 监听hls播放 master playlist的事件
        tech.on('masterplaylistchange', videojs.bind(this, this.onMasterPlaylistChange));
        tech.on('hlsresolutionswitching', videojs.bind(this, this.onHlsLevelChange));
        tech.on('hlsresolutionswitched', videojs.bind(this, this.onHlsLevelChange));

        // 监听dash播放事件
        tech.on('dashqualityswitching', videojs.bind(this, this.onDashQualityChange));
        tech.on('dashqualityswitched', videojs.bind(this, this.onDashQualityChange));
      }
      this.hasInit = true;
    }));
    _this.init(_this.player.options_.multiResolution);
    return _this;
  }

  /**
   * 初始化数据
   * @param data
   * data = {Object} multiResolution
   */


  MultiResolution.prototype.init = function init(data) {
    var opt = {};
    // label、showOrder、defaultRes 这三个参数也要覆盖default
    if (this.player.options_.label) {
      opt.label = this.player.options_.label;
    }
    if (this.player.options_.showOrder) {
      opt.showOrder = this.player.options_.showOrder;
    }
    if (this.player.options_.defaultRes) {
      opt.defaultRes = this.player.options_.defaultRes;
    }

    var player = this.player,

    // options = videojs.mergeOptions(defaultOptions, data, this.manualOptions),
    options = extend({}, defaultOptions, data, this.manualOptions, opt),
        multiResSources = options && options.sources;
    this.options = options;
    // console.log('MultiResolution init', this.options, defaultOptions, data, this.manualOptions);
    if (multiResSources) {
      log$6('MultiResolution initializing', options);
      // this.currentID = options.defaultRes;
      var playSource = void 0;
      // let playSource = multiResSources[this.currentID] || multiResSources[Object.keys(multiResSources)[0]];
      // 如果player通过 medialoader 初始化
      // 需要注意 defaultRes 指定的清晰度视频可能不存在
      this.currentID = options.defaultRes = multiResSources[options.defaultRes] ? options.defaultRes : Object.keys(multiResSources).shift();
      playSource = multiResSources[this.currentID];

      if (player.options_.children[0] == 'mediaLoader' && !this.hasInit) {
        var _player$options_$sour;

        //设置原始的sources，在medialoader初始化时,会调用player.src设置播放地址
        (_player$options_$sour = player.options_.sources).push.apply(_player$options_$sour, playSource);
      } else {
        player.src(playSource);
      }
      if (!this.hasInit) {
        this.hasInit = true;
      }
      //通过事件初始化切换清晰度组件
      player.ready(videojs.bind(this, function () {
        player.trigger({ type: 'qualitydataloaded', data: this.initQualityData(options) });
        //避免切换的时候 video 的poster自动显示，需要删除h5 tech自带的poster
        player.one('loadedmetadata', function () {
          var tech = this.tech(true);
          // console.log('loadedmetadata', tech);
          // IE无法获取到tech.name, h5 为unknown tech, flash为 undefined
          if ('flash' != tech.name_ && tech.el_.getAttribute('poster')) {
            // 设置过video poster，在切换src时会看到 poster ，这里必须想办法去掉video poster。
            // tech.el_.setAttribute('poster', '');
            tech.el_.removeAttribute('poster');
            delete tech.el_.poster;
          }
        });
      }));
      log$6('MultiResolution initialized');
    }
  };

  /**
   * 重置多清晰度插件
   */


  MultiResolution.prototype.reset = function reset() {
    var player = this.player;
    player.QualitySwitcher().reset();
  };

  /**
   * 更新多分辨率数据
   * @param data
   * data = {Object} multiResolution
   */


  MultiResolution.prototype.update = function update(data) {
    // console.log(this, data);
    this.init(data);
  };

  /**
   * 存储配置信息
   * @param data
   * @returns {*}
   */


  MultiResolution.prototype.store = function store(data) {
    if (!data) {
      return this.options;
    }
    this.options = videojs.mergeOptions(defaultOptions, this.options, data);
  };

  /**
   * 处理hls获取的master playlist数据，重新匹配配置的显示分辨率、labels、order等
   * @param event
   */


  MultiResolution.prototype.onMasterPlaylistChange = function onMasterPlaylistChange(event) {
    console.log('onMasterPlaylistChange', event);
    // let tech = this.player.tech(true);
    this.player.trigger({ type: 'qualitydataloaded', data: event.data });
  };

  MultiResolution.prototype.onHlsLevelChange = function onHlsLevelChange(event) {
    // console.log('onHlsLevelChange', event);
    if (event.type == 'hlsresolutionswitching') {
      this.player.trigger({ type: 'resolutionswitching', data: event.data });
    } else if (event.type == 'hlsresolutionswitched') {
      this.player.trigger({ type: 'resolutionswitched', data: event.data });
    }
  };

  MultiResolution.prototype.onDashQualityChange = function onDashQualityChange(event) {
    // console.log('onDashQualityChange', event);
    if (event.type == 'dashqualityswitching') {
      this.player.trigger({ type: 'resolutionswitching', data: event.data });
    } else if (event.type == 'dashqualityswitched') {
      this.player.trigger({ type: 'resolutionswitched', data: event.data });
    }
  };

  /**
   * quality switcher 的回调函数，参数为选中的item options
   * @param data
   * {
   *    'id': {String}
   *    'label': {String}
   *    'selected': {Boolean}
   * }
   */


  MultiResolution.prototype.switchResolution = function switchResolution(data) {
    if (this.currentID == data.id) {
      return;
    }
    var player = this.player;
    var currentTime = player.currentTime();
    var isPaused = player.paused(); // 切换前是否暂停，在H5模式下播放结束也可能是暂停
    var isLive = Infinity === player.duration();
    console.log('switchResolution', data, player.duration(), isPaused);

    player.trigger({ type: 'resolutionswitching', data: data });
    if (isLive) {
      // 直播模式下的切换
      player.bigPlayButton && player.bigPlayButton.hide();
      player.posterImage && player.posterImage.hide();
      // // 切换后，在事件内恢复播放，以防止播放失败
      player.one('loadstart', function () {
        player.play();
        player.trigger({ type: 'resolutionswitched', data: data });
      });
    } else {
      var isEnded = player.ended(); // 切换前是否播放结束
      var prePlaybackRate = player.playbackRate();
      var playBarWidth = player.controlBar && player.controlBar.progressControl && player.controlBar.progressControl.seekBar.playProgressBar.el().style.width || 0;
      // ios 必须loadeddata后才能设置currentTime
      // loadedmetadata trigger faster then loadeddata
      var event = videojs.browser.IS_IOS || videojs.browser.IS_ANDROID ? 'loadeddata' : 'loadedmetadata';
      player.one(event, function () {
        if (player.controlBar && player.controlBar.progressControl) {
          // 切换视频时，避免进度条跳动
          player.controlBar.progressControl.seekBar.playProgressBar.el().style.width = playBarWidth;
        }
        if (!isEnded) {
          player.currentTime(currentTime);
        }
        // ios qq浏览器在播放结束后 暂停状态为true，结束状态为false，其他正常情况结束状态为true
        // 是否需要判断切换前的视频播放状态，切换后保持原有的播放状态，为了避免因不同的浏览器造成复杂逻辑，这里统一改成：切换后继续播放，如播放结束则从头开始播放。
        // FLash 模式下需要手动处理seeked事件
        // FLash 模式下无法直接pause 必须调用play后，延迟调用pause
        if (player.techName_ == 'Flash') {
          player.play();
          player.tech(true).trigger('seeked');
        } else {
          // console.log('switchResolution', isPaused, isEnded);
          player.play();
          if (player.playbackRate() != prePlaybackRate) {
            player.playbackRate(prePlaybackRate);
          }
        }
        // console.log('switchResolution switched');
        player.trigger({ type: 'resolutionswitched', data: data });
      });
      player.bigPlayButton && player.bigPlayButton.hide();
      player.posterImage && player.posterImage.hide();
      // console.log('switchResolution switching', this);
      if (player.options_['preload'] == 'none') {
        player.one('suspend', function () {
          player.load();
        });
      }
    }
    player.src(this.options.sources[data.id]);
    if (isLive) {
      setTimeout(function () {
        player.play();
        // FIXME: 播放快直播有可能第一次play没有成功，需要补一次play，暂时没有时间找更好的办法。
        setTimeout(function () {
          player.play();
        }, 900);
        // if(player.src().indexOf('webrtc://') > -1 || player.src().indexOf('.sdp') > -1){
        //   player.tech(true).webrtcProvider.recovery();
        // }
      }, 100);
    }
    console.log('switchResolution');
    console.log(player.src());
    this.currentID = data.id;
  };

  /**
   * 初始化切换器需要的数据
   * @param originData
   *  via multiResolution
   * @returns {Object}
   * ｛
   *    qualityData：｛
   *      'video':[{
   *        'id': {String}
   *        'label': {String}
   *        'selected': {Boolean}
   *      }]
   *    ｝
   *    callbacks：｛
   *      'video': {function}
   *    ｝
   * ｝
   */


  MultiResolution.prototype.initQualityData = function initQualityData(originData) {
    var list = [],
        sources = originData.sources,
        labels = originData.labels,
        showOrder = originData.showOrder;
    if (showOrder.length > 0) {
      showOrder.forEach(function (val, key) {
        var resolution = {};
        resolution.id = val;
        resolution.selected = originData.defaultRes === val;
        resolution.label = labels[val] || val;
        list.push(resolution);
      });
    }
    return {
      'qualityData': {
        'video': list
      },
      'callbacks': {
        'video': videojs.bind(this, this.switchResolution)
      }
    };
  };

  /**
   * 根据播放格式优先级配置，对原始sources进行排序
   * @param origin
   * @returns {Array}
   */


  MultiResolution.prototype.sortSourceOrder = function sortSourceOrder(origin) {
    var source = [];
    return source;
  };

  return MultiResolution;
}(Plugin$7);

videojs.registerPlugin('MultiResolution', MultiResolution);

/**
 * @file error.js
 * TODO 需重构
 */
var FlashObj = videojs.getComponent('Flash');
var defaultDismiss = !videojs.browser.IS_IPHONE;

// Video.js 5/6 cross-compatibility.
var registerPlugin = videojs.registerPlugin || videojs.plugin;

// errors 里相应的 code 的 message 是语言配置里的 key , 1~5 不需要重新配置 message，已经在 media-error.js 中配置，其余的message需要在language里配置多语言文案，
var defaults$1 = {
  header: '',
  code: '',
  message: '',
  timeout: 45 * 1000,
  dismiss: defaultDismiss,
  progressDisabled: false,
  errors: {
    '1': {
      type: 'MEDIA_ERR_ABORTED'
      // message: 'The video download was cancelled'
    },
    '2': {
      type: 'MEDIA_ERR_NETWORK'
      // message: 'The video connection was lost, please confirm you are ' + 'connected to the internet'
    },
    '3': {
      type: 'MEDIA_ERR_DECODE'
      // message: 'The video is bad or in a format that cannot be played on your browser'
    },
    '4': {
      type: 'MEDIA_ERR_SRC_NOT_SUPPORTED'
      // message: 'This video is either unavailable or not supported in this browser'
    },
    '5': {
      type: 'MEDIA_ERR_ENCRYPTED'
      // message: 'The video you are trying to watch is encrypted and we do not know how ' + 'to decrypt it'
    },
    'unknown': {
      type: 'MEDIA_ERR_UNKNOWN'
      // message: 'An unanticipated problem was encountered, check back soon and try again'
    },
    '-1': {
      type: 'PLAYER_ERR_NO_SRC',
      message: 'No video has been loaded.'
    },
    '-2': {
      type: 'PLAYER_ERR_TIMEOUT',
      message: 'Could not download the video.'
    },
    // 请求超时
    '10': {
      type: 'SERVER_ERR',
      message: 'Request timed out.'
    },
    // 服务器没有响应 4xx\5xx
    '11': {
      type: 'SERVER_ERR',
      message: 'Server is not respond.'
    },
    // 服务器返回异常数据
    '12': {
      type: 'DATA_ERR',
      message: 'Server respond error data.'
    },
    // 视频没有转码
    '13': {
      type: 'DATA_ERR',
      message: 'No video transcoding information found.'
    },
    // Hls 网络异常
    '14': {
      type: 'HLS_NETWORK_ERR',
      message: 'A network error caused the media download to fail part-way.'
    },
    // Hls 媒体异常
    '15': {
      type: 'HLS_MEDIA_ERR',
      message: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.'
    },
    // Hls 封装异常
    '16': {
      type: 'HLS_MUX_ERR',
      message: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.'
    },
    // Hls 其他异常
    '17': {
      type: 'HLS_OTHER_ERR',
      message: 'Rise an internal exception when playing HLS.'
    },
    '18': {
      type: 'DRM_ERR',
      message: 'Current browser not support DRM.'
    },
    // 防盗链参数鉴权失败，找点播组playcgi负责人排查
    '403': {
      type: 'SERVER_ERR',
      message: 'Authentication failed.'
    },
    // 服务器异常，找点播组playcgi负责人排查
    '500': {
      type: 'SERVER_ERR',
      message: 'Server failed.'
    },
    // 文件不存在
    '1001': {
      type: 'SERVER_ERR',
      message: 'The media file does not exist. Please check if the fileID is correct.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1002': {
      type: 'SERVER_ERR',
      message: 'The trial duration is illegal. The trial duration must be within the video duration.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1003': {
      type: 'SERVER_ERR',
      message: 'Param pcfg is not unique.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1004': {
      type: 'SERVER_ERR',
      message: 'The license has expired. Please check whether the expiration time setting is reasonable.'
    },
    // 没有自适应码流
    '1005': {
      type: 'SERVER_ERR',
      message: 'Did not find an adaptive stream that can be played.'
    },
    '1006': {
      type: 'SERVER_ERR',
      message: 'Invalid request format, please check the request format.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1007': {
      type: 'SERVER_ERR',
      message: 'AppID is not exist, Please check if the AppID is correct.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1008': {
      type: 'SERVER_ERR',
      message: 'Without anti-leech information.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1009': {
      type: 'SERVER_ERR',
      message: 'psign check failed.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '1010': {
      type: 'SERVER_ERR',
      message: 'Other errors.'
    },
    // 获取视频文件失败，找点播组playcgi负责人排查
    '2001': {
      type: 'SERVER_ERR',
      message: 'Internal error.'
    },
    // 视频文件不存在
    '10008': {
      type: 'SERVER_ERR',
      message: 'The media file does not exist. Please check if the fileID is correct.'
    },
    "-2001": {
      type: "SERVER_ERR",
      message: "Current browser not support play this stream, please select another one."
    },
    "-2002": {
      type: "SERVER_ERR",
      message: "Server respond error data.(eg. stream not exist)"
    },
    "-2003": {
      type: "SERVER_ERR",
      message: "Video play failed, please refresh to start play again."
    },
    "-2004": {
      type: "SERVER_ERR",
      message: "Connection to the server has failed and the number of connection retries has exceeded the set value."
    },
    "-2005": {
      type: "SERVER_ERR",
      message: "Video decoding failure."
    },
    'PLAYER_ERR_DOMAIN_RESTRICTED': {
      message: 'This video is restricted from playing on your current domain.'
    },
    'PLAYER_ERR_IP_RESTRICTED': {
      message: 'This video is restricted at your current IP address.'
    },
    'PLAYER_ERR_GEO_RESTRICTED': {
      message: 'This video is restricted from playing in your current geographic region.'
    }
  }
};

var initPlugin = function initPlugin(player, options) {
  var monitor = void 0;
  var waiting = void 0;
  var isStalling = void 0;
  var listeners = [];
  //避免 errorDisplay 在触发 error 后重新填充弹框内容
  videojs.getComponent('ErrorDisplay').prototype.options_.fillAlways = false;

  var updateErrors = function updateErrors(updates) {
    options.errors = videojs.mergeOptions(options.errors, updates);

    // Create `code`s from errors which don't have them (based on their keys).
    Object.keys(options.errors).forEach(function (k) {
      var err = options.errors[k];

      if (!err.type) {
        err.type = k;
      }
    });
  };

  // Make sure we flesh out initially-provided errors.
  updateErrors();

  // clears the previous monitor timeout and sets up a new one
  var resetMonitor = function resetMonitor() {
    // at this point the player has recovered
    player.clearTimeout(waiting);
    if (isStalling) {
      isStalling = false;
      player.removeClass('vjs-waiting');
    }

    // start the loading spinner if player has stalled
    waiting = player.setTimeout(function () {
      // player already has an error
      // or is not playing under normal conditions
      if (player.error() || player.paused() || player.ended()) {
        return;
      }

      isStalling = true;
      player.addClass('vjs-waiting');
    }, 1000);

    player.clearTimeout(monitor);
    monitor = player.setTimeout(function () {
      // player already has an error
      // or is not playing under normal conditions
      if (player.error() || player.paused() || player.ended()) {
        return;
      }

      player.error({
        code: -2,
        type: 'PLAYER_ERR_TIMEOUT'
      });
    }, options.timeout);

    // clear out any existing player timeout
    // playback has recovered
    if (player.error() && player.error().code === -2) {
      player.error(null);
    }
  };

  // clear any previously registered listeners
  var cleanup = function cleanup() {
    var listener = void 0;

    while (listeners.length) {
      listener = listeners.shift();
      player.off(listener[0], listener[1]);
    }
    player.clearTimeout(monitor);
    player.clearTimeout(waiting);
  };

  // creates and tracks a player listener if the player looks alive
  var healthcheck = function healthcheck(type, fn) {
    var check = function check() {
      // if there's an error do not reset the monitor and
      // clear the error unless time is progressing
      if (!player.error()) {
        // error if using Flash and its API is unavailable
        var tech = player.$('.vjs-tech');

        if (tech && tech.type === 'application/x-shockwave-flash' && !tech.vjs_getProperty) {
          player.error({
            code: -2,
            type: 'PLAYER_ERR_TIMEOUT'
          });
          return;
        }

        // playback isn't expected if the player is paused
        if (player.paused()) {
          return resetMonitor();
        }
        // playback isn't expected once the video has ended
        if (player.ended()) {
          return resetMonitor();
        }
      }

      fn.call(this);
    };

    player.on(type, check);
    listeners.push([type, check]);
  };

  var onPlayStartMonitor = function onPlayStartMonitor() {
    var lastTime = 0;

    cleanup();

    // if no playback is detected for long enough, trigger a timeout error
    resetMonitor();
    healthcheck(['timeupdate', 'adtimeupdate'], function () {
      var currentTime = player.currentTime();

      // playback is operating normally or has recovered
      if (currentTime !== lastTime) {
        lastTime = currentTime;
        resetMonitor();
      }
    });

    if (!options.progressDisabled) {
      healthcheck('progress', resetMonitor);
    }
  };

  var onPlayNoSource = function onPlayNoSource() {
    if (!player.currentSrc()) {
      player.error({
        code: -1,
        type: 'PLAYER_ERR_NO_SRC'
      });
    }
  };

  var onErrorHandler = function onErrorHandler(arg) {
    var details = '';
    var error = player.error();
    var content = document_1.createElement('div');
    var dialogContent = '';

    // In the rare case when `error()` does not return an error object,
    // defensively escape the handler function.
    if (!error) {
      return;
    }
    console.log(error, options.errors[error.code || 0]);
    error = videojs.mergeOptions(error, options.errors[error.code || 0]);
    /*
        if (error.code === 4 && FlashObj && !FlashObj.isSupported()) {
          const flashMessage = player.localize(
            'If you are using an older browser please try upgrading or installing Flash.'
          );
           details += `<span class="vjs-errors-flashmessage">${flashMessage}</span>`;
        }
    */

    if (error.message) {
      details = '<div class="vjs-errors-message">' + player.localize(error.message) + '</div>';
    }
    if (error.code) {
      details += '<div class="vjs-errors-code">' + this.localize('Error Code') + ' : ' + error.code + '</div>';
    }
    if (error.type) {
      details += '<div class="vjs-errors-type">' + this.localize('Error Type') + ' : ' + error.type + '</div>';
    }
    if (error.code == '10' || error.code == '11') {
      // 超时提示诊断网络
      details += '<a href="https://ping.huatuo.qq.com/playvideo.qcloud.com" target="_blank" class="vjs-error-check-network">诊断网络</a>';
    }
    content.className = 'vjs-errors-dialog';
    // content.id = 'vjs-errors-dialog';
    // dialogContent =
    //   `<div class="vjs-errors-content-container">
    //   <h2 class="vjs-errors-headline">${this.localize(error.headline)}</h2>
    //     <div><b>${this.localize('Error Code')}</b>: ${(error.type || error.code)}</div>
    //     ${details}
    //   </div>`;

    dialogContent = '<div class="vjs-errors-content-container">\n        ' + details + '\n      </div>';
    var display = player.getChild('errorDisplay');
    var closeable = display.closeable(!('dismiss' in error) || error.dismiss);

    // We should get a close button
    if (closeable) {
      // dialogContent +=
      //   `<div class="vjs-errors-ok-button-container">
      //     <button class="vjs-errors-ok-button">${this.localize('OK')}</button>
      //   </div>`;
      content.innerHTML = dialogContent;
      display.fillWith(content);
      // Get the close button inside the error display
      display.contentEl().firstChild.appendChild(display.getChild('closeButton').el());

      // const okButton = display.el().querySelector('.vjs-errors-ok-button');

      // player.on(okButton, 'click', function() {
      //   display.close();
      // });
    } else {
      content.innerHTML = dialogContent;
      display.fillWith(content);
    }

    // if (player.currentWidth() <= 600 || player.currentHeight() <= 250) {
    //   display.addClass('vjs-xs');
    // }

    display.one('modalclose', function () {
      return player.error(null);
    });
  };

  var onDisposeHandler = function onDisposeHandler() {
    cleanup();

    player.removeClass('vjs-errors');
    // player.off('play', onPlayStartMonitor);
    // player.off('play', onPlayNoSource);
    player.off('dispose', onDisposeHandler);
    player.off(['aderror', 'error'], onErrorHandler);
  };

  var reInitPlugin = function reInitPlugin(newOptions) {
    onDisposeHandler();
    initPlugin(player, videojs.mergeOptions(defaults$1, newOptions));
  };

  reInitPlugin.extend = function (errors) {
    return updateErrors(errors);
  };
  reInitPlugin.getAll = function () {
    return videojs.mergeOptions(options.errors);
  };

  reInitPlugin.disableProgress = function (disabled) {
    options.progressDisabled = disabled;
    onPlayStartMonitor();
  };
  // 注释掉 监控逻辑
  // player.on('play', onPlayStartMonitor);
  // player.on('play', onPlayNoSource);
  player.on('dispose', onDisposeHandler);
  player.on(['aderror', 'error'], onErrorHandler);

  player.ready(function () {
    player.addClass('vjs-errors');
  });

  player.errors = reInitPlugin;
};

var errors = function errors(options) {
  initPlugin(this, videojs.mergeOptions(defaults$1, options));
};

['extend', 'getAll', 'disableProgress'].forEach(function (k) {
  errors[k] = function () {
    videojs.log.warn('The errors.' + k + '() method is not available until the plugin has been initialized!');
  };
});

// Register the plugin with video.js.
registerPlugin('Errors', errors);

/**
 * @file reporter.js
 */
var Plugin$8 = videojs.getPlugin('plugin');
// cgi请求记录
var cgiSeq = {};
var STATUS_CODE_REPORT_URL = '//report.huatuo.qq.com/code.cgi';
// const METRICS_REPORT_URL = '//playerrpt.qcloud.com/index.php';
var log$7 = videojs.log;

var Reporter = function (_Plugin) {
  inherits(Reporter, _Plugin);

  /**
   * 上报插件
   */
  function Reporter(player, options) {
    classCallCheck(this, Reporter);

    log$7('Reporter initilaizing');

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    console.log('player', player);
    if (!player.options_.plugins.Reporter) {
      var _ret;

      console.log('reporter disabled');
      return _ret = false, possibleConstructorReturn(_this, _ret);
    }

    _this.reportContent = {
      status: 'idle'
    };

    _this.mtaReportCache = [];

    log$7('Reporter initilaized');
    return _this;
  }

  Reporter.prototype.setStorage = function setStorage(key, value) {
    localStorage.setItem(key, value);
  };

  Reporter.prototype.getStorage = function getStorage(key) {
    localStorage.getItem(key);
  };

  Reporter.prototype.sender = function sender(src) {
    var img = new Image();
    img.onload = img.onerror = img.onabort = function () {
      img.onload = img.onerror = img.onabort = null;
      img = null;
    };
    img.src = src;
  };

  /**
   * playcgi 返回码上报
   * 正常返回码
   * 异常返回码
   */


  Reporter.prototype.initPlayCgiCodeReport = function initPlayCgiCodeReport() {
    var player = this.player;
    player.on('playcgistart', videojs.bind(this, this.onPlayCgiStart));
    player.on('playcgiend', videojs.bind(this, this.onPlayCgiEnd));
  };

  Reporter.prototype.onPlayCgiStart = function onPlayCgiStart(event) {
    cgiSeq[event.data.time] = cgiSeq[event.data.time] || {};
    cgiSeq[event.data.time]['startTime'] = event.data.time;
    cgiSeq[event.data.time]['url'] = event.data.url;
  };

  /**
   * 播放质量指标上报多维
   * @param ars
   */


  Reporter.reportPlayMetrics = function reportPlayMetrics(args, cb) {
    xhr.post('https://datacenter.live.qcloud.com', {
      body: JSON.stringify(args)
    }, function () {
      cb && cb();
    });
  };

  /**
   * 接口响应后收集信息上报
   * 哈勃文档@http://tapd.oa.com/mhb/markdown_wikis/#1010084921005768665
   * @param event
   */


  Reporter.prototype.onPlayCgiEnd = function onPlayCgiEnd(event) {
    if (!cgiSeq[event.data.startTime]) {
      return;
    }
    // console.log('onPlayCgiEnd', cgiSeq);
    var data = event['data'],
        code = void 0,
        type = void 0,
        requestID = void 0,
        appID = void 0,
        fileID = void 0;
    if (!data['error']) {
      if (data.result.code == 0) {
        type = 1;
        code = 0;
      } else {
        type = 3;
        code = data.result.code;
      }
      requestID = data['result']['requestId'];
    } else {
      type = 2;
      switch (data['error'].message) {
        case 'Timeout':
          code = 10;
          break;
        case 'ServerError':
          code = 11;
          break;
      }
    }
    this.reportPlayCgiToISD('', '', type, code, event.data.time - cgiSeq[event.data.startTime]['startTime'], requestID, appID, fileID);
  };

  Reporter.prototype.reportPlayCgiToISD = function reportPlayCgiToISD(domain, cgi, type, code, time, requestID, appID, fileID) {
    var obj = {
      'domain': domain || 'playvideo.qcloud.com',
      'cgi': cgi || '/getplayinfo/v2',
      'type': type,
      'code': code,
      'time': time,
      'appid': 20370,
      'platform': videojs.browser.IS_IOS ? 'ios' : videojs.browser.IS_ANDROID ? 'android' : 'pc',
      'expansion1': requestID,
      'expansion2': appID,
      'expansion3': fileID
    };
    this.sender(unifyProtocol(STATUS_CODE_REPORT_URL) + '?' + serializeParams(obj));
  };

  Reporter.prototype.reportMTA = function reportMTA(name, params) {
    if (window.MtaH5) {
      if (this.mtaReportCache.length > 0) {
        this.mtaReportCache.forEach(function (item) {
          item.call();
        });
        this.mtaReportCache = 0;
      }
      MtaH5.clickStat(name, params);
    } else {
      this.mtaReportCache.push(function () {
        MtaH5.clickStat(name, params);
      });
    }
  };

  return Reporter;
}(Plugin$8);

videojs.registerPlugin('Reporter', Reporter);

var store2 = createCommonjsModule(function (module) {
/*! store2 - v2.12.0 - 2020-08-12
* Copyright (c) 2020 Nathan Bubna; Licensed (MIT OR GPL-3.0) */
(function(window, define) {
    var _ = {
        version: "2.12.0",
        areas: {},
        apis: {},

        // utilities
        inherit: function(api, o) {
            for (var p in api) {
                if (!o.hasOwnProperty(p)) {
                    Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(api, p));
                }
            }
            return o;
        },
        stringify: function(d) {
            return d === undefined || typeof d === "function" ? d+'' : JSON.stringify(d);
        },
        parse: function(s, fn) {
            // if it doesn't parse, return as is
            try{ return JSON.parse(s,fn||_.revive); }catch(e){ return s; }
        },

        // extension hooks
        fn: function(name, fn) {
            _.storeAPI[name] = fn;
            for (var api in _.apis) {
                _.apis[api][name] = fn;
            }
        },
        get: function(area, key){ return area.getItem(key); },
        set: function(area, key, string){ area.setItem(key, string); },
        remove: function(area, key){ area.removeItem(key); },
        key: function(area, i){ return area.key(i); },
        length: function(area){ return area.length; },
        clear: function(area){ area.clear(); },

        // core functions
        Store: function(id, area, namespace) {
            var store = _.inherit(_.storeAPI, function(key, data, overwrite) {
                if (arguments.length === 0){ return store.getAll(); }
                if (typeof data === "function"){ return store.transact(key, data, overwrite); }// fn=data, alt=overwrite
                if (data !== undefined){ return store.set(key, data, overwrite); }
                if (typeof key === "string" || typeof key === "number"){ return store.get(key); }
                if (typeof key === "function"){ return store.each(key); }
                if (!key){ return store.clear(); }
                return store.setAll(key, data);// overwrite=data, data=key
            });
            store._id = id;
            try {
                var testKey = '__store2_test';
                area.setItem(testKey, 'ok');
                store._area = area;
                area.removeItem(testKey);
            } catch (e) {
                store._area = _.storage('fake');
            }
            store._ns = namespace || '';
            if (!_.areas[id]) {
                _.areas[id] = store._area;
            }
            if (!_.apis[store._ns+store._id]) {
                _.apis[store._ns+store._id] = store;
            }
            return store;
        },
        storeAPI: {
            // admin functions
            area: function(id, area) {
                var store = this[id];
                if (!store || !store.area) {
                    store = _.Store(id, area, this._ns);//new area-specific api in this namespace
                    if (!this[id]){ this[id] = store; }
                }
                return store;
            },
            namespace: function(namespace, singleArea) {
                if (!namespace){
                    return this._ns ? this._ns.substring(0,this._ns.length-1) : '';
                }
                var ns = namespace, store = this[ns];
                if (!store || !store.namespace) {
                    store = _.Store(this._id, this._area, this._ns+ns+'.');//new namespaced api
                    if (!this[ns]){ this[ns] = store; }
                    if (!singleArea) {
                        for (var name in _.areas) {
                            store.area(name, _.areas[name]);
                        }
                    }
                }
                return store;
            },
            isFake: function(){ return this._area.name === 'fake'; },
            toString: function() {
                return 'store'+(this._ns?'.'+this.namespace():'')+'['+this._id+']';
            },

            // storage functions
            has: function(key) {
                if (this._area.has) {
                    return this._area.has(this._in(key));//extension hook
                }
                return !!(this._in(key) in this._area);
            },
            size: function(){ return this.keys().length; },
            each: function(fn, fill) {// fill is used by keys(fillList) and getAll(fillList))
                for (var i=0, m=_.length(this._area); i<m; i++) {
                    var key = this._out(_.key(this._area, i));
                    if (key !== undefined) {
                        if (fn.call(this, key, this.get(key), fill) === false) {
                            break;
                        }
                    }
                    if (m > _.length(this._area)) { m--; i--; }// in case of removeItem
                }
                return fill || this;
            },
            keys: function(fillList) {
                return this.each(function(k, v, list){ list.push(k); }, fillList || []);
            },
            get: function(key, alt) {
                var s = _.get(this._area, this._in(key)),
                    fn;
                if (typeof alt === "function") {
                    fn = alt;
                    alt = null;
                }
                return s !== null ? _.parse(s, fn) :
                    alt != null ? alt : s;
            },
            getAll: function(fillObj) {
                return this.each(function(k, v, all){ all[k] = v; }, fillObj || {});
            },
            transact: function(key, fn, alt) {
                var val = this.get(key, alt),
                    ret = fn(val);
                this.set(key, ret === undefined ? val : ret);
                return this;
            },
            set: function(key, data, overwrite) {
                var d = this.get(key);
                if (d != null && overwrite === false) {
                    return data;
                }
                return _.set(this._area, this._in(key), _.stringify(data), overwrite) || d;
            },
            setAll: function(data, overwrite) {
                var changed, val;
                for (var key in data) {
                    val = data[key];
                    if (this.set(key, val, overwrite) !== val) {
                        changed = true;
                    }
                }
                return changed;
            },
            add: function(key, data) {
                var d = this.get(key);
                if (d instanceof Array) {
                    data = d.concat(data);
                } else if (d !== null) {
                    var type = typeof d;
                    if (type === typeof data && type === 'object') {
                        for (var k in data) {
                            d[k] = data[k];
                        }
                        data = d;
                    } else {
                        data = d + data;
                    }
                }
                _.set(this._area, this._in(key), _.stringify(data));
                return data;
            },
            remove: function(key, alt) {
                var d = this.get(key, alt);
                _.remove(this._area, this._in(key));
                return d;
            },
            clear: function() {
                if (!this._ns) {
                    _.clear(this._area);
                } else {
                    this.each(function(k){ _.remove(this._area, this._in(k)); }, 1);
                }
                return this;
            },
            clearAll: function() {
                var area = this._area;
                for (var id in _.areas) {
                    if (_.areas.hasOwnProperty(id)) {
                        this._area = _.areas[id];
                        this.clear();
                    }
                }
                this._area = area;
                return this;
            },

            // internal use functions
            _in: function(k) {
                if (typeof k !== "string"){ k = _.stringify(k); }
                return this._ns ? this._ns + k : k;
            },
            _out: function(k) {
                return this._ns ?
                    k && k.indexOf(this._ns) === 0 ?
                        k.substring(this._ns.length) :
                        undefined : // so each() knows to skip it
                    k;
            }
        },// end _.storeAPI
        storage: function(name) {
            return _.inherit(_.storageAPI, { items: {}, name: name });
        },
        storageAPI: {
            length: 0,
            has: function(k){ return this.items.hasOwnProperty(k); },
            key: function(i) {
                var c = 0;
                for (var k in this.items){
                    if (this.has(k) && i === c++) {
                        return k;
                    }
                }
            },
            setItem: function(k, v) {
                if (!this.has(k)) {
                    this.length++;
                }
                this.items[k] = v;
            },
            removeItem: function(k) {
                if (this.has(k)) {
                    delete this.items[k];
                    this.length--;
                }
            },
            getItem: function(k){ return this.has(k) ? this.items[k] : null; },
            clear: function(){ for (var k in this.items){ this.removeItem(k); } }
        }// end _.storageAPI
    };

    var store =
        // safely set this up (throws error in IE10/32bit mode for local files)
        _.Store("local", (function(){try{ return localStorage; }catch(e){}})());
    store.local = store;// for completeness
    store._ = _;// for extenders and debuggers...
    // safely setup store.session (throws exception in FF for file:/// urls)
    store.area("session", (function(){try{ return sessionStorage; }catch(e){}})());
    store.area("page", _.storage("page"));

    if (typeof define === 'function' && define.amd !== undefined) {
        define('store2', [], function () {
            return store;
        });
    } else if ('object' !== 'undefined' && module.exports) {
        module.exports = store;
    } else {
        // expose the primary store fn to the global object and save conflicts
        if (window.store){ _.conflict = window.store; }
        window.store = store;
    }

})(commonjsGlobal, commonjsGlobal && commonjsGlobal.define);
});

/**
 * @file continue-playback.js
 */
var Plugin$9 = videojs.getPlugin('plugin');
var log$8 = videojs.log;
// const log = console.log;
/**
 * 续播插件
 * 在视频开始播放后，只要触发timeupdate就记录一次视频的currentTime
 *
 */

var ContinuePlay = function (_Plugin) {
  inherits(ContinuePlay, _Plugin);

  /**
   *
   * @param player
   * @param options
   *  auto 视频播放后 是否自动续播
   *  text:'上次播放至 ', // 提示文案
   *  btnText: '恢复播放' // 按钮文案
   */
  function ContinuePlay(player, options) {
    classCallCheck(this, ContinuePlay);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    _this.init();
    return _this;
  }

  ContinuePlay.prototype.init = function init() {
    var player = this.player;
    var playerOptions = player.options_;
    var playID = void 0;
    player.ready(videojs.bind(this, function () {
      if (playerOptions && playerOptions.appID && playerOptions.fileID) {
        playID = playerOptions.fileID;
      } else {
        playID = this.options['playID'];
      }
      this.playID = playID;

      // 以url形式播放时，支持断点续播
      if (player.cache_ && player.cache_.source && player.cache_.source.src) {
        this.source = player.cache_.source.src.split('?')[0];
      }

      if (playID || this.source) {
        log$8('ContinuePlay initializing');
        // this.playID = playID;
        this.lastTime = store2.get(this.getStoreKey());
        // 重复初始化时需先解绑
        player.off('timeupdate', videojs.bind(this, this.onTimeUpdate));
        player.on('timeupdate', videojs.bind(this, this.onTimeUpdate));
        // Flash 非自动播放时，会先触发loadedmetadata
        // let event = this.options.auto && !videojs.browser.IS_IOS && !videojs.browser.IS_ANDROID || player.techName_ == 'Flash' ? 'loadedmetadata' : 'playing';
        player.one(this.getTriggerEvent(), videojs.bind(this, this.onPlay));
        // player.one('playing', videojs.bind(this, this.onPlay));
        // 重复初始化时重置
        if (!this.options.auto && player.getChild('ContinuePlayTips')) {
          player.getChild('ContinuePlayTips').close();
        }
        log$8('ContinuePlay initialized');
        player.trigger({ type: 'feature', data: 'continue' });
      }
    }));
  };

  ContinuePlay.prototype.onTimeUpdate = function onTimeUpdate(event) {
    store2.set(this.getStoreKey(), this.player.currentTime());
  };

  ContinuePlay.prototype.onPlay = function onPlay(event) {
    var player = this.player;
    console.log('last time play at ' + this.lastTime, this.player.duration(), !this.player.duration(), _typeof(this.player.duration()), event);
    if (Math.round(this.lastTime) > 1 && this.player.duration() > 1 && this.player.duration() !== Infinity && Math.round(this.lastTime) != Math.round(this.player.duration())) {
      if (this.options.auto) {
        console.log('auto start', this.lastTime);
        this.start();
      } else {
        // console.log('显示提示，在提示层点击触发调用 start()');
        // 显示提示，在提示层点击触发调用 start()
        player.addChild('ContinuePlayTips', videojs.mergeOptions(this.options, {
          time: this.lastTime,
          resumeCallback: videojs.bind(this, this.start)
        }));
      }
    } else {
      if (player.techName_ == 'Flash' && Math.round(this.lastTime) > 1 && Math.round(this.lastTime) != Math.round(this.player.duration()) && this.player.duration() !== Infinity && !this.player.duration()) {
        //Flash 播放时拿不到视频的duration, 重新绑定
        player.one('loadedmetadata', videojs.bind(this, this.onPlay));
      }
    }
  };

  ContinuePlay.prototype.start = function start() {
    var player = this.player;
    player.currentTime(this.lastTime);
    if (player.techName_ == 'Flash') {
      player.tech(true).trigger('seeked');
    }
    player.trigger({ type: 'continueplay', data: { lastTime: this.lastTime } });
  };

  ContinuePlay.prototype.generatePlayID = function generatePlayID() {};

  ContinuePlay.prototype.getStoreKey = function getStoreKey() {
    return 'tcplayer-lpt-' + (this.playID || this.source);
  };

  ContinuePlay.prototype.getTriggerEvent = function getTriggerEvent() {
    var player = this.player,
        playerOptions = player.options_,
        eventName = void 0;

    // Flash 自动播放时 会先触发playing ，这时拿不到视频的duration
    // Flash 非自动播放时，正常情况会先触发loadedmetadata， 如果快速点击播放，playing事件可能先触发，这时拿不到duration
    // android 如果视频未播放（未触发playing），可以设置 currentTime 并触发 seeking 事件，但是不会触发 seeked 事件
    // android x5微信，设置自动播放，会触发loadedmetadata playing，但是不会播放, 如果设置currentTime会触发seeking，但是不会触发seeked
    // ios 如果视频未播放（未触发playing），会触发loadedmetadata， 设置 currentTime 无效 ，不会触发 seeking 事件
    // ios 微信视频未播放，不触发任何视频事件

    if (playerOptions.autoplay && player.techName_ == 'Flash') {
      eventName = 'loadedmetadata';
    } else {
      eventName = 'playing';
    }
    return eventName;
  };

  return ContinuePlay;
}(Plugin$9);

videojs.registerPlugin('ContinuePlay', ContinuePlay);

/**
 * @file patch.js
 * TODO 需重构
 */
var defaults$2 = {
  align: 'top-left',
  className: '',
  content: '',
  debug: false,
  showBackground: true,
  attachToControlBar: false,
  overlays: []
};

var Component$12 = videojs.getComponent('Component');

var dom$1 = videojs.dom || videojs;
var registerPlugin$1 = videojs.registerPlugin || videojs.plugin;

/**
 * Whether the value is a `Number`.
 *
 * Both `Infinity` and `-Infinity` are accepted, but `NaN` is not.
 *
 * @param  {Number} n
 * @return {Boolean}
 */

/* eslint-disable no-self-compare */
var isNumber = function isNumber(n) {
  return typeof n === 'number' && n === n;
};
/* eslint-enable no-self-compare */

/**
 * Whether a value is a string with no whitespace.
 *
 * @param  {String} s
 * @return {Boolean}
 */
var hasNoWhitespace = function hasNoWhitespace(s) {
  return typeof s === 'string' && /^\S+$/.test(s);
};

/**
 * Overlay component.
 *
 * @class   Overlay
 * @extends {videojs.Component}
 */

var Overlay = function (_Component) {
  inherits(Overlay, _Component);

  function Overlay(player, options) {
    classCallCheck(this, Overlay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    ['start', 'end'].forEach(function (key) {
      var value = _this.options_[key];

      if (isNumber(value)) {
        _this[key + 'Event_'] = 'timeupdate';
      } else if (hasNoWhitespace(value)) {
        _this[key + 'Event_'] = value;

        // An overlay MUST have a start option. Otherwise, it's pointless.
      } else if (key === 'start') {
        throw new Error('invalid "start" option; expected number or string');
      }
    });

    // video.js does not like components with multiple instances binding
    // events to the player because it tracks them at the player level,
    // not at the level of the object doing the binding. This could also be
    // solved with Function.prototype.bind (but not videojs.bind because of
    // its GUID magic), but the anonymous function approach avoids any issues
    // caused by crappy libraries clobbering Function.prototype.bind.
    // - https://github.com/videojs/video.js/issues/3097
    ['endListener_', 'rewindListener_', 'startListener_'].forEach(function (name) {
      _this[name] = function (e) {
        return Overlay.prototype[name].call(_this, e);
      };
    });

    // If the start event is a timeupdate, we need to watch for rewinds (i.e.,
    // when the user seeks backward).
    if (_this.startEvent_ === 'timeupdate') {
      _this.on(player, 'timeupdate', _this.rewindListener_);
    }
    _this.debug('created, listening to "' + _this.startEvent_ + '" for "start" and "' + (_this.endEvent_ || 'nothing') + '" for "end"');

    _this.hide();
    return _this;
  }

  Overlay.prototype.createEl = function createEl() {
    var options = this.options_;
    var content = options.content;

    var background = options.showBackground ? 'tcp-overlay-background' : 'tcp-overlay-no-background';
    var el = dom$1.createEl('div', {
      className: '\n        tcp-overlay\n        tcp-overlay-' + options.align + '\n        ' + options.className + '\n        ' + background + '\n        vjs-hidden\n      '
    });

    if (typeof content === 'string') {
      el.innerHTML = content;
    } else if (videojs.browser.IS_IE8 || content instanceof window_1.DocumentFragment) {
      el.appendChild(content);
    } else {
      dom$1.appendContent(el, content);
    }

    return el;
  };

  /**
   * Logs debug errors
   * @param  {...[type]} args [description]
   * @return {[type]}         [description]
   */


  Overlay.prototype.debug = function debug() {
    if (!this.options_.debug) {
      return;
    }

    var log = videojs.log;
    var fn = log;

    // Support `videojs.log.foo` calls.

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (log.hasOwnProperty(args[0]) && typeof log[args[0]] === 'function') {
      fn = log[args.shift()];
    }

    fn.apply(undefined, ['overlay#' + this.id() + ': '].concat(args));
  };

  /**
   * Overrides the inherited method to perform some event binding
   *
   * @return {Overlay}
   */


  Overlay.prototype.hide = function hide() {
    _Component.prototype.hide.call(this);

    this.debug('hidden');
    this.debug('bound `startListener_` to "' + this.startEvent_ + '"');

    // Overlays without an "end" are valid.
    if (this.endEvent_) {
      this.debug('unbound `endListener_` from "' + this.endEvent_ + '"');
      this.off(this.player(), this.endEvent_, this.endListener_);
    }
    // console.log('has start',this.player().hasStarted());
    if (this.options_['once']) {
      // 只显示一次，只用在片头贴片的情况，this.startEvent_ 为 loadstart 等未播放前的事件, 已标记开始播放的播放器，不再显示片头贴片
      if (videojs.browser.IS_IOS && videojs.browser.IS_WECHAT) {
        // iOS 微信 video初始化时不会触发任何video事件
        if (!this.player().hasStarted()) {
          this.player().ready(videojs.bind(this, function () {
            this.startListener_({ type: this.startEvent_ });
          }));
        }
      } else if (!this.player().hasStarted()) {
        //未开始播放
        this.on(this.player(), this.startEvent_, this.startListener_);
      }
      return this;
    }
    // 暂停时显示的处理逻辑，避免由于seek 和 ended 触发pause 而显示
    if (this.startEvent_ === 'pause') {
      // this.on(this.player(), 'click', this.startOnPause_);
      this.on(this.player(), this.startEvent_, this.startOnPause_);
    } else {
      this.on(this.player(), this.startEvent_, this.startListener_);
    }
    return this;
  };

  Overlay.prototype.startOnPause_ = function startOnPause_(event) {
    var player = this.player();
    // console.log(event.type, player.paused(), player.seeking(), player.ended());
    if (event.type === 'pause') {
      // pause 有可能是 seek 或者 ended 之前触发的
      if (!player.seeking() && !player.ended()) {
        this.startListener_({ type: 'pause' });
      }
    } else {
      if (player.paused()) {
        this.startListener_({ type: 'pause' });
      }
    }
  };

  /**
   * Determine whether or not the overlay should hide.
   *
   * @param  {Number} time
   *         The current time reported by the player.
   * @param  {String} type
   *         An event type.
   * @return {Boolean}
   */


  Overlay.prototype.shouldHide_ = function shouldHide_(time, type) {
    var end = this.options_.end;

    return isNumber(end) ? time >= end : end === type;
  };

  /**
   * Overrides the inherited method to perform some event binding
   *
   * @return {Overlay}
   */


  Overlay.prototype.show = function show() {
    _Component.prototype.show.call(this);
    if (this.startEvent_ === 'pause') {
      // this.off(this.player(), 'click', this.startOnPause_);
      this.off(this.player(), this.startEvent_, this.startOnPause_);
    }
    this.off(this.player(), this.startEvent_, this.startListener_);

    this.debug('shown');
    this.debug('unbound `startListener_` from "' + this.startEvent_ + '"');

    // Overlays without an "end" are valid.
    if (this.endEvent_) {
      this.debug('bound `endListener_` to "' + this.endEvent_ + '"');
      this.on(this.player(), this.endEvent_, this.endListener_);
    }

    return this;
  };

  /**
   * Determine whether or not the overlay should show.
   *
   * @param  {Number} time
   *         The current time reported by the player.
   * @param  {String} type
   *         An event type.
   * @return {Boolean}
   */


  Overlay.prototype.shouldShow_ = function shouldShow_(time, type) {
    var start = this.options_.start;
    var end = this.options_.end;

    if (isNumber(start)) {

      if (isNumber(end)) {
        return time >= start && time < end;

        // In this case, the start is a number and the end is a string. We need
        // to check whether or not the overlay has shown since the last seek.
      } else if (!this.hasShownSinceSeek_) {
        this.hasShownSinceSeek_ = true;
        return time >= start;
      }

      // In this case, the start is a number and the end is a string, but
      // the overlay has shown since the last seek. This means that we need
      // to be sure we aren't re-showing it at a later time than it is
      // scheduled to appear.
      return Math.floor(time) === start;
    }

    return start === type;
  };

  /**
   * Event listener that can trigger the overlay to show.
   *
   * @param  {Event} e
   */


  Overlay.prototype.startListener_ = function startListener_(e) {
    var time = this.player().currentTime();

    if (this.shouldShow_(time, e.type)) {
      this.show();
    }
  };

  /**
   * Event listener that can trigger the overlay to show.
   *
   * @param  {Event} e
   */


  Overlay.prototype.endListener_ = function endListener_(e) {
    var time = this.player().currentTime();

    if (this.shouldHide_(time, e.type)) {
      this.hide();
    }
  };

  /**
   * Event listener that can looks for rewinds - that is, backward seeks
   * and may hide the overlay as needed.
   *
   * @param  {Event} e
   */


  Overlay.prototype.rewindListener_ = function rewindListener_(e) {
    var time = this.player().currentTime();
    var previous = this.previousTime_;
    var start = this.options_.start;
    var end = this.options_.end;

    // Did we seek backward?
    if (time < previous) {
      this.debug('rewind detected');

      // The overlay remains visible if two conditions are met: the end value
      // MUST be an integer and the the current time indicates that the
      // overlay should NOT be visible.
      if (isNumber(end) && !this.shouldShow_(time)) {
        this.debug('hiding; ' + end + ' is an integer and overlay should not show at this time');
        this.hasShownSinceSeek_ = false;
        this.hide();

        // If the end value is an event name, we cannot reliably decide if the
        // overlay should still be displayed based solely on time; so, we can
        // only queue it up for showing if the seek took us to a point before
        // the start time.
      } else if (hasNoWhitespace(end) && time < start) {
        this.debug('hiding; show point (' + start + ') is before now (' + time + ') and end point (' + end + ') is an event');
        this.hasShownSinceSeek_ = false;
        this.hide();
      }
    }

    this.previousTime_ = time;
  };

  return Overlay;
}(Component$12);

videojs.registerComponent('Overlay', Overlay);

/**
 * Initialize the plugin.
 *
 * @function plugin
 * @param    {Object} [options={}]
 */
var plugin = function plugin(options) {
  var _this2 = this;

  var settings = videojs.mergeOptions(defaults$2, options);

  // De-initialize the plugin if it already has an array of overlays.
  if (Array.isArray(this.overlays_)) {
    this.overlays_.forEach(function (overlay) {
      _this2.removeChild(overlay);
      if (_this2.controlBar) {
        _this2.controlBar.removeChild(overlay);
      }
      overlay.dispose();
    });
  }

  var overlays = settings.overlays;

  // We don't want to keep the original array of overlay options around
  // because it doesn't make sense to pass it to each Overlay component.
  delete settings.overlays;

  this.overlays_ = overlays.map(function (o) {
    var mergeOptions = videojs.mergeOptions(settings, o);

    // Attach bottom aligned overlays to the control bar so
    // they will adjust positioning when the control bar minimizes
    if (mergeOptions.attachToControlBar && _this2.controlBar && mergeOptions.align.indexOf('bottom') !== -1) {
      return _this2.controlBar.addChild('overlay', mergeOptions);
    }

    return _this2.addChild('overlay', mergeOptions);
  });
};

// plugin.VERSION = '__VERSION__';

registerPlugin$1('Patch', plugin);

/**
 * @file image-patch.js
 */
var Plugin$10 = videojs.getPlugin('plugin');
var log$9 = videojs.log;
// const log = console.log;
var locations = ['start', 'pause', 'ended'];
var startEvent = ['loadstart', 'pause', 'ended'];
var endEvent = ['play', 'play', 'play'];

var ImagePatch = function (_Plugin) {
  inherits(ImagePatch, _Plugin);

  function ImagePatch(player, options) {
    classCallCheck(this, ImagePatch);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player, options));

    _this.hasInit = false;
    _this.init(options);
    return _this;
  }

  /**
   *  data item{
   *    link: 跳转链接
   *    location: 片头 暂停 片尾
   *    type: 暂无用处
   *    url: 图片地址
   *  }
   * @param data Array
   */


  ImagePatch.prototype.init = function init(data) {
    var _this2 = this;

    var player = this.player,
        patchData = {
      showBackground: false,
      overlays: []
    },
        self = this;
    if (Array.isArray(data) && data.length > 0) {
      log$9('ImagePatch initializing');
      data.forEach(function (item) {
        var wrap = void 0,
            cell = void 0,
            a = void 0,
            img = void 0,
            fragment = document.createDocumentFragment();
        a = document.createElement('a');
        a.className = 'tcp-overlay-link';
        a.target = '_blank';
        if (item.link) {
          a.href = item.link;
        }
        if (item.url) {
          img = _this2.loadImg(unifyProtocol(item.url), videojs.bind(_this2, _this2.onImgLoaded));
          img.className = 'tcp-overlay-img';

          a.appendChild(img);

          if (videojs.browser.IS_IE8) {
            wrap = document.createElement('div');
            wrap.className = 'tcp-overlay-table';
            cell = document.createElement('div');
            cell.className = 'tcp-overlay-cell';
            cell.appendChild(a);
            wrap.appendChild(cell);
            fragment.appendChild(wrap);
          } else {
            fragment.appendChild(a);
          }

          patchData.overlays.push({
            content: fragment,
            className: 'tcp-image-patch tcp-image-patch-' + locations[item.location],
            start: startEvent[item.location],
            end: endEvent[item.location],
            once: item.location == 0,
            align: 'center'
          });
        }
      });
      if (patchData.overlays.length > 0) {
        player.Patch(patchData);
        player.trigger({ type: 'feature', data: 'patch' });
        this.hasInit = true;
      } else {
        this.reset();
      }
      log$9('ImagePatch initialized');
    }

    // this.loadImg(data[0]['url'], function(){
    //   console.log(this.width, this.height);
    // });
  };

  ImagePatch.prototype.loadImg = function loadImg(url, ready) {
    var _onReady,
        width,
        height,
        newWidth,
        newHeight,
        img = new Image();

    img.src = url;

    // 如果图片被缓存，则直接返回缓存数据
    if (img.complete) {
      ready && ready.call(ready, img);
      return img;
    }

    width = img.width;
    height = img.height;

    // 加载错误后的事件
    img.onerror = function () {
      _onReady.end = true;
      img = img.onload = img.onerror = null;
    };

    // 图片尺寸就绪
    _onReady = function onReady() {
      newWidth = img.width;
      newHeight = img.height;
      if (newWidth !== width || newHeight !== height ||
      // 如果图片已经在其他地方加载可使用面积检测
      newWidth * newHeight > 1024) {
        ready && ready.call(ready, img);
        _onReady.end = true;
      }
    };
    _onReady();

    // 完全加载完毕的事件
    img.onload = function () {
      // onload在定时器时间差范围内可能比onready快
      // 这里进行检查并保证onready优先执行
      !_onReady.end && _onReady();

      // IE gif动画会循环执行onload，置空onload即可
      img = img.onload = img.onerror = null;
    };

    return img;
  };

  ImagePatch.prototype.onImgLoaded = function onImgLoaded(img) {
    // console.log('img load', img.width, img);
    // console.log('img load', img);
    if (videojs.browser.IE_VERSION) {
      // IE 图片如果设置css width 100% 会以原始尺寸进行渲染，而不是容器宽度，且获取图片尺寸为100，不是原始尺寸
      var containerWidth = parseInt(this.player.el().currentStyle.width),
          containerHeight = parseInt(this.player.el().currentStyle.height);
      if (img.width > containerWidth || img.height > containerHeight) {
        // ie 图片高度超过容器的情况，让图片垂直居中
        var height = containerWidth / (img.width / img.height);
        // console.log(containerWidth, img.width, img.height);
        if (img.width / img.height > containerWidth / containerHeight) {
          // 等宽情况下 图片高小于播放器高
          // img.style.marginTop = (containerHeight - height) / 2 + 'px';
        } else {
          // 等宽的情况下 图片高大于播放器高
          img.style.marginTop = (containerHeight - height) / 2 + 'px';
        }
        // IE 图片超过容器需要显示完全图片，设置后img.width 获取的值为100
        img.style.width = '100%';
        img.style.height = 'auto';
      }
    }
  };

  ImagePatch.prototype.reset = function reset() {
    if (this.hasInit) {
      log$9('ImagePatch reset');
      this.player.Patch();
      this.hasInit = false;
    }
  };

  return ImagePatch;
}(Plugin$10);

videojs.registerPlugin('ImagePatch', ImagePatch);

/**
 * @file context-menu.js
 */

var Plugin$11 = videojs.getPlugin('plugin');
var log$10 = videojs.log;

var ContextMenu = function (_Plugin) {
  inherits(ContextMenu, _Plugin);

  function ContextMenu(player, options) {
    classCallCheck(this, ContextMenu);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    log$10('ContextMenu initializing');
    _this.init();
    log$10('ContextMenu initialized');
    return _this;
  }

  ContextMenu.prototype.init = function init() {
    var player = this.player;
    player.addChild('RightClickPopupMenu', this.options);
  };

  return ContextMenu;
}(Plugin$11);

videojs.registerPlugin('ContextMenu', ContextMenu);

/**
 * @file level-switch.js
 */

var Plugin$12 = videojs.getPlugin('plugin');
var LevelSwitch = function (_Plugin) {
  inherits(LevelSwitch, _Plugin);

  function LevelSwitch(player, options) {
    classCallCheck(this, LevelSwitch);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    _this.init();
    return _this;
  }

  LevelSwitch.prototype.init = function init() {
    var player = this.player;
    var contextMenu = player.options_.plugins.ContextMenu;
    if (contextMenu && contextMenu.levelSwitch && contextMenu.levelSwitch.open) {
      player.addChild('LevelSwitchTips', this.options);
    }
  };

  return LevelSwitch;
}(Plugin$12);

videojs.registerPlugin('LevelSwitch', LevelSwitch);

/**
 * @file vtt-thumbnail.js
 */
var Plugin$13 = videojs.getPlugin('plugin');
var log$12 = videojs.log;
var defaults$3 = {
  width: 0, height: 0, basePath: ""
};

var VttThumbnail = function (_Plugin) {
  inherits(VttThumbnail, _Plugin);

  /**
   *
   * @param player
   * @param options
   *
   * vttUrl vtt文件绝对地址 必传
   * basePath 图片路径 非必须，不传时使用vttUrl的path
   * imgUrl 图片绝对地址 非必须
   *
   */
  function VttThumbnail(player, options) {
    classCallCheck(this, VttThumbnail);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.hasInit = false;
    if (options['vttUrl']) {
      player.ready(videojs.bind(_this, function () {
        this.init(options);
      }));
    }
    return _this;
  }

  VttThumbnail.prototype.loadTrackFile = function loadTrackFile(options) {
    var self = this,
        player = this.player;
    // 动态创建 track 需要 track 触发load事件后才能获取track的内容，才能开始初始化。
    var thumbnailTrack = player.addRemoteTextTrack({ src: options['vttUrl'], kind: 'metadata' }, true);
    thumbnailTrack && thumbnailTrack.addEventListener('load', function () {
      // self.initTrackFile(thumbnailTrack);
      self.trackInfo = thumbnailTrack;
    });
  };

  VttThumbnail.prototype.init = function init(options) {
    if (videojs.browser.IS_IOS || videojs.browser.IS_ANDROID || !this.player.controlBar || !this.player.controlBar.progressControl) {
      // 移动端目前无法不支持
      return;
    }
    log$12('VttThumbnail initializing', options);
    if (!this.player.controlBar) {
      log$12('VttThumbnail can not initialize without control bar');
      return;
    }
    this.options = options;
    var player = this.player;
    var progerssControl = player.controlBar.progressControl;

    // 获取webvtt 配置  异步
    this.loadTrackFile(options);
    // 获取basePath
    defaults$3.basePath = parseBasePath(options['vttUrl']);

    // 初始化显示组件 同步
    this.initUI();
    // 进度条 hover 事件处理
    progerssControl.on('mouseenter', videojs.bind(this, this.onMouseEnter));
    progerssControl.on('mousemove', videojs.bind(this, this.onMouseMove));
    progerssControl.on('mouseleave', videojs.bind(this, this.onMouseOut));
    this.hasInit = true;
    log$12('VttThumbnail initialized');
    // this.player.on('userinactive', videojs.bind(this, this.onMouseOut));
    player.trigger({ type: 'feature', data: 'thumbnail' });
  };

  VttThumbnail.prototype.initTrackFile = function initTrackFile(thumbnailTrack) {
    // 解析 vtt
    var track = thumbnailTrack.track;
    this.trackInfo = thumbnailTrack;
  };

  VttThumbnail.prototype.initUI = function initUI() {
    var div = videojs.dom.createEl('div', {
      className: 'tcp-vtt-thumbnail-container'
    }),
        img = videojs.dom.createEl('img', {
      className: 'tcp-vtt-thumbnail-img'
    });
    div.appendChild(img);
    this.containerEl = div;
    this.imgEl = img;
    this.player.controlBar.progressControl.el().appendChild(div);
  };

  VttThumbnail.prototype.onMouseEnter = function onMouseEnter() {
    this.containerEl.style.display = 'block';
  };

  VttThumbnail.prototype.onMouseMove = function onMouseMove(event) {
    if (!this.trackInfo) {
      return false;
    }
    // 当鼠标在进度条上移动时, 计算预览图片需要截取的区域，以及显示的坐标，坐标相对播放器左顶点
    var eventX = void 0,
        left = void 0,
        progressControl = void 0,
        seekBar = void 0,
        progressControlRect = void 0,
        seekBarRect = void 0,
        clientRect = void 0,
        hoverTime = void 0,
        duration = void 0,
        i = 0,
        track = void 0,
        cue = void 0,
        setting = void 0,
        leftShift = void 0;
    progressControl = this.player.controlBar.progressControl;
    seekBar = this.player.controlBar.progressControl.seekBar;
    progressControlRect = offsetParent(progressControl.el()).getBoundingClientRect();
    seekBarRect = offsetParent(seekBar.el()).getBoundingClientRect();
    eventX = event.clientX;

    duration = this.player.duration();
    // 鼠标所处位置对应的
    hoverTime = ((eventX - seekBarRect.left) / seekBar.width() * duration).toFixed(3);
    // 查找对应的vtt区间内的配置。移动端this.trackInfo没有track属性。
    track = this.trackInfo['track'] || this.trackInfo;
    while (i < track.cues.length) {
      cue = track.cues[i];
      if (cue.startTime <= hoverTime && cue.endTime >= hoverTime) {
        setting = parseImageLink(cue.text);
        break;
      }
      i++;
    }
    if (!setting) {
      this.onMouseOut();
      return false;
    }
    // 计算超出容器的宽度
    leftShift = eventX - seekBarRect.left + setting['w'] / 2 - seekBar.width();
    leftShift = Math.max(0, leftShift);
    // 计算偏移量
    left = eventX - progressControlRect.left - setting['w'] / 2 - leftShift;
    // console.log('cal ', left, leftShift, eventX, seekBarRect, seekBar.width(), seekBarRect.left, setting['w']);
    left = Math.max(seekBar.el().offsetLeft, left);
    setting['left'] = left;
    this.setView(setting);
  };

  VttThumbnail.prototype.onMouseOut = function onMouseOut() {
    this.containerEl.style.display = 'none';
  };

  VttThumbnail.prototype.setView = function setView(setting) {
    var containerEl = this.containerEl;
    var imgEl = this.imgEl;
    var options = this.options;
    if (containerEl.style.width != setting.w || containerEl.style.height != setting.h) {
      containerEl.style.width = setting.w + 'px';
      containerEl.style.height = setting.h + 'px';
    }
    containerEl.style.left = setting.left + 'px';
    if (options.imgUrl && imgEl.src != options.imgUrl) {
      imgEl.src = options.imgUrl;
    } else {
      imgEl.src = setting.src;
    }
    imgEl.style.left = -setting.x + 'px';
    imgEl.style.top = -setting.y + 'px';
    imgEl.style.clip = 'rect(' + setting.y + 'px,' + (setting.w + setting.x) + 'px,' + (setting.y + setting.h) + 'px,' + setting.x + 'px)';
  };

  VttThumbnail.prototype.reset = function reset() {
    if (this.hasInit) {
      log$12('VttThumbnail reset');
      var player = this.player;
      var progerssControl = player.controlBar.progressControl;
      progerssControl.off('mousemove', videojs.bind(this, this.onMouseMove));
      progerssControl.off('mouseleave', videojs.bind(this, this.onMouseOut));
      this.hasInit = false;
    }
  };

  return VttThumbnail;
}(Plugin$13);

var getComputedStyle = function getComputedStyle(el, pseudo) {
  return function (prop) {
    if (window.getComputedStyle) {
      return window.getComputedStyle(el, pseudo)[prop];
    } else {
      return el.currentStyle[prop];
    }
  };
};
var offsetParent = function offsetParent(el) {
  if (el.nodeName !== 'HTML' && getComputedStyle(el)('position') === 'static') {
    return offsetParent(el.offsetParent);
  }
  return el;
};
var parseImageLink = function parseImageLink(imglocation) {
  var lsrc = void 0,
      clip = void 0,
      hashindex = void 0,
      hashstring = void 0;
  hashindex = imglocation.indexOf('#');
  if (hashindex === -1) {
    return { src: imglocation, w: 0, h: 0, x: 0, y: 0 };
  }
  lsrc = imglocation.substring(0, hashindex);
  // 图片URL可能是绝对地址或者相对地址，这里需要增加处理绝对地址的情况
  if (!/^(http:|https:|\/\/)/.test(lsrc)) {
    lsrc = defaults$3.basePath + lsrc;
  }
  hashstring = imglocation.substring(hashindex + 1);
  if (hashstring.substring(0, 5) !== 'xywh=') {
    return { src: lsrc, w: 0, h: 0, x: 0, y: 0 };
  }
  var data = hashstring.substring(5).split(',');
  return {
    src: lsrc,
    w: parseInt(data[2]),
    h: parseInt(data[3]),
    x: parseInt(data[0]),
    y: parseInt(data[1])
  };
};
var parseBasePath = function parseBasePath(url) {
  if (/^(\/\/)/.test(url)) {
    url = 'https:' + url;
  }
  var re = /(\w+):\/\/([^\:|\/]+)(\:\d*)?(.*\/)([^#|\?|\n]+)?(#.*)?(\?.*)?/i;
  var arr = url.match(re);
  if (arr && arr[2] && arr[4]) {
    return '//' + arr[2] + arr[4];
  }
};

videojs.registerPlugin('VttThumbnail', VttThumbnail);

/**
 * @file player-metrics.js
 */
var Plugin$14 = videojs.getPlugin('plugin');
var log$13 = videojs.log;

/**
 * 播放器数据收集插件 系统 浏览器 播放器版本
 * 上报时机：
 * 首次播放时上报
 * appID, fileID, 播放流水号，userAgent, location.href, Timing(首播耗时，播放次数+1，播放失败+[1])
 *
 * 出现error时上报
 * appID, fileID, 播放流水号，errorCode(log，播放时长(观看多少s))
 *
 * 播放结束时上报
 * appID, fileID, 播放流水号，lagStatus(卡顿总时长，播放时长)
 */

/**
 * 上报协议
 * 点播场景 40303 开始 40304 结束 40305 区间
 * 
 * 直播场景 40101 40102 40100
 * https://docs.qq.com/sheet/DRndZakFpTUhVRHBJ?tab=BB08J3
 *
 * 通过fileid播放，上报到点播协议
 * 通过url播放，且 duration 有限，上报到点播协议
 * 通过url播放，且 duration 无限，上报到直播协议
 * 快直播场景，监听txliveplayer的事件回调，复用直播协议
 */

var PlayerMetrics = function (_Plugin) {
  inherits(PlayerMetrics, _Plugin);

  function PlayerMetrics(player, options) {
    classCallCheck(this, PlayerMetrics);

    log$13('PlayerMetrics initializing');

    // 禁止上报的配置
    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    if (player.options_.reportable === false) {
      var _ret;

      return _ret = false, possibleConstructorReturn(_this, _ret);
    }
    _this.player = player;
    _this.checkPrevData();
    _this.initData();
    _this.registerListener();
    log$13('PlayerMetrics initialized');
    return _this;
  }

  // 检查是否有上次遗留的播放数据，如有的话发起上报，并清理本地数据


  PlayerMetrics.prototype.checkPrevData = function checkPrevData() {
    var tcplayerDataInLocal = localStorage.getItem('tcplayer_data');
    if (tcplayerDataInLocal) {
      var tcplayerData = JSON.parse(tcplayerDataInLocal);
      Reporter.reportPlayMetrics(tcplayerData, function () {
        localStorage.removeItem('tcplayer_data');
      });
    }
  };

  PlayerMetrics.prototype.initData = function initData() {
    // 公共参数 每次上报都需要
    // 标识此次播放行为
    this.bytes_token = guid();
    this.vodBaseData = {
      uint32_service: 2, // 1: 直播、2: 点播 duration 为 infinity 时为直播
      uint32_platform: 3, // 3 web
      bytes_version: String(version),
      uint64_appid: 0, // app唯一标识
      bytes_bizid: this.guid('dev_uuid'), // 身份唯一标识
      bytes_stream_id: '',
      uint32_module_id: 1011, // 固定
      uint32_data_type: 1, // 事件数据为1，区间统计数据为2
      uint32_command: 40303, // 40303 开始 40304 结束 40305 区间
      uint64_data_time: 0, // 对于事件数据，代表产生数据的时间点
      bytes_token: this.bytes_token, // 标志此次播放行为
      token: this.bytes_token,
      dev_uuid: this.guid('dev_uuid'),
      str_app_name: '', // web端无此数据
      str_app_version: '', // web端无此数据
      str_stream_url: '',
      str_brand_type: this.getDevice(), // 手机品牌，仅能粗略估计，不同浏览器的ua不一定能解析出型号
      str_device_resolution: screen.width + '_' + screen.height,
      str_device_type: '',
      str_package_name: '',
      str_sdk_name: 'TCPlayer',
      str_user_id: this.guid('dev_uuid'),
      // 新增
      sys_type: this.getSystem(),
      sys_version: String(this.getSystemVer()),
      // ua 
      str_user_agent: USER_AGENT,
      // 浏览器版本
      str_browser_version: String(this.getBrowserVer()),
      // 浏览器类型
      str_browser_model: String(this.getBrowser()),
      u32_app_id: String(this.player.options_['appID']),
      str_fileid: String(this.player.options_['fileID']),
      u32_network_type: this.getNetworkType() // 网络类型 // 0xFF：未知// 1：wifi// 2：4G// 3：3G// 4：2G
    };

    this.liveBaseData = {
      str_user_id: this.guid('dev_uuid'),
      dev_uuid: this.guid('dev_uuid'),
      str_session_id: this.bytes_token,
      bytes_token: this.bytes_token, // 标志此次播放行为
      str_device_type: '', // 设备型号，iphone5
      str_os_info: this.getSystem(), // 系统版本 Android 10/iOS 13.5.1
      str_package_name: '', // 包名/bundleid，web端无
      u32_network_type: this.getNetworkType() !== '0xFF' ? this.getNetworkType() : '', // 0: 无网络连接 1：wifi网络 2：4G网络 3：3G网络 4：2G网络 5：有线网络
      u32_server_ip: '', // 服务端ip，web无
      str_stream_url: this.player.cache_.src,
      u64_timestamp: this.player.startTime, // 开始拉流的时间戳（开始上报）或者上报时刻的时间戳（区间和结束） ms
      u32_link_type: 1, // 链路类型 1：CDN，2：RTMPACC，3：RTMPProxy 4: LEB
      u32_channel_type: 1, // 通道类型 1：TCP，2：Quic  3：RTP 
      str_app_version: '', // BG统一上报需要，默认为空
      platform: 3, // 3 web
      uint32_platform: 3,
      str_browser_version: this.getBrowserVer(),
      str_browser_model: this.getBrowser(),
      str_user_agent: USER_AGENT,
      u32_video_drop: '',
      u32_drop_usage: '',
      float64_rtt: ''
    };

    this.features = [];
    // 是否已经过了 canplay 阶段，用于确定：直播场景下如果发生了错误时，是在开始上报协议上报还是结束协议上报
    this.afterCanplay = false;
    this.videoDuration = 0; // 视频总时长
    this.consumeDuration = 0; // 观看的时长，在播放结束/错误/离开页面时均需要计算

    // 首先判断有传fileid，一定是点播；
    // 如果传入url，在 loadedmetadata 之前报错，此时无法区分是点播还是直播
    // 此时不严谨的判断，根据url规则来，如果url中有vod，则认为是点播，如果没有则认为是直播；待讨论是否有更合适的判断方法
    // 如果传入url，在 loadedmetadata 之后判断duration为infinty，则为直播
    this.playScene = 2;
    this.timing = {
      // 不预先声明，只做注释说明timing存所有的时间戳
      // firstPlay: 0, //首次播放时间戳
      // firstPlaying: 0 //首次播放成功时间戳
    };
    // 首次播放标识
    this.playStatus = {
      isFirstPlay: false,
      pauseDuration: 0
    };
    this.contentComputTimePoint = [];
    this.firstFrameDuration = 0; // 收到首个视频数据时间
    this.firstIFrameDuration = 0; // 渲染首个i帧时间
    // 区间上报的时间间隔
    this.blockInterval = 5000;
    this.bufferBlock = [];
    this.u32_drm_type = 'plain';

    // 卡顿数据状态
    this.lagStatus = {
      lagCount: 0, // 卡顿次数
      lagging: false, // 卡顿
      lagStart: 0, // 卡顿开始时间戳
      lagEnd: 0, // 卡顿结束时间戳
      lagInterval: 500, // 卡顿间隔阈值
      lagDuration: 0, // 卡顿总时长
      lagAvg: [], // 卡顿平均时长数组
      isFirstLag: false,
      skip: false // 是否跳过卡顿监控
    };

    // 直播场景的区间数据，上报完成后重置
    this.resetBlockData();
  };

  PlayerMetrics.prototype.getComsumeDuration = function getComsumeDuration(err) {

    // 实际观看时长 = 总时长 - 卡顿时长 - 暂停时长
    // 实际观看时长可能会超过视频实际时长
    // 实际后台观测到有负值，对数据进行一轮修复
    var playTiming = getTimeStamp() - this.timing.firstPlaying;
    this.consumeDuration = playTiming - this.lagStatus.lagDuration - this.playStatus.pauseDuration;
    if (err) {
      if (this.consumeDuration < 0) {
        if (playTiming > 0) {
          this.consumeDuration = playTiming;
        } else {
          this.consumeDuration = 0;
        }
      }
    }
  };

  PlayerMetrics.prototype.registerListener = function registerListener() {
    var player = this.player;
    player.on('loadedmetadata', videojs.bind(this, this.onLoadedmetadata));
    player.one('canplay', videojs.bind(this, this.oneCanplay));
    player.one('play', videojs.bind(this, this.onePlay));
    player.on('play', videojs.bind(this, this.onPlay));
    player.on('playing', videojs.bind(this, this.onPlaying));
    player.on('seeking', videojs.bind(this, this.onSeeking));
    player.on('seeked', videojs.bind(this, this.onSeeked));
    player.on('error', videojs.bind(this, this.onError));
    player.on('resolutionswitching', videojs.bind(this, this.onResolutionSwitching));
    player.on('pause', videojs.bind(this, this.onPause));
    player.on('playcgiend', videojs.bind(this, this.onPlaycgiend));
    player.on('ended', videojs.bind(this, this.onEnded));
    player.on('feature', videojs.bind(this, this.onFeature));
    player.on('dispose', videojs.bind(this, this.onDispose));
    document.addEventListener('visibilitychange', videojs.bind(this, this.onVisibilityChange));
    window.addEventListener('pagehide', videojs.bind(this, this.onPageHide));
  };

  PlayerMetrics.prototype.onPageHide = function onPageHide() {
    this.saveData();
  };

  PlayerMetrics.prototype.onVisibilityChange = function onVisibilityChange() {
    if (document.visibilityState === 'hidden') {
      this.saveData();
    }
  };

  PlayerMetrics.prototype.saveData = function saveData() {
    // 点播场景 40304
    // 直播场景 40102
    if (this.bytes_token && this.playScene !== 3) {
      this.getComsumeDuration();
      this.report(this.playScene === 2 ? 40304 : 40102, {}, function (data) {
        localStorage.setItem('tcplayer_data', JSON.stringify(data));
      });
    }
  };

  PlayerMetrics.prototype.onLoadedmetadata = function onLoadedmetadata() {
    // 首帧从发起playcgi开始算起
    if (this.player.tech_.webrtcProvider) {
      this.playScene = 3;
    } else {
      this.playScene = this.player.duration() === Infinity ? 1 : 2;
    }
    this.videoDuration = parseInt(this.player.duration()) || 0;
    if (window.performance) {
      performance.mark('firstFrameEnd');
      performance.measure('firstFrame', 'firstFrameStart', 'firstFrameEnd');
      this.firstFrameDuration = performance.getEntriesByName('firstFrame')[0].duration;
    }

    // 点播发起开始上报
    // ready 时无法获取 duration，无法确定是直播还是点播，所以将开始上报数据后置到loadedmetadata
    this.playScene === 2 && this.report(40303);
  };

  PlayerMetrics.prototype.oneCanplay = function oneCanplay() {
    if (window.performance) {
      performance.mark('firstIFrameEnd');
      performance.measure('firstIFrame', 'firstFrameStart', 'firstIFrameEnd');
      this.firstIFrameDuration = performance.getEntriesByName('firstIFrame')[0].duration;
      // 直播发起开始上报，需要计算渲染首帧时间，时机设定为 canplay 
      this.playScene === 1 && this.report(40101);
    }
  };

  PlayerMetrics.prototype.onePlay = function onePlay() {
    var _this2 = this;

    // 开始播放
    this.setTimingData({ firstPlay: getTimeStamp() });
    // 开始播放后进入区间上报的数据采集阶段
    var el = this.player.el_.firstChild;
    this.bufferStart = el && el.buffered && el.buffered.length > 0 ? el.buffered.start(el.buffered.length - 1) : 0;
    this.bufferBlock = [this.bufferStart];
    var quality = this.player.getVideoPlaybackQuality();

    this.recvFrames = quality.totalVideoFrames;
    this.renderedFrames = quality.totalVideoFrames - quality.droppedVideoFrames;
    this.blockStartTime = getTimeStamp(); // 记录区间开始节点的数据，用于辅助计算区间内卡顿时长

    this.blockTimer = setInterval(function () {
      if (_this2.playScene === 2) return false;
      if (_this2.lagStatus.lagging && _this2.lagStatus.lagStart) {
        // 如果在区间上报时，正处于卡顿时刻，计算发生在此次区间时间段内的卡顿时长
        var currentLagDuration = getTimeStamp() - _this2.lagStatus.lagStart;
        if (currentLagDuration > _this2.blockInterval) {
          _this2.blockData.lagBlockDuration = _this2.blockInterval;
        } else {
          _this2.blockData.lagBlockDuration += currentLagDuration;
        }
      }
      _this2.blockStartTime = getTimeStamp();
      // 区间缓存时长数据
      var bufferEnd = el && el.buffered && el.buffered.length > 0 ? el.buffered.end(el.buffered.length - 1) : 0;

      // 区间帧率数据
      var quality = _this2.player.getVideoPlaybackQuality();
      var recvFrames = quality.totalVideoFrames;
      var renderedFrames = quality.totalVideoFrames - quality.droppedVideoFrames;

      // 在卡顿结束时，会计算卡顿的次数并填值到 blockData
      Object.assign(_this2.blockData, {
        buffer_avg: parseInt((bufferEnd - _this2.bufferStart) * 1000),
        recv_frames: recvFrames - _this2.recvFrames,
        render_frames: renderedFrames - _this2.renderedFrames
      });

      // 把区间的平均缓存时长存起来，用于在结束时计算整体的平均缓存时长
      _this2.bufferBlock.push(_this2.blockData.buffer_avg);
      _this2.bufferStart = bufferEnd;
      _this2.recvFrames = recvFrames;
      _this2.renderedFrames = renderedFrames;
      _this2.report(40100);
    }, this.blockInterval);
  };

  PlayerMetrics.prototype.onDispose = function onDispose() {
    clearInterval(this.blockTimer);
  };

  PlayerMetrics.prototype.onPlay = function onPlay() {
    if (this.playStatus.pauseTime) {
      this.playStatus.pauseDuration = this.playStatus.pauseDuration + getTimeStamp() - this.playStatus.pauseTime;
      this.playStatus.pauseTime = 0;
    }
  };

  PlayerMetrics.prototype.onPlaying = function onPlaying() {
    var _this3 = this;

    // 首次成功播放
    if (!this.playStatus.isFirstPlay) {
      this.playStatus.isFirstPlay = true;
      this.setTimingData({ firstPlaying: getTimeStamp() });

      // 首次播放后开始监听卡顿事件
      this.player.on('waiting', function () {
        // 排除seek  切换视频 手动暂停 而导致的卡顿
        if (!_this3.lagStatus.lagging && !_this3.player.seeking() && !_this3.lagStatus.skip) {
          _this3.lagStatus.lagging = true;
          _this3.lagStatus.lagStart = getTimeStamp();
        }
      });

      // 收集加密类型
      // 由于总是走私有加密流程，向前兼容标准加密和不加密场景，所以无法确定是否使用了私有加密
      if (this.player.currentSource().keySystems) {
        var keySystems = this.player.currentSource().keySystems;
        if (keySystems['plain']) {
          this.u32_drm_type = 'plain';
        }
        if (keySystems['SimpleAES']) {
          this.u32_drm_type = 'SimpleAES';
        }
      }
    }
    // 卡顿结束
    if (this.lagStatus.lagging && (this.lagStatus.lagEnd = getTimeStamp()) - this.lagStatus.lagStart > this.lagStatus.lagInterval) {
      this.lagStatus.lagging = false;
      this.lagStatus.lagCount++;
      this.lagStatus.lagAvg.push(this.lagStatus.lagEnd - this.lagStatus.lagStart);
      this.lagStatus.lagDuration += this.lagStatus.lagEnd - this.lagStatus.lagStart;

      // 计算区间内卡顿的时长，用于区间上报
      if (this.lagStatus.lagStart < this.blockStartTime) {
        this.blockData.lagBlockDuration = this.lagStatus.lagEnd - this.blockStartTime;
      }
      if (this.lagStatus.lagStart >= this.blockStartTime) {
        this.blockData.lagBlockDuration += this.lagStatus.lagEnd - this.lagStatus.lagStart;
      }

      this.lagStatus.lagEnd = this.lagStatus.lagStart = 0;

      if (!this.lagStatus.isFirstLag) {
        // 首次卡顿
        this.lagStatus.isFirstLag = true;
        this.setTimingData({ firstLag: getTimeStamp() });
      }
    }

    [60, 200, 500, 1000].forEach(function (item) {
      if (_this3.lagStatus.lagging && (_this3.lagStatus.lagEnd = getTimeStamp()) - _this3.lagStatus.lagStart > item) {
        _this3.blockData['lagCount_' + item]++;
      }
    });
    this.lagStatus.skip = false;
  };

  PlayerMetrics.prototype.onSeeking = function onSeeking() {
    this.contentComputTimePoint.push({
      type: 'end',
      time: this.player.currentTime()
    });
  };

  PlayerMetrics.prototype.onSeeked = function onSeeked() {
    this.contentComputTimePoint.push({
      type: 'start',
      time: this.player.currentTime()
    });
  };

  PlayerMetrics.prototype.onError = function onError(event) {
    this.getComsumeDuration(true);
    var errInfo = {
      u64_err_code: event.data.code,
      str_err_info: event.data.message || (defaults$1.errors[event.data.code] || {}).message
    };

    var urlRules = (this.player.cache_.src || '').indexOf('vod') > -1 || this.player.options_['fileID'];
    // 如果还没有到 loadedmetadata 就报错了，要在开始时机上报带上错误信息

    if (event && event.data && event.data.code) {
      if (this.playScene === 2 && urlRules) {
        // 点播的错误信息，只上报到结束协议
        this.report(40304, errInfo);
      } else {
        !this.afterCanplay ? this.report(40101, errInfo) : this.report(40102, errInfo);
      }
    }
  };

  PlayerMetrics.prototype.onResolutionSwitching = function onResolutionSwitching() {
    // 排除切换清晰度导致的卡顿
    this.lagStatus.skip = true;
  };

  PlayerMetrics.prototype.onPause = function onPause() {
    this.playStatus.pauseTime = getTimeStamp();
    if (this.lagStatus.lagging) {
      this.lagStatus.skip = true;
    }
  };

  PlayerMetrics.prototype.onPlaycgiend = function onPlaycgiend(event) {
    var _this4 = this;

    var data = event.data;
    if (data.result && data.result['code'] == 0) {
      this.playStatus['requestID'] = data.result['requestId'];

      // 收集开启DRM的播放请求, setTimeout是为了主线程执行完sources提取逻辑
      setTimeout(function () {
        if (_this4.player.currentSources().length > 0 && _this4.player.currentSources()[0].keySystems) {
          var keySystems = _this4.player.currentSources()[0].keySystems;
          if (keySystems['com.widevine.alpha']) {
            _this4.reportMTA('drm', { initialized: 'Widevine' });
          }
          if (keySystems['com.apple.fps.1_0']) {
            _this4.reportMTA('drm', { initialized: 'FairPlay' });
          }
        } else if (_this4.player.options_.plugins.DRM && _this4.player.options_.plugins.DRM.token) {
          _this4.reportMTA('drm', { initialized: 'SimpleAES' });
        }
      }, 0);
    }

    // 直播场景没有这两个数据，因此无法使用这两个数据
    this.setTimingData({ cgiStart: event.data.startTime, cgiEnd: event.data.time });
  };

  PlayerMetrics.prototype.onEnded = function onEnded() {
    this.getComsumeDuration();
    this.playScene === 1 ? this.report(40102) : this.report(40304);
    // 根据产品需求，要计算出观看的去重后的内容时长，总是小于实际时长
    // 然而终端没有计算此字段，且协议字段中也没有此字段，因此暂与终端保持一致，此信息暂不上传
    // 此算法相对复杂，暂保留于此，用于日后所需或学习使用

    // 使用区间合并算法计算
    // 修正起始点和终止点
    // const contentComputeTimePointArray = [[0, this.contentComputTimePoint[0].time]];
    // this.contentComputTimePoint.push({
    //   type: 'end',
    //   time: player.currentTime(),
    // });

    // // 数据转换为二维数组
    // for (let i = 1; i < this.contentComputTimePoint.length; i++) {
    //   const cctp = this.contentComputTimePoint;
    //   if (cctp[i].type === 'start' && cctp[i + 1].type === 'end') {
    //     contentComputeTimePointArray.push([cctp[i].time, cctp[i + 1].time]);
    //   }
    // }

    // // 二维数组排序
    // contentComputeTimePointArray.sort((a, b) => {
    //   return a.time - b.time;
    // });

    // // 区间合并
    // // 计算合并后的区间长度
    // let contentDuration = 0;
    // let curInterval = contentComputeTimePointArray[0];
    // let arrangedInterval = [curInterval];
    // for (let i = 0;i < contentComputeTimePointArray.length; i++) {
    //   if (contentComputeTimePointArray[i][0] <= curInterval[1]) {
    //     curInterval = [curInterval[0], Math.max(contentComputeTimePointArray[i][1], curInterval[1])];
    //     arrangedInterval[arrangedInterval.length - 1] = curInterval;
    //   } else {
    //     curInterval = contentComputeTimePointArray[i];
    //     arrangedInterval.push(curInterval);
    //   } 
    // }

    // for (let i = 0; i < arrangedInterval.length; i++) {
    //   contentDuration += arrangedInterval[i][1] - arrangedInterval[i][0];
    // }

    // args.contentDuration = contentDuration;
  };

  PlayerMetrics.prototype.onFeature = function onFeature(res) {
    if (this.features.indexOf(res.data) == -1) this.features.push(res.data);
  };

  PlayerMetrics.prototype.guid = function guid$$1(key) {
    var uuid = localStorage.getItem(key);
    if (!uuid) {
      uuid = guid();

      localStorage.setItem(key, uuid);
    }
    return uuid;
  };

  // 发起上报入口


  PlayerMetrics.prototype.report = function report(protocol) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cb = arguments[2];

    if (this.playScene === 3) return false; // 快直播场景，是在webrtc.js中通过回调事件触发上报的
    if (protocol) {
      this['report_' + protocol](params, cb);
    }
  };

  // live start


  PlayerMetrics.prototype.report_40101 = function report_40101() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var protocol_40101 = {
      uint64_data_time: getTimeStampBySecond(), // 精确到秒
      str_stream_url: this.player.cache_.src,
      u64_timestamp: this.player.startTime, // 开始拉流的时间戳 ms
      u32_dns_time: '', // dns解析耗时, web无
      u32_connect_server_time: parseInt(this.firstFrameDuration), // 连接cdn的耗时 HTTP - 开始拉流到返回 200 为判定点 ms
      u32_video_decode_type: 0, // 解码器类型
      u32_first_frame_down: parseInt(this.firstFrameDuration), // 收到首个视频帧数据
      u32_first_video_decode_time: parseInt(this.firstIFrameDuration), // 解码视频i帧耗时
      u32_first_i_frame: parseInt(this.firstIFrameDuration), // 渲染首个视频帧
      u32_first_audio_frame_down: parseInt(this.firstFrameDuration), // 收到首个音频帧，web不拆分音频和视频，同 u32_first_frame_down
      u32_first_audio_render_time: parseInt(this.firstIFrameDuration), // 音频首帧渲染完成，同 u32_first_i_frame
      u64_err_code: params.u64_err_code || '', // 拉流错误码
      str_err_info: params.str_err_info || '' // 错误描述
    };

    var data = {
      app_id: 0,
      data: [Object.assign({}, this.liveBaseData, protocol_40101, params)],
      module_id: 1005,
      command: 40101
    };

    Reporter.reportPlayMetrics(data);
  };

  // 区间上报
  // 直播场景缓存帧数暂不计算


  PlayerMetrics.prototype.report_40100 = function report_40100(params) {
    var _this5 = this;

    var player = this.player || {};
    this.blockData = this.blockData || {};
    var protocol_40100 = {
      u32_cpu_usage: '', // 无
      u32_app_cpu_usage: '', // 无
      u32_avg_memory: '', // 无
      u32_avg_cpu_usage: '', // 无
      str_stream_url: player.cache_ && player.cache_.src,
      uint64_data_time: getTimeStampBySecond(), // 精确到秒
      u32_recv_av_diff_time: 0, // 音视频时间戳差值均值-接收 是啥玩意
      u32_play_av_diff_time: 0, // 音视频时间戳差值均值-播放
      u64_playtime: getTimeStamp() - this.timing.firstPlaying, // 从0开始播放的偏移时间，每隔5s累计的播放时间
      u32_audio_decode_type: 2, // 1：硬解 2：软解
      u32_audio_block_count: this.blockData.lagCount_500, // 音频卡顿次数
      u32_audio_cache_time: this.blockData.buffer_avg, // 音频平均缓存时长
      u32_audio_drop: '', // 上报周期的音频丢包数 web无
      u32_video_decode_type: 0, // 264 软解
      u32_video_recv_fps: this.blockData.recv_frames, // 视频接收帧率
      u32_fps: this.blockData.render_frames, // 视频渲染帧率
      u32_video_cache_time: this.blockData.buffer_avg, // 视频平均缓存时长
      u32_avg_cache_count: 0, // 视频平均缓存帧数，web端计算时长即可
      u32_video_block_count: this.blockData.lagCount_1000, // 视频卡顿次数 1000ms 大卡
      u32_avg_net_speed: '', // 平均网络接收速度，音频平均下行速率 + 视频平均下行速率 kb/s
      u32_video_light_block_count: this.blockData.lagCount_200, // 视频卡顿（200ms轻卡顿）
      u32_video_large_block_count: this.blockData.lagCount_500, // 视频卡顿（500ms轻卡顿）
      u32_audio_jitter_60ms_count: this.blockData.lagCount_60, // 音频卡顿次数 60ms
      u32_video_decode_fail: '', // 视频解码失败，报错误码 播放过程中报错，将会视作结束，上报结束协议
      u32_audio_decode_fail: '', // 音频解码失败，报错误码
      u32_avg_video_bitrate: 0, // 视频下行码率（区间）
      u32_avg_audio_bitrate: 0, // 音频下行码率（区间）
      u32_block_usage: parseInt(this.blockData.lagBlockDuration / this.blockInterval) * 1000 // 区间卡顿率（区间卡顿时长/区间时长 * 1000）
    };

    var data = {
      app_id: 0,
      data: [Object.assign({}, this.liveBaseData, protocol_40100, params)],
      module_id: 1005,
      command: 40100
    };

    Reporter.reportPlayMetrics(data, function () {
      _this5.resetBlockData();
    });
  };

  // 播放结束上报


  PlayerMetrics.prototype.report_40102 = function report_40102() {
    var _this6 = this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var cb = arguments[1];

    var player = this.player || {}; // 快直播场景dispose之后，才会进入此方法，此时player已注销
    var u32_avg_load = this.lagStatus.lagAvg.length > 0 ? this.lagStatus.lagAvg.reduce(function (prev, curr) {
      return prev + curr;
    }, 0) / this.lagStatus.lagAvg.length : 0;
    var u32_avg_cache_time = this.bufferBlock.length > 0 ? this.bufferBlock.reduce(function (prev, curr) {
      return prev + curr;
    }, 0) / this.bufferBlock.length : 0;
    var quality = player.getVideoPlaybackQuality && player.getVideoPlaybackQuality() || {};
    var u32_video_avg_fps = quality.totalVideoFrames / params.duration;
    var protocol_40102 = {
      uint64_data_time: getTimeStampBySecond(), // 精确到秒
      str_stream_url: player.cache_ && player.cache_.src,
      u64_timestamp: getTimeStamp(), // ms
      u32_avg_cpu_usage: '', // 无
      u32_avg_memory: '', // 无
      u64_begin_timestamp: player.startTime, // 开始拉流的时间戳 ms
      u32_result: this.consumeDuration, // 总播放时长 s
      u64_err_code: params.u64_err_code, // 
      u32_speed_cnt: 0, // 播放过程中出现加减速播放的次数
      u32_avg_cache_time: u32_avg_cache_time, // 音频平均缓存时长 单位 ms
      u32_max_load: Math.max.apply(Math, this.lagStatus.lagAvg), // 音频最长的一次卡顿时长
      u32_audio_block_time: this.lagStatus.lagDuration, // 音频总卡顿时间
      u32_avg_load: u32_avg_load, // 音频平均卡顿时长
      u32_load_cnt: this.lagStatus.lagAvg.length || 0, // 音频总卡顿次数
      u32_nodata_cnt: this.lagStatus.lagAvg.length || 0, // 同 u32_load_cnt
      u32_first_i_frame: this.firstIFrameDuration, // 首帧视频渲染时间
      u32_video_width: player.width_, // 视频宽度
      u32_video_height: player.height_, // 视频高度
      u32_video_avg_fps: u32_video_avg_fps, // 视频渲染平均帧率
      u32_avg_block_time: u32_avg_load, // 视频平均卡顿时长 >500ms
      u64_block_count: this.lagStatus.lagAvg.length || 0, // 视频总卡顿次数
      u32_video_block_time: this.lagStatus.lagDuration, // 视频总卡顿时间
      u64_jitter_cache_max: 0, // 视频 videojitterbuffer 最大缓存帧数
      u64_block_duration_max: Math.max.apply(Math, this.lagStatus.lagAvg), // 视频最大卡顿时长
      u64_jitter_cache_avg: 0, // 平均缓存帧数
      u32_ip_count_quic: '', // 不填
      u32_connect_count_quic: '', // 不填
      u32_connect_count_tcp: '', // 不填
      u32_is_real_time: '', // 播放过程是否为实时播放，0表示非实时，1表示实时
      u32_first_frame_black: '', // 不填
      u32_delay_report: 0 // 0 立即上报 1 延迟上报
    };

    var data = {
      app_id: 0,
      data: [Object.assign({}, this.liveBaseData, protocol_40102, params)],
      module_id: 1005,
      command: 40102

      // u32_delay_report 0立即上报 1延迟上报
    };if (params.u32_delay_report) {
      localStorage.setItem('tcplayer_data', JSON.stringify(data));
      return false;
    }

    // 离开页面时存储数据到本地
    if (cb) {
      data.data.u32_delay_report = 1;
      return cb(data);
    }

    Reporter.reportPlayMetrics(data, function () {
      _this6.bytes_token = null;
      localStorage.removeItem('tcplayer_data');
    });
  };

  /**
   * 初始化时机为 播放器 reday
   */


  PlayerMetrics.prototype.report_40303 = function report_40303() {
    this.setTimingData({ initEnd: getTimeStamp() });
    var protocol_40303 = {
      msg_client_ip: {
        uint32_ip: ''
      },
      uint32_service: this.playScene,
      uint64_data_time: getTimeStampBySecond(), // 精确到秒
      str_stream_url: this.player.cache_.src,
      uint32_command: 40303
    };

    var data = {
      app_id: 0,
      data: [Object.assign({}, this.vodBaseData, protocol_40303)],
      module_id: 1011,
      command: 40303
    };

    Reporter.reportPlayMetrics(data);
  };

  PlayerMetrics.prototype.report_40304 = function report_40304() {
    var _this7 = this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var cb = arguments[1];

    var u32_avg_load = this.lagStatus.lagAvg.length > 0 ? this.lagStatus.lagAvg.reduce(function (prev, curr) {
      return prev + curr;
    }, 0) / this.lagStatus.lagAvg.length : 0;
    var protocol_40304 = {
      uint64_data_time: getTimeStampBySecond(), // 精确到秒
      uint32_command: 40304,
      str_stream_url: this.player.cache_.src,
      u32_timeuse: String(parseInt(this.consumeDuration / 1000) || 0), // 停止播放-开始播放-暂停，统计的是实际观看的时长
      u32_videotime: String(this.videoDuration), // 直接获取视频总时长
      u32_avg_load: String(u32_avg_load), // 视频卡顿平均耗时, ms
      u32_load_cnt: String(this.lagStatus.lagCount), // 视频卡顿次数
      u32_max_load: this.lagStatus.lagAvg.length > 0 ? String(Math.max.apply(Math, this.lagStatus.lagAvg)) : String(0), // 播放过程中出现loading耗时最大的时间（首帧不算），单位ms
      u32_avg_block_time: String(this.lagStatus.lagDuration), // 视频总卡顿时长, 单位ms （两帧解码>500ms 的累加）
      u32_player_type: String(4), // 点播播放器类型. 1 - IJK Player, 2 - AVPlayer (ios)/ mediaplayer(android), 3 - Exo, 4 - Tcplayer
      u32_dns_time: '', // dns解析耗时（统一按拉到ip截止），从开始拉流计算，单位：ms，-1表示失败, web无
      u32_tcp_did_connect: '', // tcp连接成功时间，从开始拉流计算，单位：ms，-1表示失败， web无
      u32_first_video_packet: String(parseInt(this.firstFrameDuration)), // 收到首个视频数据时间，从开始拉流计算，单位：ms，-1表示失败
      u32_first_i_frame: String(parseInt(this.firstIFrameDuration)), // 首帧视频渲染时间，从开始拉流计算，单位：ms，-1表示失败
      u32_server_ip: '', // 连接cdn的ip地址 // web 无
      // DRM 类型：
      // plain：非加密
      // SimpleAES：HLS SimpleAES加密
      u32_drm_type: this.u32_drm_type,
      u32_playmode: String(1), // 播放模式：0表示基础播放器，1 表示超级播放器
      u64_err_code: String(params.u64_err_code || ''),
      str_err_info: String(params.str_err_info || ''),
      //  -1：初始值；
      //  0：264软解，1：264硬解
      //  2：265软解,   3: 265 硬解
      u32_video_decode_type: String(0),
      u32_speed: this.player && String(this.player.playbackRate() * 100) || '1000' // 播放速度 *100 的值
    };

    var data = {
      app_id: 0,
      data: [Object.assign({}, this.vodBaseData, protocol_40304)],
      module_id: 1011,
      command: 40304
    };

    if (cb) {
      return cb(data);
    }

    Reporter.reportPlayMetrics(data, function () {
      _this7.bytes_token = null;
      localStorage.removeItem('tcplayer_data');
    });
  };

  PlayerMetrics.prototype.setTimingData = function setTimingData(args) {
    this.timing = videojs.mergeOptions(this.timing, args);
  };

  PlayerMetrics.prototype.reset = function reset() {
    this.playStatus = {
      isFirstPlay: false
    };
  };

  PlayerMetrics.prototype.resetBlockData = function resetBlockData() {
    this.blockData = {
      lagCount_60: 0,
      lagCount_200: 0,
      lagCount_500: 0,
      lagCount_1000: 0,
      lagBlockDuration: 0,
      buffer_avg: 0,
      recv_frames: 0,
      render_frames: 0
    };
  };

  PlayerMetrics.prototype.reportMTA = function reportMTA(id, data) {}
  // this.player.Reporter().reportMTA(id, data);

  // 系统: mac、win、android、ios、other
  ;

  PlayerMetrics.prototype.getSystem = function getSystem() {
    if (IS_IOS) return 'ios';
    if (IS_ANDROID) return 'android';
    if (IS_WIN) return 'win';
    if (IS_MAC) return 'mac';else return 'other';
  };
  // 系统版本: win10、android7、ios11


  PlayerMetrics.prototype.getSystemVer = function getSystemVer() {
    var system = this.getSystem();
    if (system == 'ios') return IOS_VERSION;
    if (system == 'android') return ANDROID_VERSION;
    if (system == 'win') return WIN_VER;
    if (system == 'mac') return MAC_VER;
  };
  // 浏览器


  PlayerMetrics.prototype.getBrowser = function getBrowser() {
    if (IS_FIREFOX) return 'firefox';
    if (IS_EDGE) return 'edge';
    if (IS_MQQB) return 'mqq';
    if (IS_QQB) return 'qq';
    if (IS_TBS) return 'tbs';
    if (IS_CHROME) return 'chrome';
    if (IE_VERSION) return 'ie';
    if (IS_SAFARI) return 'safari';
    return 'other';
  };
  // 浏览器版本


  PlayerMetrics.prototype.getBrowserVer = function getBrowserVer() {
    var bw = this.getBrowser();
    if (bw == 'firefox') return FIREFOX_VER;
    if (bw == 'edge') return EDGE_VER;
    if (bw == 'chrome') return CHROME_VER;
    if (bw == 'ie') return IE_VERSION;
    if (bw == 'safari') return SAFARI_VER;
    if (bw == 'qq' || bw == 'mqq') return QQ_VER;
    if (bw == 'tbs') return TBS_VERSION;
    return 'other';
  };
  // 手机型号(只针对移动端)


  PlayerMetrics.prototype.getDevice = function getDevice() {
    if (IS_IOS) return 'IPHONE';
    if (IS_HUAWEI) return 'HUAWEI';
    if (IS_XIAOMI) return 'XIAOMI';
    if (IS_OPPO) return 'OPPO';
    if (IS_VIVO) return 'VIVO';
    if (IS_SX) return 'SUMSUNG';
    if (IS_CP) return 'COOLPAD';
    if (IS_ONE) return 'ONEPLUS';
    if (IS_ZX) return 'ZTE';
    return 'OTHER';
  };
  // 播放媒体类型


  PlayerMetrics.prototype.getMediaType = function getMediaType() {
    this.player.src() && /\/(.+)\.(.+)\?|\/(.+)\.(.+)/.test(this.player.src());
    return RegExp.$2 || RegExp.$4;
  };

  PlayerMetrics.prototype.getNetworkType = function getNetworkType() {
    var ua = navigator.userAgent;
    var networkStr = ua.match(/NetType\/\w+/) ? ua.match(/NetType\/\w+/)[0] : 'NetType/other';
    networkStr = networkStr.toLowerCase().replace('nettype/', '');
    var networkType;
    switch (networkStr) {
      case 'wifi':
        networkType = '1';
        break;
      case '4g':
        networkType = '2';
        break;
      case '3g':
        networkType = '3';
        break;
      case '3gnet':
        networkType = '3';
        break;
      case '2g':
        networkType = '4';
        break;
      default:
        networkType = '0xFF';
    }
    return networkType;
  };

  return PlayerMetrics;
}(Plugin$14);

videojs.registerPlugin('PlayerMetrics', PlayerMetrics);

/**
 * @file dot-builder.js
 */

var Plugin$15 = videojs.getPlugin('plugin');
var log$14 = videojs.log;

var ProgressMarker = function (_Plugin) {
  inherits(ProgressMarker, _Plugin);

  function ProgressMarker(player, options) {
    classCallCheck(this, ProgressMarker);

    // 新增打点回调事件，不能只局限于非移动端。移动端不展示打点的逻辑转移到init里
    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    player.ready(videojs.bind(_this, _this.init));
    return _this;
  }

  ProgressMarker.prototype.init = function init() {
    var player = this.player;
    if (!player.options_.dots) {
      return;
    }

    // 到打点处，触发回调事件
    function checkDots() {
      if (player.options_.dots) {
        player.options_.dots.forEach(function (item) {
          if (!item.emitted && item.timeOffset - (player.currentTime() || 0) * 1000 < 500) {
            item.emitted = true;
            player.trigger('marker', item.content);
          }
        });

        if (!player.options_.dots[player.options_.dots.length - 1].emitted) {
          window.requestAnimationFrame(checkDots);
        }
      }
    }

    window.requestAnimationFrame(checkDots);

    if (IS_IOS || IS_ANDROID) {
      return false;
    }

    if (!player.controlBar || !this.player.controlBar.progressControl) {
      log$14('ProgressMarker can not initialize without control bar or progress control');
      return;
    }
    log$14('ProgressMarker initializing');
    var seekBar = player.controlBar.getChild('ProgressControl').getChild('SeekBar');
    if (seekBar.getChild('ProgressMarkerGenerator')) {
      seekBar.removeChild('ProgressMarkerGenerator');
    }

    if (player.options_.plugins['ProgressMarker']) {
      seekBar.addChild('ProgressMarkerGenerator');
      log$14('ProgressMarker initialized');
      player.trigger({ type: 'feature', data: 'marker' });
    }
  };

  return ProgressMarker;
}(Plugin$15);

videojs.registerPlugin('ProgressMarker', ProgressMarker);

/**
 * @file playlist-item.js
 */

var Component$15 = videojs.getComponent('Component');

/**
 * 播放项目，可添加标题、说明、播放视频
 * @extends Component
 */

var PlayListItem = function (_Component) {
  inherits(PlayListItem, _Component);

  function PlayListItem(player, options) {
    classCallCheck(this, PlayListItem);
    return possibleConstructorReturn(this, _Component.call(this, player, options));
  }

  PlayListItem.prototype.createEl = function createEl() {
    var data = this.options_;

    // 播放项
    var el = videojs.dom.createEl('div', {
      className: 'tcp-playlist-item'
    });

    // 左侧图片
    var itemImg = videojs.dom.createEl('div', {
      className: 'tcp-playlist-item-video',
      innerHTML: data.img ? '<img src="' + data.img + '" class="tcp-playlist-item-img">' : '<img src="https://imgcache.qq.com/open_proj/proj_qcloud_v2/mc_2014/video/console/v2/css/img/vod/default-cover.png" height="100" class="tcp-playlist-item-img">'
    });

    // 视频时长
    var duration = videojs.dom.createEl('div', {
      className: 'tcp-playlist-item-duration',
      textContent: this.timeFormat(data.duration)
    });
    itemImg.appendChild(duration);

    // 视频描述
    var description = videojs.dom.createEl('div', {
      className: 'tcp-playlist-item-desc',
      textContent: data.text
    });

    el.appendChild(itemImg);
    el.appendChild(description);

    this.bindEvent(el);

    return el;
  };

  PlayListItem.prototype.bindEvent = function bindEvent(dom) {
    var _this2 = this;

    videojs.on(dom, ['click'], function () {
      // 切换视频
      _this2.player_.trigger({ type: 'playItem', data: _this2.options_ });
    });
  };

  PlayListItem.prototype.timeFormat = function timeFormat(time) {
    // 将时间秒数格式化
    var timeStr = '';
    var h = Math.floor(time / 3600);
    if (h != 0) {
      time -= h * 3600;
      if (h < 10) h = '0' + h;
      timeStr += h + ':';
    }
    var m = Math.floor(time / 60);
    if (m < 10) m = '0' + m;
    time -= m * 60;
    if (time < 10) time = '0' + time;
    timeStr += m + ':' + time;
    return timeStr;
  };

  return PlayListItem;
}(Component$15);

videojs.registerComponent('PlayListItem', PlayListItem);

/**
 * @file playlist-title.js
 */

var Component$16 = videojs.getComponent('Component');

/**
 * 播放项目，可添加标题、说明、播放视频
 * @extends Component
 */

var PlayListTitle = function (_Component) {
  inherits(PlayListTitle, _Component);

  function PlayListTitle(player, options) {
    classCallCheck(this, PlayListTitle);
    return possibleConstructorReturn(this, _Component.call(this, player, options));
  }

  PlayListTitle.prototype.createEl = function createEl() {
    var data = this.options_;
    var el = videojs.dom.createEl('div', {
      className: 'tcp-playlist-title',
      textContent: data.title
    });
    return el;
  };

  return PlayListTitle;
}(Component$16);

videojs.registerComponent('PlayListTitle', PlayListTitle);

/**
 * @file playlist-box.js
 */

var Component$14 = videojs.getComponent('Component');
var PlayListBox = function (_Component) {
  inherits(PlayListBox, _Component);

  function PlayListBox(player, options) {
    classCallCheck(this, PlayListBox);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.init();
    _this.activeIndex = -1; // 当前正在播的视频
    return _this;
  }

  PlayListBox.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-playlist-box'
    });
    return el;
  };

  PlayListBox.prototype.init = function init() {
    var _this2 = this;

    var list = this.options_.data;

    this.addChild('PlayListTitle', { title: this.options_.title });
    list.forEach(function (item, index) {
      item.index = index;
      _this2.addChild('PlayListItem', item);
    });

    // 设置自动循环
    this.player_.on('ready', function () {
      if (_this2.options_.loop) {
        _this2.activeIndex = 0;
        _this2.player_.on('ended', videojs.bind(_this2, function () {
          _this2.player_.trigger({
            type: 'playItem'
          });
        }));
      }
    });

    this.player_.on('playItem', function (res) {
      var data = res.data,
          target = void 0;

      if (!data) _this2.activeIndex = (_this2.activeIndex + 1) % list.length; // 播放下一个视频
      else _this2.activeIndex = data.index; // 播放指定视频

      target = list[_this2.activeIndex];
      _this2.player_.loadVideoByID({ fileID: target.fileID, appID: target.appID, psign: target.psign });

      // 切换视频后自动播放
      _this2.player_.one('loadedmetadata', videojs.bind(_this2, function () {
        _this2.player_.play();
      }));

      document.querySelectorAll('.tcp-playlist-item').forEach(function (playItem) {
        videojs.dom.removeClass(playItem, 'tcp-playlist-item-active');
      });

      var activeItem = document.querySelectorAll('.tcp-playlist-item')[_this2.activeIndex];
      videojs.dom.addClass(activeItem, 'tcp-playlist-item-active');
    });
  };

  return PlayListBox;
}(Component$14);

videojs.registerComponent('PlayListBox', PlayListBox);

/**
 * @file playlist-toggle.js
 */

var Component$17 = videojs.getComponent('Component');

/**
 * 播放列表开关
 * @extends Component
 */

var PlayListToggle = function (_Component) {
  inherits(PlayListToggle, _Component);

  function PlayListToggle(player, options) {
    classCallCheck(this, PlayListToggle);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.status = 0; // 0关闭，1开启，默认关闭
    return _this;
  }

  PlayListToggle.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-playlist-toggle',
      textContent: '<' // 先简单的使用"<",">"
    });
    this.bindEvent(el);
    return el;
  };

  PlayListToggle.prototype.bindEvent = function bindEvent(el) {
    var _this2 = this;

    videojs.on(el, ['click'], function (e) {
      _this2.status = !_this2.status;
      var playListDom = document.querySelector('.tcp-playlist');
      if (_this2.status) {
        el.textContent = '>';
        videojs.dom.addClass(playListDom, 'tcp-playlist-open');
        videojs.dom.removeClass(playListDom, 'tcp-playlist-close');
      } else {
        videojs.dom.addClass(playListDom, 'tcp-playlist-close');
        videojs.dom.removeClass(playListDom, 'tcp-playlist-open');
        el.textContent = '<';
      }
    });
  };

  return PlayListToggle;
}(Component$17);

videojs.registerComponent('PlayListToggle', PlayListToggle);

/**
 * @file playlist.js
 */

var Component$13 = videojs.getComponent('Component');

/**
 * 播放列表，包含开关、列表内容
 * @extends Component
 */

var PlayList$1 = function (_Component) {
  inherits(PlayList, _Component);

  function PlayList(player, options) {
    classCallCheck(this, PlayList);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.init();
    return _this;
  }

  PlayList.prototype.createEl = function createEl() {
    var el = videojs.dom.createEl('div', {
      className: 'tcp-playlist tcp-playlist-close'
    });
    return el;
  };

  PlayList.prototype.init = function init() {
    this.addChild('PlayListToggle');
    this.addChild('PlayListBox', this.options_);
  };

  return PlayList;
}(Component$13);

videojs.registerComponent('PlayList', PlayList$1);

/**
 * @file playnext-button.js
 */

var Button$5 = videojs.getComponent('Button');

/**
 * 播放下一个视频
 * @extends Button
 */

var PlayNextButton = function (_Button) {
  inherits(PlayNextButton, _Button);

  function PlayNextButton(player, options) {
    classCallCheck(this, PlayNextButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.addClass();
    return _this;
  }

  PlayNextButton.prototype.addClass = function addClass() {
    videojs.dom.addClass(this.el_, 'vjs-play-next');
  };

  PlayNextButton.prototype.update = function update() {};

  PlayNextButton.prototype.handleClick = function handleClick(event) {
    this.player_.trigger({
      type: 'playItem'
    });
  };

  return PlayNextButton;
}(Button$5);

PlayNextButton.prototype.controlText_ = 'Play Next';

videojs.registerComponent('PlayNextButton', PlayNextButton);

/**
 * @file playlist.js
 */
var Plugin$16 = videojs.getPlugin('plugin');
var log$15 = videojs.log;

var PlayList = function (_Plugin) {
  inherits(PlayList, _Plugin);

  function PlayList(player, options) {
    classCallCheck(this, PlayList);

    // 暂时仅支持PC端
    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    if (IS_IOS || IS_ANDROID) return possibleConstructorReturn(_this);
    _this.options = options;
    if (options && options.data instanceof Array && options.data.length > 0) {
      player.ready(videojs.bind(_this, _this.init));
    }
    return _this;
  }

  PlayList.prototype.init = function init() {
    log$15('PlayList initializing');
    this.player.addChild('PlayList', this.options);
    // 插在controlBar第二个位置
    this.player.controlBar.addChild('PlayNextButton', {}, 1);

    log$15('PlayList initialized');
    this.player.trigger({ type: 'feature', data: 'playlist' });
  };

  return PlayList;
}(Plugin$16);

videojs.registerPlugin('PlayList', PlayList);

var Plugin$17 = videojs.getPlugin('plugin');
var log$16 = videojs.log;
// const log = console.log;

var HLSToken = function (_Plugin) {
  inherits(HLSToken, _Plugin);

  function HLSToken(player, options) {
    classCallCheck(this, HLSToken);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    log$16('HLSToken', player, options);
    _this.init(options);
    return _this;
  }

  HLSToken.prototype.init = function init(options) {
    log$16('HLSToken init', options, this.player);
    var player = this.player;
    if (options.token) {
      this.options = options;
      // 在playcgi返回数据后修改 hls url
      player.on('playcgiend', videojs.bind(this, function (event) {
        this.modifyData(event.data);
      }));
    }
  };

  /**
   * 修改 m3u8 url
   * @param data
   */


  HLSToken.prototype.modifyData = function modifyData(data) {
    var _this2 = this;

    log$16('HLSToken modifyData', data);
    if (data.result.code === 0) {
      var videoInfo = data.result.videoInfo;
      if (videoInfo.masterPlayList) {
        // 在 URL 中的文件名之前增加 voddrm.token.<Token>
        // /video.m3u8 to /voddrm.token.<Token>.video.m3u8
        var urlItem = videoInfo.masterPlayList.url.split('/');
        urlItem[urlItem.length - 1] = 'voddrm.token.' + this.options.token + '.' + urlItem[urlItem.length - 1];
        videoInfo.masterPlayList.url = urlItem.join('/');
      }
      if (videoInfo.transcodeList && videoInfo.transcodeList.length > 0) {
        videoInfo.transcodeList = videoInfo.transcodeList.map(function (item) {
          var urlItem = item.url.split('/');
          urlItem[urlItem.length - 1] = 'voddrm.token.' + _this2.options.token + '.' + urlItem[urlItem.length - 1];
          item.url = urlItem.join('/');
          return item;
        });
      }
    }
  };

  return HLSToken;
}(Plugin$17);

videojs.registerPlugin('HLSToken', HLSToken);

var getMessageContents = function getMessageContents(message) {
  var xml = new window_1.DOMParser().parseFromString(
  // TODO do we want to support UTF-8?
  String.fromCharCode.apply(null, new Uint16Array(message)), 'application/xml');
  var headersElement = xml.getElementsByTagName('HttpHeaders')[0];
  var headers = {};

  if (headersElement) {
    var headerNames = headersElement.getElementsByTagName('name');
    var headerValues = headersElement.getElementsByTagName('value');

    for (var i = 0; i < headerNames.length; i++) {
      headers[headerNames[i].childNodes[0].nodeValue] = headerValues[i].childNodes[0].nodeValue;
    }
  }

  var challengeElement = xml.getElementsByTagName('Challenge')[0];
  var challenge = void 0;

  if (challengeElement) {
    challenge = window_1.atob(challengeElement.childNodes[0].nodeValue);
  }

  return {
    headers: headers,
    message: challenge
  };
};

var requestPlayreadyLicense = function requestPlayreadyLicense(url, messageBuffer, callback) {
  var _getMessageContents = getMessageContents(messageBuffer),
      headers = _getMessageContents.headers,
      message = _getMessageContents.message;

  videojs.xhr({
    uri: url,
    method: 'post',
    headers: headers,
    body: message,
    responseType: 'arraybuffer'
  }, callback);
};

var getSupportedKeySystem = function getSupportedKeySystem(keySystems) {
  // As this happens after the src is set on the video, we rely only on the set src (we
  // do not change src based on capabilities of the browser in this plugin).

  var promise = void 0;

  Object.keys(keySystems).forEach(function (keySystem) {
    // TODO use initDataTypes when appropriate
    var systemOptions = {};
    var audioContentType = keySystems[keySystem].audioContentType;
    var videoContentType = keySystems[keySystem].videoContentType;

    if (audioContentType) {
      systemOptions.audioCapabilities = [{
        contentType: audioContentType
      }];
    }
    if (videoContentType) {
      systemOptions.videoCapabilities = [{
        contentType: videoContentType
      }];
    }

    if (!promise) {
      promise = window_1.navigator.requestMediaKeySystemAccess(keySystem, [systemOptions]);
    } else {
      promise = promise['catch'](function (e) {
        return window_1.navigator.requestMediaKeySystemAccess(keySystem, [systemOptions]);
      });
    }
  });

  return promise;
};

var makeNewRequest = function makeNewRequest(_ref) {
  var mediaKeys = _ref.mediaKeys,
      initDataType = _ref.initDataType,
      initData = _ref.initData,
      options = _ref.options,
      getLicense = _ref.getLicense,
      removeSession = _ref.removeSession,
      eventBus = _ref.eventBus;

  var keySession = mediaKeys.createSession();

  keySession.addEventListener('message', function (event) {
    getLicense(options, event.message).then(function (license) {
      return keySession.update(license);
    })['catch'](videojs.log.error.bind(videojs.log.error, 'failed to get and set license'));
  }, false);

  keySession.addEventListener('keystatuseschange', function (event) {
    var expired = false;

    // based on https://www.w3.org/TR/encrypted-media/#example-using-all-events
    keySession.keyStatuses.forEach(function (status, keyId) {
      // Trigger an event so that outside listeners can take action if appropriate.
      // For instance, the `output-restricted` status should result in an
      // error being thrown.
      eventBus.trigger({
        keyId: keyId,
        status: status,
        target: keySession,
        type: 'keystatuschange'
      });
      switch (status) {
        case 'expired':
          // If one key is expired in a session, all keys are expired. From
          // https://www.w3.org/TR/encrypted-media/#dom-mediakeystatus-expired, "All other
          // keys in the session must have this status."
          expired = true;
          break;
        case 'internal-error':
          // "This value is not actionable by the application."
          // https://www.w3.org/TR/encrypted-media/#dom-mediakeystatus-internal-error
          videojs.log.warn('Key status reported as "internal-error." Leaving the session open since we ' + 'don\'t have enough details to know if this error is fatal.', event);
          break;
      }
    });

    if (expired) {
      // Close session and remove it from the session list to ensure that a new
      // session can be created.
      //
      // TODO convert to videojs.log.debug and add back in
      // https://github.com/videojs/video.js/pull/4780
      // videojs.log.debug('Session expired, closing the session.');
      keySession.close().then(function () {
        removeSession(initData);
      });
    }
  }, false);

  keySession.generateRequest(initDataType, initData)['catch'](videojs.log.error.bind(videojs.log.error, 'Unable to create or initialize key session'));
};

var addSession = function addSession(_ref2) {
  var video = _ref2.video,
      initDataType = _ref2.initDataType,
      initData = _ref2.initData,
      options = _ref2.options,
      getLicense = _ref2.getLicense,
      removeSession = _ref2.removeSession,
      eventBus = _ref2.eventBus;

  if (video.mediaKeysObject) {
    makeNewRequest({
      mediaKeys: video.mediaKeysObject,
      initDataType: initDataType,
      initData: initData,
      options: options,
      getLicense: getLicense,
      removeSession: removeSession,
      eventBus: eventBus
    });
  } else {
    video.pendingSessionData.push({ initDataType: initDataType, initData: initData });
  }
};

var setMediaKeys = function setMediaKeys(_ref3) {
  var video = _ref3.video,
      certificate = _ref3.certificate,
      createdMediaKeys = _ref3.createdMediaKeys,
      options = _ref3.options,
      getLicense = _ref3.getLicense,
      removeSession = _ref3.removeSession,
      eventBus = _ref3.eventBus;

  video.mediaKeysObject = createdMediaKeys;

  if (certificate) {
    createdMediaKeys.setServerCertificate(certificate);
  }

  for (var i = 0; i < video.pendingSessionData.length; i++) {
    var data = video.pendingSessionData[i];

    makeNewRequest({
      mediaKeys: video.mediaKeysObject,
      initDataType: data.initDataType,
      initData: data.initData,
      options: options,
      getLicense: getLicense,
      removeSession: removeSession,
      eventBus: eventBus
    });
  }

  video.pendingSessionData = [];

  return video.setMediaKeys(createdMediaKeys);
};

var defaultPlayreadyGetLicense = function defaultPlayreadyGetLicense(url) {
  return function (emeOptions, keyMessage, callback) {
    requestPlayreadyLicense(url, keyMessage, function (err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }

      callback(null, responseBody);
    });
  };
};

var defaultGetLicense = function defaultGetLicense(url) {
  return function (emeOptions, keyMessage, callback) {
    videojs.xhr({
      uri: url,
      method: 'POST',
      responseType: 'arraybuffer',
      body: keyMessage,
      headers: {
        'Content-type': 'application/octet-stream'
      }
    }, function (err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }

      callback(null, responseBody);
    });
  };
};

var promisifyGetLicense = function promisifyGetLicense(getLicenseFn, eventBus) {
  return function (emeOptions, keyMessage) {
    return new Promise(function (resolve, reject) {
      getLicenseFn(emeOptions, keyMessage, function (err, license) {
        if (eventBus) {
          eventBus.trigger('licenserequestattempted');
        }
        if (err) {
          reject(err);
        }

        resolve(license);
      });
    });
  };
};

var standardizeKeySystemOptions = function standardizeKeySystemOptions(keySystem, keySystemOptions) {
  if (typeof keySystemOptions === 'string') {
    keySystemOptions = { url: keySystemOptions };
  }

  if (!keySystemOptions.url && !keySystemOptions.getLicense) {
    throw new Error('Neither URL nor getLicense function provided to get license');
  }

  if (keySystemOptions.url && !keySystemOptions.getLicense) {
    keySystemOptions.getLicense = keySystem === 'com.microsoft.playready' ? defaultPlayreadyGetLicense(keySystemOptions.url) : defaultGetLicense(keySystemOptions.url);
  }

  return keySystemOptions;
};

var standard5July2016 = function standard5July2016(_ref4) {
  var video = _ref4.video,
      initDataType = _ref4.initDataType,
      initData = _ref4.initData,
      options = _ref4.options,
      removeSession = _ref4.removeSession,
      eventBus = _ref4.eventBus;

  var keySystemPromise = Promise.resolve();

  if (typeof video.mediaKeysObject === 'undefined') {
    // Prevent entering this path again.
    video.mediaKeysObject = null;

    // Will store all initData until the MediaKeys is ready.
    video.pendingSessionData = [];

    var certificate = void 0;
    var keySystemOptions = void 0;

    keySystemPromise = getSupportedKeySystem(options.keySystems);

    if (!keySystemPromise) {
      videojs.log.error('No supported key system found');
      return Promise.resolve();
    }

    keySystemPromise = keySystemPromise.then(function (keySystemAccess) {
      return new Promise(function (resolve, reject) {
        // save key system for adding sessions
        video.keySystem = keySystemAccess.keySystem;

        keySystemOptions = standardizeKeySystemOptions(keySystemAccess.keySystem, options.keySystems[keySystemAccess.keySystem]);

        if (!keySystemOptions.getCertificate) {
          resolve(keySystemAccess);
          return;
        }

        keySystemOptions.getCertificate(options, function (err, cert) {
          if (err) {
            reject(err);
            return;
          }

          certificate = cert;

          resolve(keySystemAccess);
        });
      });
    }).then(function (keySystemAccess) {
      return keySystemAccess.createMediaKeys();
    }).then(function (createdMediaKeys) {
      return setMediaKeys({
        video: video,
        certificate: certificate,
        createdMediaKeys: createdMediaKeys,
        options: options,
        getLicense: promisifyGetLicense(keySystemOptions.getLicense, eventBus),
        removeSession: removeSession,
        eventBus: eventBus
      });
    })['catch'](videojs.log.error.bind(videojs.log.error, 'Failed to create and initialize a MediaKeys object'));
  }

  return keySystemPromise.then(function () {
    addSession({
      video: video,
      initDataType: initDataType,
      initData: initData,
      options: options,
      // if key system has not been determined then addSession doesn't need getLicense
      getLicense: video.keySystem ? promisifyGetLicense(standardizeKeySystemOptions(video.keySystem, options.keySystems[video.keySystem]).getLicense, eventBus) : null,
      removeSession: removeSession,
      eventBus: eventBus
    });
  });
};

var stringToUint16Array = function stringToUint16Array(string) {
  // 2 bytes for each char
  var buffer = new ArrayBuffer(string.length * 2);
  var array = new Uint16Array(buffer);

  for (var i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i);
  }

  return array;
};





var uint8ArrayToString = function uint8ArrayToString(array) {
  return String.fromCharCode.apply(null, new Uint16Array(array.buffer));
};

var getHostnameFromUri = function getHostnameFromUri(uri) {
  var link = document_1.createElement('a');
  uri = uri.match(/.*(skd\:\/\/.+)/i)[1];
  link.href = uri;
  return link.hostname;
};

var arrayBuffersEqual = function arrayBuffersEqual(arrayBuffer1, arrayBuffer2) {
  if (arrayBuffer1 === arrayBuffer2) {
    return true;
  }

  if (arrayBuffer1.byteLength !== arrayBuffer2.byteLength) {
    return false;
  }

  var dataView1 = new DataView(arrayBuffer1);
  var dataView2 = new DataView(arrayBuffer2);

  for (var i = 0; i < dataView1.byteLength; i++) {
    if (dataView1.getUint8(i) !== dataView2.getUint8(i)) {
      return false;
    }
  }

  return true;
};

var arrayBufferFrom = function arrayBufferFrom(bufferOrTypedArray) {
  if (bufferOrTypedArray instanceof Uint8Array || bufferOrTypedArray instanceof Uint16Array) {
    return bufferOrTypedArray.buffer;
  }

  return bufferOrTypedArray;
};

var FAIRPLAY_KEY_SYSTEM = 'com.apple.fps.1_0';

var concatInitDataIdAndCertificate = function concatInitDataIdAndCertificate(_ref) {
  var initData = _ref.initData,
      id = _ref.id,
      cert = _ref.cert;

  if (typeof id === 'string') {
    id = stringToUint16Array(id);
  }

  // layout:
  //   [initData]
  //   [4 byte: idLength]
  //   [idLength byte: id]
  //   [4 byte:certLength]
  //   [certLength byte: cert]
  var offset = 0;
  var buffer = new ArrayBuffer(initData.byteLength + 4 + id.byteLength + 4 + cert.byteLength);
  var dataView = new DataView(buffer);
  var initDataArray = new Uint8Array(buffer, offset, initData.byteLength);

  initDataArray.set(initData);
  offset += initData.byteLength;

  dataView.setUint32(offset, id.byteLength, true);
  offset += 4;

  var idArray = new Uint16Array(buffer, offset, id.length);

  idArray.set(id);
  offset += idArray.byteLength;

  dataView.setUint32(offset, cert.byteLength, true);
  offset += 4;

  var certArray = new Uint8Array(buffer, offset, cert.byteLength);

  certArray.set(cert);

  return new Uint8Array(buffer, 0, buffer.byteLength);
};

var addKey = function addKey(_ref2) {
  var video = _ref2.video,
      contentId = _ref2.contentId,
      initData = _ref2.initData,
      cert = _ref2.cert,
      options = _ref2.options,
      getLicense = _ref2.getLicense,
      eventBus = _ref2.eventBus;

  return new Promise(function (resolve, reject) {
    if (!video.webkitKeys) {
      video.webkitSetMediaKeys(new window_1.WebKitMediaKeys(FAIRPLAY_KEY_SYSTEM));
    }

    if (!video.webkitKeys) {
      reject('Could not create MediaKeys');
      return;
    }
    console.log('fairplay createSession');
    console.log('fairplay contentId & initData', contentId, initData);
    var keySession = video.webkitKeys.createSession('video/mp4', concatInitDataIdAndCertificate({ id: contentId, initData: initData, cert: cert }));

    if (!keySession) {
      reject('Could not create key session');
      return;
    }

    keySession.contentId = contentId;

    keySession.addEventListener('webkitkeymessage', function (event) {
      getLicense(options, contentId, event, function (err, license) {
        if (eventBus) {
          eventBus.trigger('licenserequestattempted');
        }
        if (err) {
          reject(err);
          return;
        }
        keySession.update(new Uint8Array(license));
        // keySession.update(base64DecodeUint8Array(license));
        // keySession.update(license);
      });
    });

    keySession.addEventListener('webkitkeyadded', function (event) {
      resolve(event);
    });

    // for testing purposes, adding webkitkeyerror must be the last item in this method
    keySession.addEventListener('webkitkeyerror', function (event) {
      reject(event);
    });
  });
};

var defaultGetCertificate = function defaultGetCertificate(certificateUri) {
  return function (emeOptions, callback) {
    videojs.xhr({
      uri: certificateUri,
      responseType: 'arraybuffer'
    }, function (err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }
      console.log('fairplay get certificate', responseBody);
      callback(null, new Uint8Array(responseBody));
    });
  };
};

var defaultGetContentId = function defaultGetContentId(emeOptions, initData) {
  return getHostnameFromUri(uint8ArrayToString(initData));
};

var defaultGetLicense$1 = function defaultGetLicense(licenseUri) {
  return function (emeOptions, contentId, event, callback) {
    videojs.xhr({
      uri: licenseUri,
      method: 'POST',
      responseType: 'arraybuffer',
      // responseType: 'text',
      body: event.message,
      // body: 'spc='+base64EncodeUint8Array(event.message)+'&assetId='+encodeURIComponent(contentId),
      headers: {
        // 'Content-type': 'application/octet-stream'
        'Content-type': 'application/x-www-form-urlencoded'
      }
    }, function (err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }
      console.log('fairplay get license success', response, responseBody);
      // console.log('fairplay get license success key ', key);
      callback(null, responseBody);
    });
  };
};

var fairplay = function fairplay(_ref3) {
  var video = _ref3.video,
      initData = _ref3.initData,
      options = _ref3.options,
      eventBus = _ref3.eventBus;

  var fairplayOptions = options.keySystems[FAIRPLAY_KEY_SYSTEM];
  var getCertificate = fairplayOptions.getCertificate || defaultGetCertificate(fairplayOptions.certificateUri);
  var getContentId = fairplayOptions.getContentId || defaultGetContentId;
  var getLicense = fairplayOptions.getLicense || defaultGetLicense$1(fairplayOptions.licenseUri);

  return new Promise(function (resolve, reject) {
    getCertificate(options, function (err, cert) {
      if (err) {
        reject(err);
        return;
      }

      resolve(cert);
    });
  }).then(function (cert) {
    return addKey({
      video: video,
      cert: cert,
      initData: initData,
      getLicense: getLicense,
      options: options,
      contentId: getContentId(options, initData),
      eventBus: eventBus
    });
  })['catch'](function (event) {
    eventBus.player_.error({ code: 3, message: event });
  });
};

var PLAYREADY_KEY_SYSTEM = 'com.microsoft.playready';

var addKeyToSession = function addKeyToSession(options, session, event, eventBus) {
  var playreadyOptions = options.keySystems[PLAYREADY_KEY_SYSTEM];

  if (typeof playreadyOptions.getKey === 'function') {
    playreadyOptions.getKey(options, event.destinationURL, event.message.buffer, function (err, key) {
      if (err) {
        videojs.log.error('Unable to get key: ' + err);
        return;
      }

      session.update(key);
    });
    return;
  }

  if (typeof playreadyOptions === 'string') {
    playreadyOptions = { url: playreadyOptions };
  }

  var url = playreadyOptions.url || event.destinationURL;

  requestPlayreadyLicense(url, event.message.buffer, function (err, response) {
    if (eventBus) {
      eventBus.trigger('licenserequestattempted');
    }
    if (err) {
      videojs.log.error('Unable to request key from url: ' + url);
      return;
    }

    session.update(new Uint8Array(response.body));
  });
};

var createSession = function createSession(video, initData, options, eventBus) {
  var session = video.msKeys.createSession('video/mp4', initData);

  if (!session) {
    videojs.log.error('Could not create key session.');
    return;
  }

  // Note that mskeymessage may not always be called for PlayReady:
  //
  // "If initData contains a PlayReady object that contains an OnDemand header, only a
  // keyAdded event is returned (as opposed to a keyMessage event as described in the
  // Encrypted Media Extension draft). Similarly, if initData contains a PlayReady object
  // that contains a key identifier in the hashed data storage (HDS), only a keyAdded
  // event is returned."
  // eslint-disable-next-line max-len
  // @see [PlayReady License Acquisition]{@link https://msdn.microsoft.com/en-us/library/dn468979.aspx}
  session.addEventListener('mskeymessage', function (event) {
    addKeyToSession(options, session, event, eventBus);
  });

  session.addEventListener('mskeyerror', function (event) {
    videojs.log.error('Unexpected key error from key session with ' + ('code: ' + session.error.code + ' and systemCode: ' + session.error.systemCode));
  });
};

var msPrefixed = (function (_ref) {
  var video = _ref.video,
      initData = _ref.initData,
      options = _ref.options,
      eventBus = _ref.eventBus;

  // Although by the standard examples the presence of video.msKeys is checked first to
  // verify that we aren't trying to create a new session when one already exists, here
  // sessions are managed earlier (on the player.eme object), meaning that at this point
  // any existing keys should be cleaned up.
  if (video.msKeys) {
    delete video.msKeys;
  }

  try {
    video.msSetMediaKeys(new window_1.MSMediaKeys(PLAYREADY_KEY_SYSTEM));
  } catch (e) {
    videojs.log.error('Unable to create media keys for PlayReady key system. Error: ' + e.message);
    return;
  }

  createSession(video, initData, options, eventBus);
});

var Plugin$18 = videojs.getPlugin('plugin');

var hasSession = function hasSession(sessions, initData) {
  for (var i = 0; i < sessions.length; i++) {
    // Other types of sessions may be in the sessions array that don't store the initData
    // (for instance, PlayReady sessions on IE11).
    if (!sessions[i].initData) {
      continue;
    }

    // initData should be an ArrayBuffer by the spec:
    // eslint-disable-next-line max-len
    // @see [Media Encrypted Event initData Spec]{@link https://www.w3.org/TR/encrypted-media/#mediaencryptedeventinit}
    //
    // However, on some browsers it may come back with a typed array view of the buffer.
    // This is the case for IE11, however, since IE11 sessions are handled differently
    // (following the msneedkey PlayReady path), this coversion may not be important. It
    // is safe though, and might be a good idea to retain in the short term (until we have
    // catalogued the full range of browsers and their implementations).
    var sessionBuffer = arrayBufferFrom(sessions[i].initData);
    var initDataBuffer = arrayBufferFrom(initData);

    if (arrayBuffersEqual(sessionBuffer, initDataBuffer)) {
      return true;
    }
  }

  return false;
};

var removeSession = function removeSession(sessions, initData) {
  for (var i = 0; i < sessions.length; i++) {
    if (sessions[i].initData === initData) {
      sessions.splice(i, 1);
      return;
    }
  }
};

var handleEncryptedEvent = function handleEncryptedEvent(event, options, sessions, eventBus) {

  if (!options || !options.keySystems || options.src && options.src.indexOf('m3u8') > -1) {
    // return silently since it may be handled by a different system
    return Promise.resolve();
  }

  var initData = event.initData;

  return getSupportedKeySystem(options.keySystems).then(function (_ref) {
    var keySystem = _ref.keySystem;

    // Use existing init data from options if provided
    if (options.keySystems[keySystem] && options.keySystems[keySystem].pssh) {
      initData = options.keySystems[keySystem].pssh;
    }

    // "Initialization Data must be a fixed value for a given set of stream(s) or media
    // data. It must only contain information related to the keys required to play a given
    // set of stream(s) or media data."
    // eslint-disable-next-line max-len
    // @see [Initialization Data Spec]{@link https://www.w3.org/TR/encrypted-media/#initialization-data}
    if (hasSession(sessions, initData) || !initData) {
      // TODO convert to videojs.log.debug and add back in
      // https://github.com/videojs/video.js/pull/4780
      // videojs.log('eme',
      //             'Already have a configured session for init data, ignoring event.');
      return;
    }

    sessions.push({ initData: initData });

    return standard5July2016({
      video: event.target,
      initDataType: event.initDataType,
      initData: initData,
      options: options,
      removeSession: removeSession.bind(null, sessions),
      eventBus: eventBus
    });
  });
};

var handleWebKitNeedKeyEvent = function handleWebKitNeedKeyEvent(event, options, eventBus) {
  if (!options.keySystems || !options.keySystems[FAIRPLAY_KEY_SYSTEM] || !event.initData) {
    // return silently since it may be handled by a different system
    return;
  }

  // From Apple's example Safari FairPlay integration code, webkitneedkey is not repeated
  // for the same content. Unless documentation is found to present the opposite, handle
  // all webkitneedkey events the same (even if they are repeated).

  return fairplay({
    video: event.target,
    initData: event.initData,
    options: options,
    eventBus: eventBus
  });
};

var handleMsNeedKeyEvent = function handleMsNeedKeyEvent(event, options, sessions, eventBus) {
  if (!options.keySystems || !options.keySystems[PLAYREADY_KEY_SYSTEM]) {
    // return silently since it may be handled by a different system
    return;
  }

  // "With PlayReady content protection, your Web app must handle the first needKey event,
  // but it must then ignore any other needKey event that occurs."
  // eslint-disable-next-line max-len
  // @see [PlayReady License Acquisition]{@link https://msdn.microsoft.com/en-us/library/dn468979.aspx}
  //
  // Usually (and as per the example in the link above) this is determined by checking for
  // the existence of video.msKeys. However, since the video element may be reused, it's
  // easier to directly manage the session.
  if (sessions.reduce(function (acc, session) {
    return acc || session.playready;
  }, false)) {
    // TODO convert to videojs.log.debug and add back in
    // https://github.com/videojs/video.js/pull/4780
    // videojs.log('eme',
    //             'An \'msneedkey\' event was receieved earlier, ignoring event.');
    return;
  }

  var initData = event.initData;

  // Use existing init data from options if provided
  if (options.keySystems[PLAYREADY_KEY_SYSTEM] && options.keySystems[PLAYREADY_KEY_SYSTEM].pssh) {
    initData = options.keySystems[PLAYREADY_KEY_SYSTEM].pssh;
  }

  if (!initData) {
    return;
  }

  sessions.push({ playready: true, initData: initData });

  msPrefixed({
    video: event.target,
    initData: initData,
    options: options,
    eventBus: eventBus
  });
};

var getOptions = function getOptions(player) {
  return videojs.mergeOptions(player.currentSource(), player.eme.options);
};

/**
 * Configure a persistent sessions array and activeSrc property to ensure we properly
 * handle each independent source's events. Should be run on any encrypted or needkey
 * style event to ensure that the sessions reflect the active source.
 *
 * @function setupSessions
 * @param    {Player} player
 */
var setupSessions = function setupSessions(player) {
  var src = player.src();
  if (src !== player.eme.activeSrc) {
    player.eme.activeSrc = src;
    player.eme.sessions = [];
  }
};

/**
 * Function to invoke when the player is ready.
 *
 * This is a great place for your plugin to initialize itself. When this
 * function is called, the player will have its DOM and child components
 * in place.
 *
 * @function onPlayerReady
 * @param    {Player} player
 * @param    {Object} [options={}]
 */
var onPlayerReady = function onPlayerReady(player) {
  if (player.$('.vjs-tech').tagName.toLowerCase() !== 'video' || !player.tech_) {
    return;
  }

  setupSessions(player);

  // Support EME 05 July 2016
  // Chrome 42+, Firefox 47+, Edge
  player.tech_.el_.addEventListener('encrypted', function (event) {
    // TODO convert to videojs.log.debug and add back in
    // https://github.com/videojs/video.js/pull/4780
    // videojs.log('eme', 'Received an \'encrypted\' event');
    // skip dash widevine encrypted event , because dash.js resolve it.
    if (player.currentSource().keySystems && player.currentSource().keySystems['com.widevine.alpha'] && player.currentSource().type === 'application/dash+xml') {
      return false;
    }
    setupSessions(player);
    handleEncryptedEvent(event, getOptions(player), player.eme.sessions, player.tech_);
  });
  // Support Safari EME with FairPlay
  // (also used in early Chrome or Chrome with EME disabled flag)
  player.tech_.el_.addEventListener('webkitneedkey', function (event) {
    // TODO convert to videojs.log.debug and add back in
    // https://github.com/videojs/video.js/pull/4780
    // videojs.log('eme', 'Received a \'webkitneedkey\' event');

    // TODO it's possible that the video state must be cleared if reusing the same video
    // element between sources
    setupSessions(player);
    handleWebKitNeedKeyEvent(event, getOptions(player), player.tech_);
  });

  // EDGE still fires msneedkey, but should use encrypted instead
  if (videojs.browser.IS_EDGE) {
    return;
  }

  // IE11 Windows 8.1+
  player.tech_.el_.addEventListener('msneedkey', function (event) {
    // TODO convert to videojs.log.debug and add back in
    // https://github.com/videojs/video.js/pull/4780
    // videojs.log('eme', 'Received an \'msneedkey\' event');
    setupSessions(player);
    handleMsNeedKeyEvent(event, getOptions(player), player.eme.sessions, player.tech_);
  });
};

/**
 * A video.js plugin.
 *
 * In the plugin function, the value of `this` is a video.js `Player`
 * instance. You cannot rely on the player being in a "ready" state here,
 * depending on how the plugin is invoked. This may or may not be important
 * to you; if not, remove the wait for "ready"!
 *
 * @function eme
 * @param    {Object} [options={}]
 *           An object of options left to the plugin author to define.
 */
// const DRM = function(options = {}) {
//   const player = this;
//
//   player.ready(() => onPlayerReady(player));
//
//   // Plugin API
//   player.eme = {
//     /**
//     * Sets up MediaKeys on demand
//     * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449
//     *
//     * @function initializeMediaKeys
//     * @param    {Object} [emeOptions={}]
//     *           An object of eme plugin options.
//     * @param    {Function} [callback=function(){}]
//     */
//     initializeMediaKeys(emeOptions = {}, callback = function() {}) {
//       // TODO: this should be refactored and renamed to be less tied
//       // to encrypted events
//       const mergedEmeOptions = videojs.mergeOptions(
//         player.currentSource(),
//         options,
//         emeOptions
//       );
//
//       // fake an encrypted event for handleEncryptedEvent
//       const mockEncryptedEvent = {
//         initDataType: 'cenc',
//         initData: null,
//         target: player.tech_.el_
//       };
//
//       setupSessions(player);
//
//       if (player.tech_.el_.setMediaKeys) {
//         handleEncryptedEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_)
//           .then(() => callback())
//           .catch((error) => callback(error));
//       } else if (player.tech_.el_.msSetMediaKeys) {
//         handleMsNeedKeyEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_);
//         callback();
//       }
//     },
//     options
//   };
// };

var DRM = function (_Plugin) {
  inherits(DRM, _Plugin);

  function DRM(player, options) {
    classCallCheck(this, DRM);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    player.ready(function () {
      return onPlayerReady(player);
    });

    player.eme = {
      /**
      * Sets up MediaKeys on demand
      * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449
      *
      * @function initializeMediaKeys
      * @param    {Object} [emeOptions={}]
      *           An object of eme plugin options.
      * @param    {Function} [callback=function(){}]
      */
      initializeMediaKeys: function initializeMediaKeys() {
        var emeOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

        // TODO: this should be refactored and renamed to be less tied
        // to encrypted events
        var mergedEmeOptions = videojs.mergeOptions(player.currentSource(), options, emeOptions);

        // fake an encrypted event for handleEncryptedEvent
        var mockEncryptedEvent = {
          initDataType: 'cenc',
          initData: null,
          target: player.tech_.el_
        };

        setupSessions(player);

        if (player.tech_.el_.setMediaKeys) {
          handleEncryptedEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_).then(function () {
            return callback();
          })['catch'](function (error) {
            return callback(error);
          });
        } else if (player.tech_.el_.msSetMediaKeys) {
          handleMsNeedKeyEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_);
          callback();
        }
      },

      options: options
    };
    return _this;
  }

  DRM.prototype.setOptions = function setOptions(options) {
    this.options = options;
    this.player.options_.plugins.DRM = options;

    // Token=Base64(RSADecrypt(PriKey, DecodeBase64(Token)))
    // window.atob(encodedData);

    // window.btoa(stringToEncode)
  };
  // initializeMediaKeys(emeOptions = {}, callback = function() {}) {
  //   // TODO: this should be refactored and renamed to be less tied
  //   // to encrypted events
  //   const mergedEmeOptions = videojs.mergeOptions(
  //     player.currentSource(),
  //     options,
  //     emeOptions
  //   );
  //
  //   // fake an encrypted event for handleEncryptedEvent
  //   const mockEncryptedEvent = {
  //     initDataType: 'cenc',
  //     initData: null,
  //     target: player.tech_.el_
  //   };
  //
  //   setupSessions(player);
  //
  //   if (player.tech_.el_.setMediaKeys) {
  //     handleEncryptedEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_)
  //       .then(() => callback())
  //       .catch((error) => callback(error));
  //   } else if (player.tech_.el_.msSetMediaKeys) {
  //     handleMsNeedKeyEvent(mockEncryptedEvent, mergedEmeOptions, player.eme.sessions, player.tech_);
  //     callback();
  //   }
  // }


  return DRM;
}(Plugin$18);

// Register the plugin with video.js.


var registerPlugin$2 = videojs.registerPlugin || videojs.plugin;

registerPlugin$2('DRM', DRM);

var Plugin$19 = videojs.getPlugin('plugin');
var dom$2 = videojs.dom;

// polyfill
if (!window.requestAnimationFrame) {
  var lastTime = 0;
  window.requestAnimationFrame = function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
}

var DynamicWatermark = function (_Plugin) {
  inherits(DynamicWatermark, _Plugin);

  /**
   *
   * @param player
   * @param options
   * options.content
   * options.speed
   */
  function DynamicWatermark(player, options) {
    classCallCheck(this, DynamicWatermark);

    var _this = possibleConstructorReturn(this, _Plugin.call(this, player));

    _this.options = options;
    if (!!options.content) {
      _this.init();
    }
    return _this;
  }

  DynamicWatermark.prototype.dispose = function dispose() {
    this.stopAnimation();
    this.player.el().removeChild(this.containerElement);
    _Plugin.prototype.dispose.call(this);
  };

  DynamicWatermark.prototype.init = function init() {
    var _this2 = this;

    //  1.获取视频宽高
    //  2.获取播放器宽高
    //  3.采用归一化数值,确定水印区域和坐标,注意播放器尺寸变化的影响
    //  4.初始化显示组件
    //  5.显示文本水印,并随机移动
    //  6.确保相关dom一直在html中
    var player = this.player;
    this.initUI();
    this.initStyle();
    player.on('loadedmetadata', function () {
      _this2.calculateStyle();
      _this2.setStyle();
      dom$2.removeClass(_this2.containerElement, 'vjs-hidden');
    });

    player.one('play', function () {
      _this2.startAnimation();
    });

    player.on(['fullscreenchange', 'playerresize'], function () {
      // console.log('fullscreenchange');
      // 如果立即进行计算尺寸和位置，获取到的播放器宽高会不准，此时播放器容器在重绘中。
      setTimeout(function () {
        _this2.calculateStyle();
      }, 200);
    });
  };

  DynamicWatermark.prototype.initUI = function initUI() {
    var player = this.player;
    // init UI
    var containerElement = dom$2.createEl('div', {
      className: 'tcp-dynamic-watermark-container vjs-hidden'
    });
    var markContentElement = dom$2.createEl('div', {
      innerHTML: encodeHTML(this.options.content),
      className: 'tcp-dynamic-watermark-content'
    });
    containerElement.appendChild(markContentElement);
    player.el().appendChild(containerElement);
    this.containerElement = containerElement;
    this.markContentElement = markContentElement;

    if (this.options.type === 'image') {
      var imgNode = document.createElement('img');
      this.options.width && (imgNode.style.width = this.options.width);
      this.options.height && (imgNode.style.height = this.options.height);
      imgNode.setAttribute('src', this.options.content);
      this.markContentElement.innerHTML = '';
      this.markContentElement.appendChild(imgNode);
    }
  };

  DynamicWatermark.prototype.initStyle = function initStyle() {
    this.style = {
      containerWidth: '',
      containerHeight: '',
      containerLeft: '',
      containerTop: '',
      contentLeft: Math.random() * 80,
      contentTop: Math.random() * 80,
      margin: 0,
      padding: 0,
      display: 'block',
      visibility: 'visible',
      opacity: 0.5,
      position: 'absolute',
      color: 'rgba(255, 255, 255)'
    };
  };

  DynamicWatermark.prototype.calculateStyle = function calculateStyle() {
    var player = this.player;
    var style = this.style;
    var videoWidth = player.videoWidth();
    var videoHeight = player.videoHeight();
    var playerClientRect = dom$2.getBoundingClientRect(player.el());
    var playerWith = playerClientRect.width,
        playerHeight = playerClientRect.height;
    // 以 16:9 为基准， 小于 16:9为竖屏，大于 16:9为宽屏，定位视频在播放器的实际区域
    var playerRatio = (playerWith / playerHeight).toFixed(2);
    var videoRatio = (videoWidth / videoHeight).toFixed(2);
    var frameWidth = void 0,
        frameHeight = void 0;
    if (videoRatio < playerRatio) {
      frameHeight = playerHeight;
      frameWidth = frameHeight * videoRatio;
    } else if (videoRatio > playerRatio) {
      frameWidth = playerWith;
      frameHeight = frameWidth / videoRatio;
    } else if (videoRatio == playerRatio) {
      frameWidth = playerWith;
      frameHeight = playerHeight;
    }
    // console.log(videoWidth, videoHeight, playerWith, playerHeight);
    style.containerLeft = (playerWith - frameWidth) / 2 / playerWith * 100;
    style.containerTop = (playerHeight - frameHeight) / 2 / playerHeight * 100;
    style.containerWidth = frameWidth / playerWith * 100;
    style.containerHeight = frameHeight / playerHeight * 100;
  };

  DynamicWatermark.prototype.setStyle = function setStyle() {
    var containerElement = this.containerElement,
        markContentElement = this.markContentElement,
        style = this.style;
    containerElement.style.left = style.containerLeft + '%';
    containerElement.style.top = style.containerTop + '%';
    containerElement.style.width = style.containerWidth + '%';
    containerElement.style.height = style.containerHeight + '%';
    containerElement.style.display = markContentElement.style.display = style.display;
    containerElement.style.visibility = markContentElement.style.visibility = style.visibility;
    containerElement.style.opacity = markContentElement.style.opacity = style.opacity;
    containerElement.style.position = markContentElement.style.position = style.position;
    containerElement.style.margin = markContentElement.style.margin = style.margin;
    containerElement.style.padding = markContentElement.style.padding = style.padding;

    markContentElement.style.left = this.options.left || style.contentLeft + '%';
    markContentElement.style.top = this.options.top || style.contentTop + '%';
    this.options.right && (markContentElement.style.right = this.options.right);
    this.options.bottom && (markContentElement.style.bottom = this.options.bottom);

    markContentElement.style.color = this.options.color || style.color;
    containerElement.style.opacity = markContentElement.style.opacity = this.options.opacity || style.opacity;

    if (this.options.type === 'text') {
      markContentElement.style.fontSize = this.options.fontSize || '12px';
      markContentElement.innerHTML = encodeHTML(this.options.content);
    }
  };

  DynamicWatermark.prototype.setContent = function setContent(content) {
    this.options.content = content;
  };

  DynamicWatermark.prototype.startAnimation = function startAnimation() {
    var _this3 = this;

    if (this.rafID) {
      return;
    }
    var player = this.player;
    var style = this.style;
    var containerElement = this.containerElement,
        markContentElement = this.markContentElement;
    var xDirection = 1,
        yDirection = 1;
    var random = Math.random();
    var render = function render() {
      try {
        if (!_this3.isPauseAnimation) {
          var speed = Math.min(1, _this3.options.speed === 0 ? 0 : _this3.options.speed ? _this3.options.speed : 0.2);
          var containerClientRect = dom$2.getBoundingClientRect(containerElement),
              contentClientRect = dom$2.getBoundingClientRect(markContentElement);
          // console.log(contentClientRect);
          var left = contentClientRect.left - containerClientRect.left,
              top = contentClientRect.top - containerClientRect.top;
          // console.log(left, top);
          left += speed * xDirection * random;
          top += speed * yDirection * (1 - random);

          if (left + contentClientRect.width > containerClientRect.width) {
            xDirection = -1;
            random = Math.random();
          } else if (left < 0) {
            xDirection = 1;
            random = Math.random();
          }
          if (top + contentClientRect.height > containerClientRect.height) {
            yDirection = -1;
            random = Math.random();
          } else if (top < 0) {
            yDirection = 1;
            random = Math.random();
          }
          left = Math.min(containerClientRect.width - contentClientRect.width, left);
          top = Math.min(containerClientRect.height - contentClientRect.height, top);

          // markContentElement.style.left = left/containerClientRect.width*100 + '%';
          // markContentElement.style.top = top/containerClientRect.height*100 + '%';
          style.contentLeft = left / containerClientRect.width * 100;
          style.contentTop = top / containerClientRect.height * 100;
          _this3.setStyle();
        }
      } catch (exception) {
        // 被移除元素后重新添加到dom节点里
        // console.log(dom.$('.tcp-dynamic-watermark-container'), dom.$('.tcp-dynamic-watermark-content'), this);
        if (!player.$('.tcp-dynamic-watermark-container')) {
          player.el() && player.el().appendChild(containerElement);
        } else if (!player.$('.tcp-dynamic-watermark-content')) {
          containerElement.appendChild(markContentElement);
        }
      }
      if (_this3.isStopAnimation) {
        _this3.isStopAnimation = false;
        cancelAnimationFrame(_this3.rafID);
        _this3.rafID = null;
        return;
      }
      if (_this3.options.speed !== 0) {
        requestAnimationFrame(render);
      }
    };
    this.rafID = requestAnimationFrame(render);
  };

  DynamicWatermark.prototype.resumeAnimation = function resumeAnimation() {
    this.isPauseAnimation = false;
  };

  DynamicWatermark.prototype.pauseAnimation = function pauseAnimation() {
    this.isPauseAnimation = true;
  };

  DynamicWatermark.prototype.stopAnimation = function stopAnimation() {
    this.isStopAnimation = true;
  };

  return DynamicWatermark;
}(Plugin$19);

videojs.registerPlugin('DynamicWatermark', DynamicWatermark);

var defaultConfig$1 = {
  enableStashBuffer: false
};

var Html5FlvJS = function () {
  function Html5FlvJS(source, tech, options) {
    var _this = this;

    classCallCheck(this, Html5FlvJS);

    var createInstance = function createInstance() {
      var flvjs = window.flvjs;
      _this.flvjs = flvjs;
      var flv = new flvjs.createPlayer({
        isLive: false,
        url: source.src,
        type: 'flv'
      }, videojs.mergeOptions(defaultConfig$1, options.flvConfig));
      _this.tech = tech;
      flv.on(flvjs.Events.ERROR, videojs.bind(_this, _this.onError));
      //监听所有flv.js事件

      var _loop = function _loop(eventName) {
        flv.on(flvjs.Events[eventName], videojs.bind(_this, function (event) {
          this.onEvent(eventName, event);
        }));
      };

      for (var eventName in flvjs.Events) {
        _loop(eventName);
      }
      _this.flv = flv;
      _this._id = new Date().getTime();
      // 从webrtc切换过来，清除video内部状态，否则flv会无法播放
      if (tech.el().srcObject) {
        tech.el().srcObject = null;
      }
      flv.attachMediaElement(tech.el());
      flv.load();
    };

    if (!window.flvjs) {
      loadScript(FLV_PATH, function () {
        createInstance();
      });
    } else {
      createInstance();
    }
  }

  Html5FlvJS.prototype.onError = function onError(errorType, message, source) {
    console.log('flvjs onError', arguments, this);
    var player = this.tech.player();
    // this.tech.player().trigger('error', event);
    if (errorType === this.flvjs.ErrorTypes.NETWORK_ERROR) {
      player.error({ code: 2, source: source });
    }
    if (errorType === this.flvjs.ErrorTypes.MEDIA_ERROR) {
      player.error({ code: 3, source: source });
    }
  };

  Html5FlvJS.prototype.onEvent = function onEvent(eventType, source) {
    // console.log('flvjs onEvent', eventType, source,  this);
    this.tech.player().trigger({ type: 'FLVJS_EVENT', data: {
        type: eventType,
        data: source
      } });
  };

  Html5FlvJS.prototype.dispose = function dispose() {
    console.log('Html5FlvJS dispose');
    this.tech.player().pause();
    // firefox 存在此错误，其他浏览器没有问题，暂吞掉此错误，保证功能顺利进行
    // https://stackoverflow.com/questions/52575527/firefox-invalidstateerror-an-attempt-was-made-to-use-an-object-that-is-not-or

    if (this.tech.flvProvider) {
      try {
        this.flv.destroy();
      } catch (e) {
        console.log('error msg:', e.message);
      }
    }

    this.tech.flvProvider = null;
  };

  return Html5FlvJS;
}();

var flvTypeRE = /^video\/flv$/i;
var flvExtRE = /\.flv/i;
var flvProtoRE = /^(ws:\/\/)/i;
var FlvSourceHandler = {
  name: 'flvSourceHandler',
  canHandleSource: function canHandleSource(source) {
    if (flvTypeRE.test(source.type)) {
      return 'probably';
    } else if (flvExtRE.test(source.src) || flvProtoRE.test(source.src)) {
      return 'maybe';
    } else {
      return '';
    }
  },
  handleSource: function handleSource(source, tech, options) {
    if (tech.flvProvider) {
      tech.flvProvider.dispose();
    }
    tech.flvProvider = new Html5FlvJS(source, tech, options);
    return tech.flvProvider;
  },
  canPlayType: function canPlayType(type) {
    if (flvTypeRE.test(type)) {
      return 'probably';
    }
  }
};

function mountFlvProvider(enforce) {
  if (videojs.browser.IS_IOS && videojs.browser.IS_MQQ) {
    // ios13手机QQ内置浏览器 支持了Mediasource sourceBuffer API 但无法用于视频播放。需特殊判断
    return false;
  }

  // PC safari 可以播放
  // flvjs && flvjs.isSupported() && 
  if (!videojs.browser.IS_TBS && !videojs.browser.IS_MQQB && !(IS_IOS && videojs.browser.IS_SAFARI) && !videojs.browser.IE_VERSION || !!enforce) {
    try {
      var html5Tech = videojs.getTech && videojs.getTech('Html5');
      if (html5Tech) {
        html5Tech.registerSourceHandler(FlvSourceHandler, 0);
      }
    } catch (e) {
      console.error('flv.js init failed');
    }
  } else {}
}
TCPlayer.mountFlvProvider = mountFlvProvider;
mountFlvProvider();

var defaultConfig$2 = {
  // 'connectRetryCount':	,//SDK 与服务器重连次数
  // 'connectRetryDelay':	,//SDK 与服务器重连延时
  'receiveVideo': true, //是否拉取视频流
  'receiveAudio': true, //是否拉取音频流
  'showLog': false //是否在控制台打印日志
};

var WebRTCProvider = function () {
  function WebRTCProvider(source, tech, options) {
    var _this = this;

    classCallCheck(this, WebRTCProvider);

    var createInstance = function createInstance() {
      console.log('WebRTCProvider constructor');
      _this.tech = tech;
      _this.playerMetrics = _this.tech.player().PlayerMetrics();
      var TXLivePlayer = window.TXLivePlayer;
      _this.TXLivePlayer = TXLivePlayer;

      // 创建播放器实例 初始化设置
      var webrtcConfig = videojs.mergeOptions(defaultConfig$2, options.webrtcConfig);
      var webrtcPlayer = new TXLivePlayer();
      // 初始化播放器，关联video
      webrtcPlayer.setPlayerView(tech.el());
      webrtcPlayer.setConfig(webrtcConfig);
      webrtcPlayer.setPlayListener({
        // 播放事件监听
        onPlayEvent: videojs.bind(_this, _this.onPlayEvent),
        // 播放数据监听
        onPlayStats: videojs.bind(_this, _this.onPlayStats),
        onPlayReport: videojs.bind(_this, _this.onPlayReport)
      });

      // v1.1.0 webrtcPlayer.startPlay 默认自动拉流并播放，需要规范 autoplay 属性的行为。
      // if (options.autoplay) {
      //   webrtcPlayer.startPlay(source.src);
      // } else {
      //   tech.player().one('play', () => {
      //     console.log('webrtcPlayer play', tech.currentSource_.src === source.src);
      //     if(tech.currentSource_.src === source.src){
      //       webrtcPlayer.startPlay(source.src);
      //     }
      //   })
      // }
      // v1.2.0
      webrtcPlayer.startPlay(source.src);
      _this.webrtcPlayer = webrtcPlayer;
    };
    if (!window.TXLivePlayer) {
      loadScript(WEBRTC_PATH, function () {
        createInstance();
      });
    } else {
      createInstance();
    }
  }

  // 事件处理 参考文档 https://git.woa.com/video_fe/tx-live-player/blob/master/docs/%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE.md


  WebRTCProvider.prototype.onPlayStats = function onPlayStats(data) {
    // console.log('webrtc onPlayStats', data);
    this.tech.player().trigger({ type: 'webrtcstats', data: data });
  };

  WebRTCProvider.prototype.onPlayEvent = function onPlayEvent(event, data) {
    console.warn('webrtc onPlayEvent', event, data);
    var player = this.tech.player();
    if (event < -2000) {
      // webrtc error event
      // PLAY_ERR_WEBRTC_FAIL	-2001	WebRTC 相关错误（比如浏览器不支持 WebRTC、设置 sdp 失败等）
      // PLAY_ERR_REQUEST_PULL_FAIL	-2002	拉流接口后台返回报错（比如流不存在、鉴权失败等）
      // PLAY_ERR_PLAY_FAIL	-2003	视频播放失败
      // PLAY_ERR_PLAY_FAIL -2003 中特定场景，自动播放被阻止（videoActive 为 true），作为回调事件暴露，与tcplayerlite保持一致返回2005
      // PLAY_ERR_SERVER_DISCONNECT	-2004	连接服务器失败，并且连接重试次数已超过设定值
      // PLAY_ERR_DECODE_FAIL	-2005	视频解码失败，自动转换协议，不对外暴露-2005
      // PLAY_ERR_REQUEST_ABR_FAIL -2006 多分辨率平滑切换接口请求失败

      if (event === -2003 && data && data.videoActive) {
        // 自动播放被阻止的事件，包括标准直播和快直播，统一到blocked事件，2005为兼容旧用户行为
        player.trigger('blocked');
        player.trigger({ type: 'webrtcevent', data: { code: 2005 } });
      }

      if (event === -2003) {
        return false;
      }
      if (event === -2005 || event === -2001 || event === -2004) {
        // 解码失败，自动转换协议播放
        this.switchPlaySource();
        return false;
      }
      player.error({ code: event, source: data });
      return false;
    }

    // 代理常规事件
    // PLAY_EVT_STREAM_BEGIN	1001	开始拉流
    // PLAY_EVT_SERVER_CONNECTED	1002	已经连接服务器
    // PLAY_EVT_PLAY_BEGIN	1003	视频播放开始
    // PLAY_EVT_PLAY_STOP	1004	停止拉流，结束视频播放
    // PLAY_EVT_SERVER_RECONNECT	1005	连接服务器失败，已启动自动重连恢复
    // PLAY_EVT_STREAM_EMPTY	1006	获取流数据为空
    // PLAY_EVT_REQUEST_PULL_BEGIN	1007	开始请求信令服务器
    // PLAY_EVT_REQUEST_PULL_SUCCESS	1008	请求信令服务器成功
    // PLAY_EVT_PLAY_WAITING_BEGIN	1009	拉流卡顿等待缓冲中
    // PLAY_EVT_PLAY_WAITING_STOP	1010	拉流卡顿结束恢复播放
    // PLAY_ERR_PLAY_FAIL 2005 自动播放被阻止，应作为回调事件而不是错误
    player.trigger({ type: 'webrtcevent', data: { code: event, data: data } });
  };

  WebRTCProvider.prototype.onPlayReport = function onPlayReport(data) {
    if (data.uint32_command === 40101) {
      this.playerMetrics.report_40101(data);
    }
    if (data.uint32_command === 40100) {
      this.playerMetrics.report_40100(data);
    }
    if (data.uint32_command === 40102) {
      this.playerMetrics.report_40102(data);
    }
  };

  WebRTCProvider.prototype.dispose = function dispose() {
    console.warn('WebRTCProvider dispose');
    if (this.webrtcPlayer) {
      this.webrtcPlayer.setPlayListener({
        onPlayEvent: function onPlayEvent() {},
        onPlayStats: function onPlayStats() {}
      });
      this.webrtcPlayer.stopPlay();
      this.webrtcPlayer.setPlayerView(videojs.dom.createEl('video'));
      //   // webrtcPlayer.destroy() 会销毁 video ，影响后续切换其他视频格式的播放,只能以这种方式规避
    }
    this.webrtcPlayer = null;
  };

  WebRTCProvider.prototype.setSource = function setSource(source) {
    var _this2 = this;

    console.log('setSource', source);
    this.webrtcPlayer.startPlay(source.src);
    this.tech.player().one('webrtcevent', function (event) {
      console.log('setSource webrtcevent', event.data);
      if (event.data.code === -1002) {
        _this2.tech.player().play();
      }
    });
  };
  /**
   * 快直播偶现切换流 播放没有反应，没有报错信息，触发play waiting事件后就没有任何行为
   * 恢复策略
   */


  WebRTCProvider.prototype.recovery = function recovery() {
    var _this3 = this;

    console.warn('webrtc prepare recovery');
    var player = this.tech.player();
    var timeout = void 0;
    // 监听 play 事件触发后监听 waiting 事件，如果 3s 内没有playing、progress事件
    player.one('waiting', function () {
      timeout = setTimeout(function () {
        player.one('webrtcevent', function (event) {
          console.warn('webrtc recovery startPlay', event);
          if (event.data.code === 1004) {
            _this3.webrtcPlayer && _this3.webrtcPlayer.startPlay(player.src());
            player.play();
            var fun = function fun(event) {
              console.warn('webrtc recovery play', event.data.code);
              if (event.data.code === 1002) {
                player.play();
                player.off('webrtcevent', fun);
              }
            };
            player.on('webrtcevent', fun);
          }
        });
        _this3.webrtcPlayer && _this3.webrtcPlayer.stopPlay();
      }, 2000);
    });
    player.one('playing', function () {
      timeout && clearTimeout(timeout);
    });
  };
  /**
   * webrtc 无法播放时自动切换成对应的 flv、hls
   * 当转换后的 flv、hls 播放失败时，将执行播放失败降级逻辑
   */


  WebRTCProvider.prototype.switchPlaySource = function switchPlaySource() {
    var player = this.tech.player();
    // player.pause();
    // this.webrtcPlayer.stopPlay();
    // 获取当前播放的 url
    // {src: 'webrtc://5664.liveplay.myqcloud.com/live/5664_harc…=f22a813b284137ed10d3259a7b5c224b&txTime=6403f7bb'}
    var currentSrc = this.tech.currentSource_.src;
    // 设置新的 sources
    var sources = this.convertProtocol(currentSrc); //  转换成 flv、hls， 优先判断flv 能否播放，然后播放hls
    console.log('switchPlaySource', sources);
    player.bigPlayButton && player.bigPlayButton.hide();
    player.posterImage && player.posterImage.hide();
    player.src(sources);
    // this.webrtcPlayer.setPlayerView(videojs.dom.createEl('div'));
    var event = videojs.browser.IS_IOS || videojs.browser.IS_ANDROID ? 'loadeddata' : 'loadedmetadata';
    // FIXME: 切换src后会触发两次播放事件，这里目前只能如下处理，待优化
    var continuePlay = function continuePlay() {
      console.log('switchPlaySource play', event);
      player.play();
      player.one('progress', function () {
        console.log('switchPlaySource progress');
        // 偶现 progress后没有播放成功，需要补一次play调用。然而如果没有第一次play， progress不一定触发。
        player.play();
        player.off(event, continuePlay);
      });
    };
    player.on(event, continuePlay);
    // 后续通过通用播放失败降级逻辑处理
  };

  WebRTCProvider.prototype.convertProtocol = function convertProtocol(src) {
    // 本函数逻辑来自vcplayer line 485，待优化
    var sources = [];
    if (src.indexOf('.sdp') > -1) {
      src = src.replace('.sdp', '.flv');
      // 关闭降级 flv ，切换flv有播放异常，还未解决
      // sources.push(src.replace('.sdp', '.flv'));
      sources.push(src.replace('.sdp', '.m3u8'));
    } else {
      var flvSrc = src.replace('webrtc://', 'https://').replace('?', '.flv?');
      if (flvSrc.indexOf('?') === -1 && flvSrc.indexOf('.flv') === -1) {
        flvSrc = flvSrc + '.flv';
      }
      hlsSrc = src.replace('webrtc://', 'https://').replace('?', '.m3u8?');
      if (hlsSrc.indexOf('?') === -1 && hlsSrc.indexOf('.m3u8') === -1) {
        hlsSrc = hlsSrc + '.m3u8';
      }
      // 关闭降级 flv ，切换flv有播放异常，还未解决
      // sources.push(flvSrc);
      sources.push(hlsSrc);
    }
    return sources;
  };

  return WebRTCProvider;
}();

// sourceHandler 用于判断tech是否可以支持这类视频播放


var webrtcTypeRE = /^webrtc/i;
var webrtcExtRE = /\.sdp/i;
var webrtcProtoRE = /^(webrtc:\/\/)/i;
var sourceHandler = {
  name: 'webrtcSourceHandler',
  canHandleSource: function canHandleSource(source) {
    if (webrtcTypeRE.test(source.type)) {
      return 'probably';
    } else if (webrtcExtRE.test(source.src) || webrtcProtoRE.test(source.src)) {
      return 'maybe';
    } else {
      return '';
    }
  },
  handleSource: function handleSource(source, tech, options) {
    if (tech.webrtcProvider) {
      tech.webrtcProvider.dispose();
    }
    tech.webrtcProvider = new WebRTCProvider(source, tech, options);
    return tech.webrtcProvider;
  },
  canPlayType: function canPlayType(type) {
    if (webrtcTypeRE.test(type)) {
      return 'probably';
    }
  }
};

function mountWebRTCProvider(enforce) {
  if (!videojs.browser.isWebRTCSupported()) {
    return false;
  }
  try {
    var html5Tech = videojs.getTech && videojs.getTech('Html5');
    if (html5Tech) {
      html5Tech.registerSourceHandler(sourceHandler, 0);
    }
  } catch (e) {
    console.error('webrtc init failed');
  }
  // })
}
mountWebRTCProvider();

/**
 * @file flash-rtmp.js
 * @module flash-rtmp
 */

/**
 * Add RTMP properties to the {@link Flash} Tech.
 *
 * @param {Flash} Flash
 *        The flash tech class.
 *
 * @mixin FlashRtmpDecorator
 *
 * @return {Flash}
 *         The flash tech with RTMP properties added.
 */
function FlashRtmpDecorator(Flash) {
  Flash.streamingFormats = {
    'rtmp/mp4': 'MP4',
    'rtmp/flv': 'FLV'
  };

  /**
   * Join connection and stream with an ampersand.
   *
   * @param {string} connection
   *        The connection string.
   *
   * @param {string} stream
   *        The stream string.
   *
   * @return {string}
   *         The connection and stream joined with an `&` character
   */
  Flash.streamFromParts = function (connection, stream) {
    return connection + '&' + stream;
  };

  /**
   * The flash parts object that contains connection and stream info.
   *
   * @typedef {Object} Flash~PartsObject
   *
   * @property {string} connection
   *           The connection string of a source, defaults to an empty string.
   *
   * @property {string} stream
   *           The stream string of the source, defaults to an empty string.
   */

  /**
   * Convert a source url into a stream and connection parts.
   *
   * @param {string} src
   *        the source url
   *
   * @return {Flash~PartsObject}
   *         The parts object that contains a connection and a stream
   */
  Flash.streamToParts = function (src) {
    var parts = {
      connection: '',
      stream: ''
    };

    if (!src) {
      return parts;
    }

    // Look for the normal URL separator we expect, '&'.
    // If found, we split the URL into two pieces around the
    // first '&'.
    var connEnd = src.search(/&(?!\w+=)/);
    var streamBegin = void 0;

    if (connEnd !== -1) {
      streamBegin = connEnd + 1;
    } else {
      // If there's not a '&', we use the last '/' as the delimiter.
      connEnd = streamBegin = src.lastIndexOf('/') + 1;
      if (connEnd === 0) {
        // really, there's not a '/'?
        connEnd = streamBegin = src.length;
      }
    }

    parts.connection = src.substring(0, connEnd);
    parts.stream = src.substring(streamBegin, src.length);

    return parts;
  };

  /**
   * Check if the source type is a streaming type.
   *
   * @param {string} srcType
   *        The mime type to check.
   *
   * @return {boolean}
   *          - True if the source type is a streaming type.
   *          - False if the source type is not a streaming type.
   */
  Flash.isStreamingType = function (srcType) {
    return srcType in Flash.streamingFormats;
  };

  // RTMP has four variations, any string starting
  // with one of these protocols should be valid

  /**
   * Regular expression used to check if the source is an rtmp source.
   *
   * @property {RegExp} Flash.RTMP_RE
   */
  Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

  /**
   * Check if the source itself is a streaming type.
   *
   * @param {string} src
   *        The url to the source.
   *
   * @return {boolean}
   *          - True if the source url indicates that the source is streaming.
   *          - False if the shource url indicates that the source url is not streaming.
   */
  Flash.isStreamingSrc = function (src) {
    return Flash.RTMP_RE.test(src);
  };

  /**
   * A source handler for RTMP urls
   * @type {Object}
   */
  Flash.rtmpSourceHandler = {};

  /**
   * Check if Flash can play the given mime type.
   *
   * @param {string} type
   *        The mime type to check
   *
   * @return {string}
   *         'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canPlayType = function (type) {
    if (Flash.isStreamingType(type)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Check if Flash can handle the source natively
   *
   * @param {Object} source
   *        The source object
   *
   * @param {Object} [options]
   *        The options passed to the tech
   *
   * @return {string}
   *         'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {
    var can = Flash.rtmpSourceHandler.canPlayType(source.type);

    if (can) {
      return can;
    }

    if (Flash.isStreamingSrc(source.src)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Pass the source to the flash object.
   *
   * @param {Object} source
   *        The source object
   *
   * @param {Flash} tech
   *        The instance of the Flash tech
   *
   * @param {Object} [options]
   *        The options to pass to the source
   */
  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {
    var srcParts = Flash.streamToParts(source.src);

    tech.setRtmpConnection(srcParts.connection);
    tech.setRtmpStream(srcParts.stream);
  };

  // Register the native source handler
  Flash.registerSourceHandler(Flash.rtmpSourceHandler);

  return Flash;
}

/**
 * Flash tech
 */
/**
 * @file flash.js
 * VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

var Tech$2 = videojs.getComponent('Tech');
var Dom$1 = videojs.dom;
var Url$1 = videojs.url;
var createTimeRange = videojs.createTimeRange;
var mergeOptions$1 = videojs.mergeOptions;

var navigator$2 = window_1 && window_1.navigator || {};

/**
 * Flash Media Controller - Wrapper for Flash Media API
 *
 * @mixes FlashRtmpDecorator
 * @mixes Tech~SouceHandlerAdditions
 * @extends Tech
 */

var Flash = function (_Tech) {
  inherits(Flash, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `Flash` Tech is ready.
   */
  function Flash(player, options, ready) {
    classCallCheck(this, Flash);

    // Set the source when ready
    var _this = possibleConstructorReturn(this, _Tech.call(this, player, options, ready));

    if (options.source) {
      _this.ready(function () {
        this.setSource(options.source);
      }, true);
    }

    // Having issues with Flash reloading on certain page actions
    // (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options.startTime) {
      _this.ready(function () {
        this.load();
        this.play();
        this.currentTime(options.startTime);
      }, true);
    }

    // Add global window functions that the swf expects
    // A 4.x workflow we weren't able to solve for in 5.0
    // because of the need to hard code these functions
    // into the swf for security reasons

    window_1.videojs = window_1.videojs || {};
    window_1.videojs.Flash = window_1.videojs.Flash || {};
    window_1.videojs.Flash.onReady = Flash.onReady;
    window_1.videojs.Flash.onEvent = Flash.onEvent;
    window_1.videojs.Flash.onError = Flash.onError;

    _this.on('seeked', function () {
      this.lastSeekTarget_ = undefined;
    });

    return _this;
  }

  /**
   * Create the `Flash` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Flash.prototype.createEl = function createEl() {
    var options = this.options_;

    // If video.js is hosted locally you should also set the location
    // for the hosted swf, which should be relative to the page (not video.js)
    // Otherwise this adds a CDN url.
    // The CDN also auto-adds a swf URL for that specific version.
    if (!options.swf) {
      // options.swf = `//vjs.zencdn.net/swf/${SWF_VERSION}/video-js.swf`;
      // options.swf = './player.swf';
      options.swf = unifyProtocol('//imgcache.qq.com/open/qcloud/video/tcplayer/player.swf');
    }

    // Generate ID for swf object
    var objId = options.techId;

    // Merge default flashvars with ones passed in to init
    var flashVars = mergeOptions$1({

      // SWF Callback Functions
      readyFunction: 'videojs.Flash.onReady',
      eventProxyFunction: 'videojs.Flash.onEvent',
      errorEventProxyFunction: 'videojs.Flash.onError',

      // Player Settings
      autoplay: options.autoplay,
      preload: options.preload,
      loop: options.loop,
      muted: options.muted

    }, options.flashVars);

    // Merge default parames with ones passed in
    var params = mergeOptions$1({
      // Opaque is needed to overlay controls, but can affect playback performance
      wmode: 'opaque',
      // Using bgcolor prevents a white flash when the object is loading
      bgcolor: '#000000'
    }, options.params);

    // Merge default attributes with ones passed in
    var attributes = mergeOptions$1({
      // Both ID and Name needed or swf to identify itself
      id: objId,
      name: objId,
      'class': 'vjs-tech'
    }, options.attributes);

    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);
    this.el_.tech = this;

    return this.el_;
  };

  /**
   * Called by {@link Player#play} to play using the `Flash` `Tech`.
   */


  Flash.prototype.play = function play() {
    if (this.ended()) {
      this.setCurrentTime(0);
    }
    this.el_.vjs_play();
  };

  /**
   * Called by {@link Player#pause} to pause using the `Flash` `Tech`.
   */


  Flash.prototype.pause = function pause() {
    this.el_.vjs_pause();
  };

  /**
   * A getter/setter for the `Flash` Tech's source object.
   * > Note: Please use {@link Flash#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `Flash` techs.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Flash.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.currentSrc();
    }

    // Setting src through `src` not `setSrc` will be deprecated
    return this.setSrc(_src);
  };

  /**
   * A getter/setter for the `Flash` Tech's source object.
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `Flash` techs.
   */


  Flash.prototype.setSrc = function setSrc(src) {
    var _this2 = this;

    // Make sure source URL is absolute.
    src = Url$1.getAbsoluteURL(src);
    this.el_.vjs_src(src);

    // Currently the SWF doesn't autoplay if you load a source later.
    // e.g. Load player w/ no source, wait 2s, set src.
    if (this.autoplay()) {
      this.setTimeout(function () {
        return _this2.play();
      }, 0);
    }
  };

  /**
   * Indicates whether the media is currently seeking to a new position or not.
   *
   * @return {boolean}
   *         - True if seeking to a new position
   *         - False otherwise
   */


  Flash.prototype.seeking = function seeking() {
    return this.lastSeekTarget_ !== undefined;
  };

  /**
   * Returns the current time in seconds that the media is at in playback.
   *
   * @param {number} time
   *        Current playtime of the media in seconds.
   */


  Flash.prototype.setCurrentTime = function setCurrentTime(time) {
    var seekable = this.seekable();

    if (seekable.length) {
      // clamp to the current seekable range
      time = time > seekable.start(0) ? time : seekable.start(0);
      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);

      this.lastSeekTarget_ = time;
      this.trigger('seeking');
      this.el_.vjs_setProperty('currentTime', time);
      _Tech.prototype.setCurrentTime.call(this);
    }
  };

  /**
   * Get the current playback time in seconds
   *
   * @return {number}
   *         The current time of playback in seconds.
   */


  Flash.prototype.currentTime = function currentTime() {
    // when seeking make the reported time keep up with the requested time
    // by reading the time we're seeking to
    if (this.seeking()) {
      return this.lastSeekTarget_ || 0;
    }
    return this.el_.vjs_getProperty('currentTime');
  };

  /**
   * Get the current source
   *
   * @method currentSrc
   * @return {Tech~SourceObject}
   *         The current source
   */


  Flash.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.vjs_getProperty('currentSrc');
  };

  /**
   * Get the total duration of the current media.
   *
   * @return {number}
   8          The total duration of the current media.
   */


  Flash.prototype.duration = function duration() {
    if (this.readyState() === 0) {
      return NaN;
    }
    var duration = this.el_.vjs_getProperty('duration');

    return duration >= 0 ? duration : Infinity;
  };

  /**
   * Load media into Tech.
   */


  Flash.prototype.load = function load() {
    this.el_.vjs_load();
  };

  /**
   * Get the poster image that was set on the tech.
   */


  Flash.prototype.poster = function poster() {
    this.el_.vjs_getProperty('poster');
  };

  /**
   * Poster images are not handled by the Flash tech so make this is a no-op.
   */


  Flash.prototype.setPoster = function setPoster() {};

  /**
   * Determine the time ranges that can be seeked to in the media.
   *
   * @return {TimeRange}
   *         Returns the time ranges that can be seeked to.
   */


  Flash.prototype.seekable = function seekable() {
    var duration = this.duration();

    if (duration === 0) {
      return createTimeRange();
    }
    return createTimeRange(0, duration);
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Flash.prototype.buffered = function buffered() {
    var ranges = this.el_.vjs_getProperty('buffered');

    if (ranges.length === 0) {
      return createTimeRange();
    }
    return createTimeRange(ranges[0][0], ranges[0][1]);
  };

  /**
   * Get fullscreen support -
   *
   * Flash does not allow fullscreen through javascript
   * so this always returns false.
   *
   * @return {boolean}
   *         The Flash tech does not support fullscreen, so it will always return false.
   */


  Flash.prototype.supportsFullScreen = function supportsFullScreen() {
    // Flash does not allow fullscreen through javascript
    return false;
  };

  /**
   * Flash does not allow fullscreen through javascript
   * so this always returns false.
   *
   * @return {boolean}
   *         The Flash tech does not support fullscreen, so it will always return false.
   */


  Flash.prototype.enterFullScreen = function enterFullScreen() {
    return false;
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Flash.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    var videoPlaybackQuality = this.el_.vjs_getProperty('getVideoPlaybackQuality');

    if (window_1.performance && typeof window_1.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window_1.performance.now();
    } else if (window_1.performance && window_1.performance.timing && typeof window_1.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window_1.Date.now() - window_1.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Flash;
}(Tech$2);

// Create setters and getters for attributes


var _readWrite = ['rtmpConnection', 'rtmpStream', 'preload', 'defaultPlaybackRate', 'playbackRate', 'autoplay', 'loop', 'controls', 'volume', 'muted', 'defaultMuted'];
var _readOnly = ['networkState', 'readyState', 'initialTime', 'startOffsetTime', 'paused', 'ended', 'videoWidth', 'videoHeight'];
var _api = Flash.prototype;

/**
 * Create setters for the swf on the element
 *
 * @param {string} attr
 *        The name of the parameter
 *
 * @private
 */
function _createSetter(attr) {
  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);

  _api['set' + attrUpper] = function (val) {
    return this.el_.vjs_setProperty(attr, val);
  };
}

/**
 * Create petters for the swf on the element
 *
 * @param {string} attr
 *        The name of the parameter
 *
 * @private
 */
function _createGetter(attr) {
  _api[attr] = function () {
    return this.el_.vjs_getProperty(attr);
  };
}

// Create getter and setters for all read/write attributes
for (var i$3 = 0; i$3 < _readWrite.length; i$3++) {
  _createGetter(_readWrite[i$3]);
  _createSetter(_readWrite[i$3]);
}

// Create getters for read-only attributes
for (var _i$1 = 0; _i$1 < _readOnly.length; _i$1++) {
  _createGetter(_readOnly[_i$1]);
}

/** ------------------------------ Getters ------------------------------ **/
/**
 * Get the value of `rtmpConnection` from the swf.
 *
 * @method Flash#rtmpConnection
 * @return {string}
 *         The current value of `rtmpConnection` on the swf.
 */

/**
 * Get the value of `rtmpStream` from the swf.
 *
 * @method Flash#rtmpStream
 * @return {string}
 *         The current value of `rtmpStream` on the swf.
 */

/**
 * Get the value of `preload` from the swf. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Flash#preload
 * @return {string}
 *         The value of `preload` from the swf. Will be 'none', 'metadata',
 *         or 'auto'.
 */

/**
 * Get the value of `defaultPlaybackRate` from the swf.
 *
 * @method Flash#defaultPlaybackRate
 * @return {number}
 *         The current value of `defaultPlaybackRate` on the swf.
 */

/**
 * Get the value of `playbackRate` from the swf. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Flash#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the swf. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 */

/**
 * Get the value of `autoplay` from the swf. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Flash#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the swf.
 *         - True indicates that the media ashould start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 */

/**
 * Get the value of `loop` from the swf. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Flash#loop
 * @return {boolean}
 *         - The value of `loop` from the swf.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 */

/**
 * Get the value of `mediaGroup` from the swf.
 *
 * @method Flash#mediaGroup
 * @return {string}
 *         The current value of `mediaGroup` on the swf.
 */

/**
 * Get the value of `controller` from the swf.
 *
 * @method Flash#controller
 * @return {string}
 *         The current value of `controller` on the swf.
 */

/**
 * Get the value of `controls` from the swf. `controls` indicates
 * whether the native flash controls should be shown or hidden.
 *
 * @method Flash#controls
 * @return {boolean}
 *         - The value of `controls` from the swf.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 */

/**
 * Get the value of the `volume` from the swf. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Flash#volume
 * @return {number}
 *         The volume percent as a decimal. Value will be between 0-1.
 */

/**
 * Get the value of the `muted` from the swf. `muted` indicates the current
 * audio level should be silent.
 *
 * @method Flash#muted
 * @return {boolean}
 *         - True if the audio should be set to silent
 *         - False otherwise
 */

/**
 * Get the value of `defaultMuted` from the swf. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. `muted` indicates the
 * current state.
 *
 * @method Flash#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the swf.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted.
 */

/**
 * Get the value of `networkState` from the swf. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Flash#networkState
 * @return {number}
 *         The value of `networkState` from the swf. This will be a number
 *         from the list in the description.
 */

/**
 * Get the value of `readyState` from the swf. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Flash#readyState
 * @return {number}
 *         The value of `readyState` from the swf. This will be a number
 *         from the list in the description.
 */

/**
 * Get the value of `readyState` from the swf. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Flash#readyState
 * @return {number}
 *         The value of `readyState` from the swf. This will be a number
 *         from the list in the description.
 */

/**
 * Get the value of `initialTime` from the swf.
 *
 * @method Flash#initialTime
 * @return {number}
 *         The `initialTime` proprety on the swf.
 */

/**
 * Get the value of `startOffsetTime` from the swf.
 *
 * @method Flash#startOffsetTime
 * @return {number}
 *         The `startOffsetTime` proprety on the swf.
 */

/**
 * Get the value of `paused` from the swf. `paused` indicates whether the swf
 * is current paused or not.
 *
 * @method Flash#paused
 * @return {boolean}
 *         The value of `paused` from the swf.
 */

/**
 * Get the value of `ended` from the swf. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Flash#ended
 * @return {boolean}
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */

/**
 * Get the value of `videoWidth` from the swf. `videoWidth` indicates
 * the current width of the media in css pixels.
 *
 * @method Flash#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the swf. This will be a number
 *         in css pixels.
 */

/**
 * Get the value of `videoHeight` from the swf. `videoHeigth` indicates
 * the current height of the media in css pixels.
 *
 * @method Flassh.prototype.videoHeight
 * @return {number}
 *         The value of `videoHeight` from the swf. This will be a number
 *         in css pixels.
 */
/** ------------------------------ Setters ------------------------------ **/

/**
 * Set the value of `rtmpConnection` on the swf.
 *
 * @method Flash#setRtmpConnection
 * @param {string} rtmpConnection
 *        New value to set the `rtmpConnection` property to.
 */

/**
 * Set the value of `rtmpStream` on the swf.
 *
 * @method Flash#setRtmpStream
 * @param {string} rtmpStream
 *        New value to set the `rtmpStream` property to.
 */

/**
 * Set the value of `preload` on the swf. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Flash#setPreload
 * @param {string} preload
 *        The value of `preload` to set on the swf. Should be 'none', 'metadata',
 *        or 'auto'.
 */

/**
 * Set the value of `defaultPlaybackRate` on the swf.
 *
 * @method Flash#setDefaultPlaybackRate
 * @param {number} defaultPlaybackRate
 *        New value to set the `defaultPlaybackRate` property to.
 */

/**
 * Set the value of `playbackRate` on the swf. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Flash#setPlaybackRate
 * @param {number} playbackRate
 *        New value of `playbackRate` on the swf. A number indicating
 *        the current playback speed of the media, where 1 is normal speed.
 */

/**
 * Set the value of `autoplay` on the swf. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Flash#setAutoplay
 * @param {boolean} autoplay
 *        - The value of `autoplay` from the swf.
 *        - True indicates that the media ashould start as soon as the page loads.
 *        - False indicates that the media should not start as soon as the page loads.
 */

/**
 * Set the value of `loop` on the swf. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Flash#setLoop
 * @param {boolean} loop
 *        - True indicates that playback should seek back to start once
 *          the end of a media is reached.
 *        - False indicates that playback should not loop back to the start when the
 *          end of the media is reached.
 */

/**
 * Set the value of `mediaGroup` on the swf.
 *
 * @method Flash#setMediaGroup
 * @param {string} mediaGroup
 *        New value of `mediaGroup` to set on the swf.
 */

/**
 * Set the value of `controller` on the swf.
 *
 * @method Flash#setController
 * @param {string} controller
 *        New value the current value of `controller` on the swf.
 */

/**
 * Get the value of `controls` from the swf. `controls` indicates
 * whether the native flash controls should be shown or hidden.
 *
 * @method Flash#controls
 * @return {boolean}
 *         - The value of `controls` from the swf.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 */

/**
 * Set the value of the `volume` on the swf. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Flash#setVolume
 * @param {number} percentAsDecimal
 *         The volume percent as a decimal. Value will be between 0-1.
 */

/**
 * Set the value of the `muted` on the swf. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Flash#setMuted
 * @param {boolean} muted
 *         - True if the audio should be set to silent
 *         - False otherwise
 */

/**
 * Set the value of `defaultMuted` on the swf. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. `muted` indicates the
 * current state.
 *
 * @method Flash#setDefaultMuted
 * @param {boolean} defaultMuted
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted.
 */

/* Flash Support Testing -------------------------------------------------------- */

/**
 * Check if the Flash tech is currently supported.
 *
 * @return {boolean}
 *          - True if the flash tech is supported.
 *          - False otherwise.
 */
Flash.isSupported = function () {
  return Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

// Add Source Handler pattern functions to this tech
Tech$2.withSourceHandlers(Flash);

/*
 * Native source handler for flash,  simply passes the source to the swf element.
 *
 * @property {Tech~SourceObject} source
 *           The source object
 *
 * @property {Flash} tech
 *           The instance of the Flash tech
 */
Flash.nativeSourceHandler = {};

/**
 * Check if the Flash can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canPlayType = function (type) {
  if (type in Flash.formats) {
    return 'maybe';
  }

  return '';
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'maybe', or '' (empty string).
 */
Flash.nativeSourceHandler.canHandleSource = function (source, options) {
  var type = void 0;

  /**
   * Guess the mime type of a file if it does not have one
   *
   * @param {Tech~SourceObject} src
   *        The source object to guess the mime type for
   *
   * @return {string}
   *         The mime type that was guessed
   */
  function guessMimeType(src) {
    var ext = Url$1.getFileExtension(src);

    if (ext) {
      return 'video/' + ext;
    }
    return '';
  }

  if (!source.type) {
    type = guessMimeType(source.src);
  } else {
    // Strip code information from the type because we don't get that specific
    type = source.type.replace(/;.*/, '').toLowerCase();
  }

  return Flash.nativeSourceHandler.canPlayType(type);
};

/**
 * Pass the source to the swf.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Flash} tech
 *        The instance of the Flash tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Flash.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * noop for native source handler dispose, as cleanup will happen automatically.
 */
Flash.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Flash.registerSourceHandler(Flash.nativeSourceHandler);

/**
 * Flash supported mime types.
 *
 * @constant {Object}
 */
Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

/**
 * Called when the the swf is "ready", and makes sure that the swf is really
 * ready using {@link Flash#checkReady}
 *
 * @param {Object} currSwf
 *        The current swf object
 */
Flash.onReady = function (currSwf) {
  var el = Dom$1.$('#' + currSwf);
  var tech = el && el.tech;

  // if there is no el then the tech has been disposed
  // and the tech element was removed from the player div
  if (tech && tech.el()) {
    // check that the flash object is really ready
    Flash.checkReady(tech);
  }
};

/**
 * The SWF isn't always ready when it says it is. Sometimes the API functions still
 * need to be added to the object. If it's not ready, we set a timeout to check again
 * shortly.
 *
 * @param {Flash} tech
 *        The instance of the flash tech to check.
 */
Flash.checkReady = function (tech) {
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    this.setTimeout(function () {
      Flash.checkReady(tech);
    }, 50);
  }
};

/**
 * Trigger events from the swf on the Flash Tech.
 *
 * @param {number} swfID
 *        The id of the swf that had the event
 *
 * @param {string} eventName
 *        The name of the event to trigger
 */
Flash.onEvent = function (swfID, eventName) {
  var tech = Dom$1.$('#' + swfID).tech;
  var args = Array.prototype.slice.call(arguments, 2);

  // dispatch Flash events asynchronously for two reasons:
  // - Flash swallows any exceptions generated by javascript it
  //   invokes
  // - Flash is suspended until the javascript returns which may cause
  //   playback performance issues
  tech.setTimeout(function () {
    tech.trigger(eventName, args);
  }, 1);
};

/**
 * Log errors from the swf on the Flash tech.
 *
 * @param {number} swfID
 *        The id of the swf that had an error.
 *
 * @param {string} err
 *        The error to set on the Flash Tech.
 *
 * @return {MediaError|undefined}
 *          - Returns a MediaError when err is 'srcnotfound'
 *          - Returns undefined otherwise.
 */
Flash.onError = function (swfID, err) {
  var tech = Dom$1.$('#' + swfID).tech;

  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED
  if (err === 'srcnotfound') {
    return tech.error(4);
  }

  // trigger a custom error
  tech.error('FLASH: ' + err);
};

/**
 * Get the current version of Flash that is in use on the page.
 *
 * @return {Array}
 *          an array of versions that are available.
 */
Flash.version = function () {
  var version = '0,0,0';

  // IE
  try {
    version = new window_1.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (err) {
    try {
      if (navigator$2.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator$2.plugins['Shockwave Flash 2.0'] || navigator$2.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {
      // satisfy linter
    }
  }
  return version.split(',');
};

/**
 * Only use for non-iframe embeds.
 *
 * @param {Object} swf
 *        The videojs-swf object.
 *
 * @param {Object} flashVars
 *        Names and values to use as flash option variables.
 *
 * @param {Object} params
 *        Style parameters to set on the object.
 *
 * @param {Object} attributes
 *        Attributes to set on the element.
 *
 * @return {Element}
 *          The embeded Flash DOM element.
 */
Flash.embed = function (swf, flashVars, params, attributes) {
  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);

  // Get element by embedding code and retrieving created element
  var obj = Dom$1.createEl('div', { innerHTML: code }).childNodes[0];

  return obj;
};

/**
 * Only use for non-iframe embeds.
 *
 * @param {Object} swf
 *        The videojs-swf object.
 *
 * @param {Object} flashVars
 *        Names and values to use as flash option variables.
 *
 * @param {Object} params
 *        Style parameters to set on the object.
 *
 * @param {Object} attributes
 *        Attributes to set on the element.
 *
 * @return {Element}
 *          The embeded Flash DOM element.
 */
Flash.getEmbedCode = function (swf, flashVars, params, attributes) {
  var objTag = '<object type="application/x-shockwave-flash" ';
  var flashVarsString = '';
  var paramsString = '';
  var attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    Object.getOwnPropertyNames(flashVars).forEach(function (key) {
      flashVarsString += key + '=' + flashVars[key] + '&amp;';
    });
  }

  // Add swf, flashVars, and other default params
  params = mergeOptions$1({
    movie: swf,
    flashvars: flashVarsString,
    // Required to talk to swf
    allowScriptAccess: 'always',
    // All should be default, but having security issues.
    allowNetworking: 'all'
  }, params);

  // Create param tags string
  Object.getOwnPropertyNames(params).forEach(function (key) {
    paramsString += '<param name="' + key + '" value="' + params[key] + '" />';
  });

  attributes = mergeOptions$1({
    // Add swf to attributes (need both for IE and Others to work)
    data: swf,

    // Default to 100% width/height
    width: '100%',
    height: '100%'

  }, attributes);

  // Create Attributes string
  Object.getOwnPropertyNames(attributes).forEach(function (key) {
    attrsString += key + '="' + attributes[key] + '" ';
  });

  return '' + objTag + attrsString + '>' + paramsString + '</object>';
};

// Run Flash through the RTMP decorator
FlashRtmpDecorator(Flash);

if (Tech$2.getTech('Flash')) {
  videojs.log.warn('Not using videojs-flash as it appears to already be registered');
  videojs.log.warn('videojs-flash should only be used with video.js@6 and above');
} else {
  videojs.registerTech('Flash', Flash);
}

// Flash.VERSION = VERSION;

var FlashlsSourceHandler = {};

var mpegurlRE$1 = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;

/**
 * Reports that Flash can play HLS.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'maybe', or '' (empty string)
 */
FlashlsSourceHandler.canPlayType = function (type) {
  return mpegurlRE$1.test(type) ? 'maybe' : '';
};

/**
 * Returns true if the source type indicates HLS content.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'maybe', or '' (empty string).
 */
FlashlsSourceHandler.canHandleSource = function (source, options) {
  return FlashlsSourceHandler.canPlayType(source.type) === 'maybe';
};

/**
 * Pass the source to the swf.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Flash} tech
 *        The instance of the Flash tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
FlashlsSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * No extra cleanup is necessary on dispose.
 */
FlashlsSourceHandler.dispose = function () {};

// Register the source handler and make sure it takes precedence over
// any other Flash source handlers for HLS
videojs.getTech('Flash').registerSourceHandler(FlashlsSourceHandler, 0);

// Use the flashls-enabled version of the video.js SWF
// videojs.options.flash.swf = 'https://players.brightcove.net/videojs-flashls/video-js.swf';
// videojs.options.flash.swf = '/docs/examples/page/video-js.swf';

// Include the version number.
FlashlsSourceHandler.VERSION = '__VERSION__';

var Play = "播放";
var Pause = "暂停";
var LIVE = "直播";
var Loaded = "加载完毕";
var Progress = "进度";
var Fullscreen = "全屏";
var Mute = "静音";
var Unmute = "取消静音";
var Subtitles = "字幕";
var Captions = "内嵌字幕";
var Chapters = "节目段落";
var Descriptions = "描述";
var Close = "关闭";
var Replay = "重播";
var Text = "文字";
var White = "白";
var Black = "黑";
var Red = "红";
var Green = "绿";
var Blue = "蓝";
var Yellow = "黄";
var Magenta = "紫红";
var Cyan = "青";
var Background = "背景";
var Window = "视窗";
var Transparent = "透明";
var Opaque = "不透明";
var None = "无";
var Raised = "浮雕";
var Depressed = "压低";
var Uniform = "均匀";
var Dropshadow = "下阴影";
var Casual = "舒适";
var Script = "手写体";
var Reset = "重启";
var Done = "完成";
var auto = "自动";
var Mirror = "镜像";
var CN = {
	Play: Play,
	Pause: Pause,
	LIVE: LIVE,
	Loaded: Loaded,
	Progress: Progress,
	Fullscreen: Fullscreen,
	Mute: Mute,
	Unmute: Unmute,
	Subtitles: Subtitles,
	Captions: Captions,
	Chapters: Chapters,
	Descriptions: Descriptions,
	Close: Close,
	Replay: Replay,
	Text: Text,
	White: White,
	Black: Black,
	Red: Red,
	Green: Green,
	Blue: Blue,
	Yellow: Yellow,
	Magenta: Magenta,
	Cyan: Cyan,
	Background: Background,
	Window: Window,
	Transparent: Transparent,
	Opaque: Opaque,
	None: None,
	Raised: Raised,
	Depressed: Depressed,
	Uniform: Uniform,
	Dropshadow: Dropshadow,
	Casual: Casual,
	Script: Script,
	Reset: Reset,
	Done: Done,
	auto: auto,
	Mirror: Mirror,
	"Current Time": "当前时间",
	"Duration Time": "时长",
	"Remaining Time": "剩余时间",
	"Stream Type": "媒体流类型",
	"Non-Fullscreen": "退出全屏",
	"Playback Rate": "播放速度",
	"subtitles off": "关闭字幕",
	"captions off": "关闭内嵌字幕",
	"Close Modal Dialog": "关闭弹窗",
	"descriptions off": "关闭描述",
	"Audio Track": "音轨",
	"You aborted the media playback": "视频播放被终止",
	"A network error caused the media download to fail part-way.": "网络错误导致视频下载中途失败。",
	"The media could not be loaded, either because the server or network failed or because the format is not supported.": "视频因格式不支持或者服务器或网络的问题无法加载。",
	"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "由于视频文件损坏或是该视频使用了你的浏览器不支持的功能，播放终止。",
	"No compatible source was found for this media.": "无法找到此视频兼容的源或者当前环境无法播放该视频。",
	"The media is encrypted and we do not have the keys to decrypt it.": "视频已加密，无法解密。",
	"Play Video": "播放视频",
	"Modal Window": "弹窗",
	"This is a modal window": "这是一个弹窗",
	"This modal can be closed by pressing the Escape key or activating the close button.": "可以按ESC按键或启用关闭按钮来关闭此弹窗。",
	", opens captions settings dialog": ", 开启标题设置弹窗",
	", opens subtitles settings dialog": ", 开启字幕设置弹窗",
	", opens descriptions settings dialog": ", 开启描述设置弹窗",
	", selected": ", 选择",
	"captions settings": "字幕设定",
	"Audio Player": "音频播放器",
	"Video Player": "视频播放器",
	"Progress Bar": "进度小节",
	"Volume Level": "音量",
	"subtitles settings": "字幕设定",
	"descriptions settings": "描述设定",
	"Semi-Transparent": "半透明",
	"Font Size": "字体尺寸",
	"Text Edge Style": "字体边缘样式",
	"Font Family": "字体库",
	"Proportional Sans-Serif": "比例无细体",
	"Monospace Sans-Serif": "单间隔无细体",
	"Proportional Serif": "比例细体",
	"Monospace Serif": "单间隔细体",
	"Small Caps": "小型大写字体",
	"restore all settings to the default values": "恢复全部设定至预设值",
	"Caption Settings Dialog": "字幕设定视窗",
	"Beginning of dialog window. Escape will cancel and close the window.": "开始对话视窗。离开会取消及关闭视窗",
	"End of dialog window.": "结束对话视窗",
	"Request timed out.": "请求超时，请稍后再试。",
	"Could not download the video.": "无法加载视频，请检查网络。",
	"Server is not respond.": "服务器请求失败，请稍后再试。",
	"Server respond error data.": "服务器返回数据有误，请稍后再试。",
	"Last time play at ": "上次看到 ",
	"Resume play": "恢复播放",
	"Powered by Tencent Cloud.": "腾讯云提供技术支持",
	"Rise an internal exception when playing HLS.": "播放 HLS 时出现内部异常。",
	"Authentication failed.": "防盗链参数鉴权失败。",
	"Server failed.": "媒体服务器错误。",
	"Get file error.": "媒体服务器获取文件错误。",
	"The media file does not exist. Please check if the fileID is correct.": "媒体文件不存在，请检查 fileID 是否正确。",
	"No video transcoding information found.": "没有找到视频转码信息。",
	"Current browser not support DRM.": "浏览器不支持当前 DRM 方案。",
	"The trial duration is illegal. The trial duration must be within the video duration.": "试看时长不合法，试看时长要在视频时长范围内。",
	"Param pcfg is not unique.": "pcfg 不唯一。",
	"The license has expired. Please check whether the expiration time setting is reasonable.": "license 过期，请检查过期时间设置是否合理。",
	"Did not find an adaptive stream that can be played.": "没有找到可以播放的自适应码流，<a href='https://cloud.tencent.com/document/product/266/34071' style='color: white;' target='_blank'>查看文档</a>。",
	"Invalid request format, please check the request format.": "请求格式不合法，请检查请求格式。",
	"AppID is not exist, Please check if the AppID is correct.": "AppID 不存在，请检查 AppID 是否正确。",
	"Without anti-leech information.": "没带防盗链检测。",
	"psign check failed.": "播放参数 psign 校验失败，<a href='https://cloud.tencent.com/document/product/266/45554' style='color: white' target='_blank'>查看文档</a>。",
	"Other errors.": "其他错误。",
	"Internal error.": "内部错误。",
	"Video statistic": "视频统计信息",
	"Play Next": "下一个",
	"Current browser not support play this stream, please select another one.": "无法找到此视频兼容的源或者当前环境无法播放该视频，请选择其他视频播放。",
	"Server respond error data.(eg. stream not exist)": "媒体服务器获取数据异常，可能该视频不存在，请选择其他视频播放。",
	"Video play failed, please refresh to start play again.": "视频播放器失败，请刷新并重新播放。",
	"Connection to the server has failed and the number of connection retries has exceeded the set value.": "媒体服务器连接异常，并达到最大重试次数，请检查网络是否正常并刷新重试",
	"Video decoding failure.": "视频解码失败，请选择其他视频播放。"
};

var log = videojs.log;
// const log = console.log;

//IE 8 fixed;
if (Function.prototype.bind && (typeof console === 'undefined' ? 'undefined' : _typeof(console)) == "object" && _typeof(console.log) == "object") {
  var logFns = ["log", "info", "warn", "error", "assert", "dir", "clear", "profile", "profileEnd"];

  for (var i$1 = 0; i$1 < logFns.length; i$1++) {
    var method = logFns[i$1];
    console[method] = Function.prototype.call.bind(console[method], console);
  }
}

videojs.addLanguage('zh-CN', CN);

function TCPlayer(id, options, ready) {
  var tag = void 0,
      initStart = new Date().getTime(),
      dom = videojs.dom;

  if (typeof id === 'string') {
    tag = document.querySelector('#' + id);
  } else if (id && id.nodeName) {
    tag = id;
  } else {
    throw new TypeError('The ID or element supplied is not valid.');
  }
  if (tag.nodeName.toLowerCase() != 'video' && tag.nodeName.toLowerCase() != 'audio') {
    throw new TypeError('The element type must be <video>.');
  }

  if (!dom.hasClass(tag, 'tcplayer')) {
    dom.addClass(tag, 'tcplayer');
  }
  if (!dom.hasClass(tag, 'video-js')) {
    dom.addClass(tag, 'video-js');
  }
  if (videojs.browser.IE_VERSION && (tag.style.width || tag.offsetWidth && tag.offsetWidth !== 300)) {
    // 避免设置了尺寸的情况下再动态设置宽高，在IE下会出现尺寸重置的情况。
    console.log('player width ' + tag.style.width);
    window_1.VIDEOJS_NO_DYNAMIC_STYLE = true;
  }

  var defaultOptions = {
    controls: true,
    language: 'zh-CN',
    // preload: 'auto',
    playbackRates: [0.5, 1, 1.25, 1.5, 2],
    controlBar: {
      volumePanel: {
        inline: tag.nodeName.toLowerCase() == 'video' ? false : true
      },
      fullscreenToggle: tag.nodeName.toLowerCase() == 'video' ? true : false,
      QualitySwitcherMenuButton: true
    },
    plugins: {
      Skin: '',
      VID: '',
      QualitySwitcher: {},
      MultiResolution: {},
      Errors: {},
      Reporter: {},
      ContextMenu: {},
      LevelSwitch: {},
      VttThumbnail: {},
      PlayerMetrics: {}
    }
  };
  // 默认开启的插件,有顺序要求，VID>QualitySwitcher>MultiResolution
  // if (options) {
  // options.playbackRates = options.playbackRates ? defaultOptions.playbackRates : defaultOptions.playbackRates;
  options = videojs.mergeOptions(defaultOptions, options);
  if (videojs.browser.IE_VERSION && videojs.browser.IE_VERSION < 11 && window_1 != window_1.top) {
    // 在不支持Fullscreen api 且 iframe中不显示全屏按钮
    // options.controlBar['fullscreenToggle'] = false;
  }
  if (options.autoplay && videojs.browser.IS_ANDROID && videojs.browser.IS_WECHAT) {
    //Android x5微信 （qq.com），设置自动播放，会触发playing，但是不会播放，并且劫持video插入一个播放按钮，因此设置autoplay为false
    options.autoplay = false;
  }
  log('player initializing', options);
  // }

  // logoImage 在player的Children中有顺序要求，需在封面之前初始化，通常情况下需要plugin来进行配置component的顺序，但是代码量较少，就在tcplayer处理。
  videojs.getComponent('player').prototype.options_.children.splice(1, 0, 'logoImage');

  var player = videojs(id, options, ready);
  // PlayerMetrics 播放指标数据收集插件在 player 初始化后才可以调用
  player.PlayerMetrics(options).setTimingData({ initStart: initStart });
  log('player initialized', options);
  return player;
}

// TCPlayer.videojs = videojs;
// Object.assign(TCPlayer, videojs);
// 兼容IE11的写法
Object.keys(videojs).forEach(function (key) {
  TCPlayer[key] = videojs[key];
});

// class TCPlayer extends videojs{
//   constructor(id, options, ready) {
//     return super(id, options, ready);
//   }
// }

return TCPlayer;

})));
